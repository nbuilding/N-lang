start: (instruction ((";" | "\n") instruction)*)

instruction: declare (";")?
           | print (";")?
           | function_callback (";")?
           | function_callback_quirky (";")?
           | function_callback_quirky_pipe (";")?
           | for (";")?
           | imp (";")?
           | return (";")?
           | if (";")?
           | ifelse (";")?
           | vary (";")?
           | enum_definition (";")?
           | alias_definition (";")?

// functions
vary: "var " NAME "=" expression
declare: "let " modifier name_type "=" expression
enum_definition: "type" modifier declaration_with_typevars "=" enum_constructors
alias_definition: "alias" modifier declaration_with_typevars "=" types
print: "print" expression
function_callback: "<" function_call ">"
function_callback_quirky: value ".<" function_call ">"
function_callback_quirky_pipe: value "|>" "<" function_call ">"
for: "for" name_type NUMBER code_block
imp: "import" NAME
impn: "imp" NAME
return: "return" expression
if: "if" condition ("{"? expression "}"? | "{"? instruction "}"? | code_block)
ifelse: "if" condition ("{"? expression "}"? | "{"? instruction "}"? | code_block) "else" ("{"? instruction "}"? | code_block)
ifelse_expr: "if" condition "{"? expression "}"? "else" "{"? expression "}"?
?condition: expression
          | conditional_let
conditional_let: "let" cond_pattern "=" expression

//helpers
name_type: definite_pattern [":" types]
function_dec_call: NAME (" " [name_type (" " name_type)*])?
function_call : literal (" " literal)*
code_block: "{" instruction* "}"
function_def: arguments ["->" types] code_block
arguments: "[" generic_declaration? (name_type (" " name_type)*)? "]"
generic_declaration: "[" (NAME ",")* NAME "]"
anonymous_func: arguments "->" NAME ":" (instruction (";" instruction)*)
char: "\\" ( escape_code | "{" /./ "}")
escape_code: /[tnr]/
tupledef: "(" types ("," types)* ")"
with_typevars: module_type "[" types ("," types)* "]"
declaration_with_typevars: NAME ("[" NAME ("," NAME)* "]")?
tupleval: "(" expression ("," expression)* ")"
listval: "[" (expression ("," expression)*)? "]"
recordval: "{" (record_entry (";" | "\n"))* record_entry (";" | "\n")? "}"
enum_constructors: enum_constructor ("|" enum_constructor)*
enum_constructor: modifier "<" NAME types* ">"
                | modifier NAME

modifier: PUBLIC?

?record_entry: NAME ":" expression
             | NAME

?any_pattern: definite_pattern_value
            | cond_pattern_value

?definite_pattern: definite_pattern_value
                 | tuple_pattern
?definite_pattern_value: NAME
                       | "_"
                       | "(" definite_pattern ")"
                       | record_pattern
tuple_pattern: (definite_pattern_value ",")+ definite_pattern_value
record_pattern: "{" (record_entry_pattern (";" | "\n"))* record_entry_pattern "}"
?record_entry_pattern: NAME
                     | NAME ":" definite_pattern

?cond_pattern: cond_pattern_value
?cond_pattern_value: "(" cond_pattern_value ")"
                   | list_pattern
                   | enum_pattern
list_pattern: "[" (any_pattern ("," any_pattern)*)? "]"
enum_pattern: "<" NAME any_pattern* ">"

// Boolean and number expressions, with order of operations.
// Question mark "inlines" the branch, so we don't get nested
// boolean_expression(or_expression(and_expression etc)).
// Square brackets mean that the stuff inside it can appear 0 or 1 time. Same as
// (whatever)?

?types: module_type
      | tupledef
      | with_typevars
      | UNIT
module_type: [NAME "."]* NAME

?expression: ifelse_expr
           | boolean_expression
           | function_def
           | anonymous_func

?boolean_expression: or_expression
?or_expression: [or_expression OR] and_expression
?and_expression: [and_expression AND] not_expression
?not_expression: compare_expression
               | NOT_KW not_expression
?compare_expression: [compare_expression compare_operator] number_expression
?compare_operator: EQUALS
                 | GORE
                 | LORE
                 | LESS
                 | GREATER
                 | NEQUALS

?number_expression: sum_expression
?sum_expression: [sum_expression (ADD | SUBTRACT)] product_expression
?product_expression: [product_expression (MULTIPLY | DIVIDE | ROUNDDIV | MODULO)] exponent_expression
// Exponentiation right to left associative
?exponent_expression: unary_expression [EXPONENT exponent_expression]
?unary_expression: await_expression
                 | NOT unary_expression
                 | SUBTRACT unary_expression
?await_expression: record_access
                 | await_expression AWAIT
?record_access: value
              | record_access "." NAME
value: NUMBER
     | BOOLEAN
     | STRING
     | NAME
     | "(" expression ")"
     | UNIT
     | function_callback
     | function_callback_quirky
     | function_callback_quirky_pipe
     | char
     | tupleval
     | listval
     | recordval
     | impn

// Alias for unary_expression. Used for values that visually look tightly bound,
// which is important for function arguments since they're separated by spaces.
// For example, <myFunction 1 + 1 2> looks ambiguous; <myFunction (1 + 1) 2>
// should be used instead. However, <myFunction -num a.b> is pretty clearly
// <myFunction (-num) (a.b)> so they don't need parentheses.
?literal: unary_expression

//constants
BOOLEAN: ("true" | "false")
COMMENT: "//" /[^\n]/*
OR: ("||" | "|")
AND: ("&&" | "&")
EQUALS: ("==" | "=")
GORE: ">="
LORE: "<="
LESS: "<"
GREATER: ">"
NEQUALS: ("/=" | "!=")
NOT_KW: "not"
NOT: "~"
ADD: "+"
SUBTRACT: "-"
MULTIPLY: "*"
DIVIDE: "/"
ROUNDDIV: "//"
MODULO: "%"
EXPONENT: "^"
AWAIT: "!"
PUBLIC: "pub"
UNIT: "()"
%import common.ESCAPED_STRING -> STRING
%import common.SIGNED_NUMBER  -> NUMBER
%import common.CNAME  -> NAME
%import common.WS
%ignore WS
%ignore COMMENT
