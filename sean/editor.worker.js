/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js":
/*!*****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/arrays.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayInsert": () => (/* binding */ arrayInsert),
/* harmony export */   "asArray": () => (/* binding */ asArray),
/* harmony export */   "binarySearch": () => (/* binding */ binarySearch),
/* harmony export */   "coalesce": () => (/* binding */ coalesce),
/* harmony export */   "distinct": () => (/* binding */ distinct),
/* harmony export */   "distinctES6": () => (/* binding */ distinctES6),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "findFirstInSorted": () => (/* binding */ findFirstInSorted),
/* harmony export */   "first": () => (/* binding */ first),
/* harmony export */   "firstIndex": () => (/* binding */ firstIndex),
/* harmony export */   "firstOrDefault": () => (/* binding */ firstOrDefault),
/* harmony export */   "flatten": () => (/* binding */ flatten),
/* harmony export */   "groupBy": () => (/* binding */ groupBy),
/* harmony export */   "isFalsyOrEmpty": () => (/* binding */ isFalsyOrEmpty),
/* harmony export */   "isNonEmptyArray": () => (/* binding */ isNonEmptyArray),
/* harmony export */   "mergeSort": () => (/* binding */ mergeSort),
/* harmony export */   "pushToEnd": () => (/* binding */ pushToEnd),
/* harmony export */   "pushToStart": () => (/* binding */ pushToStart),
/* harmony export */   "range": () => (/* binding */ range),
/* harmony export */   "tail": () => (/* binding */ tail),
/* harmony export */   "tail2": () => (/* binding */ tail2)
/* harmony export */ });
/**
 * Returns the last element of an array.
 * @param array The array.
 * @param n Which element from the end (default is zero).
 */
function tail(array, n = 0) {
    return array[array.length - (1 + n)];
}
function tail2(arr) {
    if (arr.length === 0) {
        throw new Error('Invalid tail call');
    }
    return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];
}
function equals(one, other, itemEquals = (a, b) => a === b) {
    if (one === other) {
        return true;
    }
    if (!one || !other) {
        return false;
    }
    if (one.length !== other.length) {
        return false;
    }
    for (let i = 0, len = one.length; i < len; i++) {
        if (!itemEquals(one[i], other[i])) {
            return false;
        }
    }
    return true;
}
function binarySearch(array, key, comparator) {
    let low = 0, high = array.length - 1;
    while (low <= high) {
        const mid = ((low + high) / 2) | 0;
        const comp = comparator(array[mid], key);
        if (comp < 0) {
            low = mid + 1;
        }
        else if (comp > 0) {
            high = mid - 1;
        }
        else {
            return mid;
        }
    }
    return -(low + 1);
}
/**
 * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false
 * are located before all elements where p(x) is true.
 * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.
 */
function findFirstInSorted(array, p) {
    let low = 0, high = array.length;
    if (high === 0) {
        return 0; // no children
    }
    while (low < high) {
        const mid = Math.floor((low + high) / 2);
        if (p(array[mid])) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    return low;
}
/**
 * Like `Array#sort` but always stable. Usually runs a little slower `than Array#sort`
 * so only use this when actually needing stable sort.
 */
function mergeSort(data, compare) {
    _sort(data, compare, 0, data.length - 1, []);
    return data;
}
function _merge(a, compare, lo, mid, hi, aux) {
    let leftIdx = lo, rightIdx = mid + 1;
    for (let i = lo; i <= hi; i++) {
        aux[i] = a[i];
    }
    for (let i = lo; i <= hi; i++) {
        if (leftIdx > mid) {
            // left side consumed
            a[i] = aux[rightIdx++];
        }
        else if (rightIdx > hi) {
            // right side consumed
            a[i] = aux[leftIdx++];
        }
        else if (compare(aux[rightIdx], aux[leftIdx]) < 0) {
            // right element is less -> comes first
            a[i] = aux[rightIdx++];
        }
        else {
            // left element comes first (less or equal)
            a[i] = aux[leftIdx++];
        }
    }
}
function _sort(a, compare, lo, hi, aux) {
    if (hi <= lo) {
        return;
    }
    const mid = lo + ((hi - lo) / 2) | 0;
    _sort(a, compare, lo, mid, aux);
    _sort(a, compare, mid + 1, hi, aux);
    if (compare(a[mid], a[mid + 1]) <= 0) {
        // left and right are sorted and if the last-left element is less
        // or equals than the first-right element there is nothing else
        // to do
        return;
    }
    _merge(a, compare, lo, mid, hi, aux);
}
function groupBy(data, compare) {
    const result = [];
    let currentGroup = undefined;
    for (const element of mergeSort(data.slice(0), compare)) {
        if (!currentGroup || compare(currentGroup[0], element) !== 0) {
            currentGroup = [element];
            result.push(currentGroup);
        }
        else {
            currentGroup.push(element);
        }
    }
    return result;
}
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
function coalesce(array) {
    return array.filter(e => !!e);
}
/**
 * @returns false if the provided object is an array and not empty.
 */
function isFalsyOrEmpty(obj) {
    return !Array.isArray(obj) || obj.length === 0;
}
function isNonEmptyArray(obj) {
    return Array.isArray(obj) && obj.length > 0;
}
/**
 * Removes duplicates from the given array. The optional keyFn allows to specify
 * how elements are checked for equalness by returning a unique string for each.
 */
function distinct(array, keyFn) {
    if (!keyFn) {
        return array.filter((element, position) => {
            return array.indexOf(element) === position;
        });
    }
    const seen = Object.create(null);
    return array.filter((elem) => {
        const key = keyFn(elem);
        if (seen[key]) {
            return false;
        }
        seen[key] = true;
        return true;
    });
}
function distinctES6(array) {
    const seen = new Set();
    return array.filter(element => {
        if (seen.has(element)) {
            return false;
        }
        seen.add(element);
        return true;
    });
}
/**
 * @deprecated ES6: use `Array.findIndex`
 */
function firstIndex(array, fn) {
    for (let i = 0; i < array.length; i++) {
        const element = array[i];
        if (fn(element)) {
            return i;
        }
    }
    return -1;
}
function first(array, fn, notFoundValue = undefined) {
    const index = firstIndex(array, fn);
    return index < 0 ? notFoundValue : array[index];
}
function firstOrDefault(array, notFoundValue) {
    return array.length > 0 ? array[0] : notFoundValue;
}
function flatten(arr) {
    return [].concat(...arr);
}
function range(arg, to) {
    let from = typeof to === 'number' ? arg : 0;
    if (typeof to === 'number') {
        from = arg;
    }
    else {
        from = 0;
        to = arg;
    }
    const result = [];
    if (from <= to) {
        for (let i = from; i < to; i++) {
            result.push(i);
        }
    }
    else {
        for (let i = from; i > to; i--) {
            result.push(i);
        }
    }
    return result;
}
/**
 * Insert `insertArr` inside `target` at `insertIndex`.
 * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array
 */
function arrayInsert(target, insertIndex, insertArr) {
    const before = target.slice(0, insertIndex);
    const after = target.slice(insertIndex);
    return before.concat(insertArr, after);
}
/**
 * Pushes an element to the start of the array, if found.
 */
function pushToStart(arr, value) {
    const index = arr.indexOf(value);
    if (index > -1) {
        arr.splice(index, 1);
        arr.unshift(value);
    }
}
/**
 * Pushes an element to the end of the array, if found.
 */
function pushToEnd(arr, value) {
    const index = arr.indexOf(value);
    if (index > -1) {
        arr.splice(index, 1);
        arr.push(value);
    }
}
function asArray(x) {
    return Array.isArray(x) ? x : [x];
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/cancellation.js":
/*!***********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/cancellation.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CancellationToken": () => (/* binding */ CancellationToken),
/* harmony export */   "CancellationTokenSource": () => (/* binding */ CancellationTokenSource)
/* harmony export */ });
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const shortcutEvent = Object.freeze(function (callback, context) {
    const handle = setTimeout(callback.bind(context), 0);
    return { dispose() { clearTimeout(handle); } };
});
var CancellationToken;
(function (CancellationToken) {
    function isCancellationToken(thing) {
        if (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {
            return true;
        }
        if (thing instanceof MutableToken) {
            return true;
        }
        if (!thing || typeof thing !== 'object') {
            return false;
        }
        return typeof thing.isCancellationRequested === 'boolean'
            && typeof thing.onCancellationRequested === 'function';
    }
    CancellationToken.isCancellationToken = isCancellationToken;
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: _event_js__WEBPACK_IMPORTED_MODULE_0__.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: shortcutEvent
    });
})(CancellationToken || (CancellationToken = {}));
class MutableToken {
    constructor() {
        this._isCancelled = false;
        this._emitter = null;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new _event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = null;
        }
    }
}
class CancellationTokenSource {
    constructor(parent) {
        this._token = undefined;
        this._parentListener = undefined;
        this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
    }
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else if (this._token instanceof MutableToken) {
            // actually cancel
            this._token.cancel();
        }
    }
    dispose(cancel = false) {
        if (cancel) {
            this.cancel();
        }
        if (this._parentListener) {
            this._parentListener.dispose();
        }
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js":
/*!********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Debug": () => (/* binding */ Debug),
/* harmony export */   "LcsDiff": () => (/* binding */ LcsDiff),
/* harmony export */   "MyArray": () => (/* binding */ MyArray),
/* harmony export */   "StringDiffSequence": () => (/* binding */ StringDiffSequence),
/* harmony export */   "stringDiff": () => (/* binding */ stringDiff)
/* harmony export */ });
/* harmony import */ var _diffChange_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./diffChange.js */ "./node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js");
/* harmony import */ var _hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hash.js */ "./node_modules/monaco-editor/esm/vs/base/common/hash.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


class StringDiffSequence {
    constructor(source) {
        this.source = source;
    }
    getElements() {
        const source = this.source;
        const characters = new Int32Array(source.length);
        for (let i = 0, len = source.length; i < len; i++) {
            characters[i] = source.charCodeAt(i);
        }
        return characters;
    }
}
function stringDiff(original, modified, pretty) {
    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;
}
//
// The code below has been ported from a C# implementation in VS
//
class Debug {
    static Assert(condition, message) {
        if (!condition) {
            throw new Error(message);
        }
    }
}
class MyArray {
    /**
     * Copies a range of elements from an Array starting at the specified source index and pastes
     * them to another Array starting at the specified destination index. The length and the indexes
     * are specified as 64-bit integers.
     * sourceArray:
     *		The Array that contains the data to copy.
     * sourceIndex:
     *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
     * destinationArray:
     *		The Array that receives the data.
     * destinationIndex:
     *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
     * length:
     *		A 64-bit integer that represents the number of elements to copy.
     */
    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
        for (let i = 0; i < length; i++) {
            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
        }
    }
    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
        for (let i = 0; i < length; i++) {
            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
        }
    }
}
/**
 * A utility class which helps to create the set of DiffChanges from
 * a difference operation. This class accepts original DiffElements and
 * modified DiffElements that are involved in a particular change. The
 * MarktNextChange() method can be called to mark the separation between
 * distinct changes. At the end, the Changes property can be called to retrieve
 * the constructed changes.
 */
class DiffChangeHelper {
    /**
     * Constructs a new DiffChangeHelper for the given DiffSequences.
     */
    constructor() {
        this.m_changes = [];
        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;
        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;
        this.m_originalCount = 0;
        this.m_modifiedCount = 0;
    }
    /**
     * Marks the beginning of the next change in the set of differences.
     */
    MarkNextChange() {
        // Only add to the list if there is something to add
        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            // Add the new change to our list
            this.m_changes.push(new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
        }
        // Reset for the next change
        this.m_originalCount = 0;
        this.m_modifiedCount = 0;
        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;
        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;
    }
    /**
     * Adds the original element at the given position to the elements
     * affected by the current change. The modified index gives context
     * to the change position with respect to the original sequence.
     * @param originalIndex The index of the original element to add.
     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
     */
    AddOriginalElement(originalIndex, modifiedIndex) {
        // The 'true' start index is the smallest of the ones we've seen
        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
        this.m_originalCount++;
    }
    /**
     * Adds the modified element at the given position to the elements
     * affected by the current change. The original index gives context
     * to the change position with respect to the modified sequence.
     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
     * @param modifiedIndex The index of the modified element to add.
     */
    AddModifiedElement(originalIndex, modifiedIndex) {
        // The 'true' start index is the smallest of the ones we've seen
        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
        this.m_modifiedCount++;
    }
    /**
     * Retrieves all of the changes marked by the class.
     */
    getChanges() {
        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            // Finish up on whatever is left
            this.MarkNextChange();
        }
        return this.m_changes;
    }
    /**
     * Retrieves all of the changes marked by the class in the reverse order
     */
    getReverseChanges() {
        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            // Finish up on whatever is left
            this.MarkNextChange();
        }
        this.m_changes.reverse();
        return this.m_changes;
    }
}
/**
 * An implementation of the difference algorithm described in
 * "An O(ND) Difference Algorithm and its variations" by Eugene W. Myers
 */
class LcsDiff {
    /**
     * Constructs the DiffFinder
     */
    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {
        this.ContinueProcessingPredicate = continueProcessingPredicate;
        const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);
        const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);
        this._hasStrings = (originalHasStrings && modifiedHasStrings);
        this._originalStringElements = originalStringElements;
        this._originalElementsOrHash = originalElementsOrHash;
        this._modifiedStringElements = modifiedStringElements;
        this._modifiedElementsOrHash = modifiedElementsOrHash;
        this.m_forwardHistory = [];
        this.m_reverseHistory = [];
    }
    static _isStringArray(arr) {
        return (arr.length > 0 && typeof arr[0] === 'string');
    }
    static _getElements(sequence) {
        const elements = sequence.getElements();
        if (LcsDiff._isStringArray(elements)) {
            const hashes = new Int32Array(elements.length);
            for (let i = 0, len = elements.length; i < len; i++) {
                hashes[i] = (0,_hash_js__WEBPACK_IMPORTED_MODULE_1__.stringHash)(elements[i], 0);
            }
            return [elements, hashes, true];
        }
        if (elements instanceof Int32Array) {
            return [[], elements, false];
        }
        return [[], new Int32Array(elements), false];
    }
    ElementsAreEqual(originalIndex, newIndex) {
        if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {
            return false;
        }
        return (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);
    }
    OriginalElementsAreEqual(index1, index2) {
        if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {
            return false;
        }
        return (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);
    }
    ModifiedElementsAreEqual(index1, index2) {
        if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {
            return false;
        }
        return (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);
    }
    ComputeDiff(pretty) {
        return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
    }
    /**
     * Computes the differences between the original and modified input
     * sequences on the bounded range.
     * @returns An array of the differences between the two input sequences.
     */
    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
        const quitEarlyArr = [false];
        let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
        if (pretty) {
            // We have to clean up the computed diff to be more intuitive
            // but it turns out this cannot be done correctly until the entire set
            // of diffs have been computed
            changes = this.PrettifyChanges(changes);
        }
        return {
            quitEarly: quitEarlyArr[0],
            changes: changes
        };
    }
    /**
     * Private helper method which computes the differences on the bounded range
     * recursively.
     * @returns An array of the differences between the two input sequences.
     */
    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
        quitEarlyArr[0] = false;
        // Find the start of the differences
        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
            originalStart++;
            modifiedStart++;
        }
        // Find the end of the differences
        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
            originalEnd--;
            modifiedEnd--;
        }
        // In the special case where we either have all insertions or all deletions or the sequences are identical
        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
            let changes;
            if (modifiedStart <= modifiedEnd) {
                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');
                // All insertions
                changes = [
                    new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
                ];
            }
            else if (originalStart <= originalEnd) {
                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');
                // All deletions
                changes = [
                    new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
                ];
            }
            else {
                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');
                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');
                // Identical sequences - No differences
                changes = [];
            }
            return changes;
        }
        // This problem can be solved using the Divide-And-Conquer technique.
        const midOriginalArr = [0];
        const midModifiedArr = [0];
        const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
        const midOriginal = midOriginalArr[0];
        const midModified = midModifiedArr[0];
        if (result !== null) {
            // Result is not-null when there was enough memory to compute the changes while
            // searching for the recursion point
            return result;
        }
        else if (!quitEarlyArr[0]) {
            // We can break the problem down recursively by finding the changes in the
            // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)
            // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)
            // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point
            const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
            let rightChanges = [];
            if (!quitEarlyArr[0]) {
                rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
            }
            else {
                // We did't have time to finish the first half, so we don't have time to compute this half.
                // Consider the entire rest of the sequence different.
                rightChanges = [
                    new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
                ];
            }
            return this.ConcatenateChanges(leftChanges, rightChanges);
        }
        // If we hit here, we quit early, and so can't return anything meaningful
        return [
            new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
        ];
    }
    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
        let forwardChanges = null;
        let reverseChanges = null;
        // First, walk backward through the forward diagonals history
        let changeHelper = new DiffChangeHelper();
        let diagonalMin = diagonalForwardStart;
        let diagonalMax = diagonalForwardEnd;
        let diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;
        let lastOriginalIndex = -1073741824 /* MIN_SAFE_SMALL_INTEGER */;
        let historyIndex = this.m_forwardHistory.length - 1;
        do {
            // Get the diagonal index from the relative diagonal number
            const diagonal = diagonalRelative + diagonalForwardBase;
            // Figure out where we came from
            if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {
                // Vertical line (the element is an insert)
                originalIndex = forwardPoints[diagonal + 1];
                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
                if (originalIndex < lastOriginalIndex) {
                    changeHelper.MarkNextChange();
                }
                lastOriginalIndex = originalIndex;
                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
                diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration
            }
            else {
                // Horizontal line (the element is a deletion)
                originalIndex = forwardPoints[diagonal - 1] + 1;
                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
                if (originalIndex < lastOriginalIndex) {
                    changeHelper.MarkNextChange();
                }
                lastOriginalIndex = originalIndex - 1;
                changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
                diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration
            }
            if (historyIndex >= 0) {
                forwardPoints = this.m_forwardHistory[historyIndex];
                diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot
                diagonalMin = 1;
                diagonalMax = forwardPoints.length - 1;
            }
        } while (--historyIndex >= -1);
        // Ironically, we get the forward changes as the reverse of the
        // order we added them since we technically added them backwards
        forwardChanges = changeHelper.getReverseChanges();
        if (quitEarlyArr[0]) {
            // TODO: Calculate a partial from the reverse diagonals.
            //       For now, just assume everything after the midOriginal/midModified point is a diff
            let originalStartPoint = midOriginalArr[0] + 1;
            let modifiedStartPoint = midModifiedArr[0] + 1;
            if (forwardChanges !== null && forwardChanges.length > 0) {
                const lastForwardChange = forwardChanges[forwardChanges.length - 1];
                originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
                modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
            }
            reverseChanges = [
                new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
            ];
        }
        else {
            // Now walk backward through the reverse diagonals history
            changeHelper = new DiffChangeHelper();
            diagonalMin = diagonalReverseStart;
            diagonalMax = diagonalReverseEnd;
            diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;
            lastOriginalIndex = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;
            historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
            do {
                // Get the diagonal index from the relative diagonal number
                const diagonal = diagonalRelative + diagonalReverseBase;
                // Figure out where we came from
                if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {
                    // Horizontal line (the element is a deletion))
                    originalIndex = reversePoints[diagonal + 1] - 1;
                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
                    if (originalIndex > lastOriginalIndex) {
                        changeHelper.MarkNextChange();
                    }
                    lastOriginalIndex = originalIndex + 1;
                    changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
                    diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration
                }
                else {
                    // Vertical line (the element is an insertion)
                    originalIndex = reversePoints[diagonal - 1];
                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
                    if (originalIndex > lastOriginalIndex) {
                        changeHelper.MarkNextChange();
                    }
                    lastOriginalIndex = originalIndex;
                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
                    diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration
                }
                if (historyIndex >= 0) {
                    reversePoints = this.m_reverseHistory[historyIndex];
                    diagonalReverseBase = reversePoints[0]; //We stored this in the first spot
                    diagonalMin = 1;
                    diagonalMax = reversePoints.length - 1;
                }
            } while (--historyIndex >= -1);
            // There are cases where the reverse history will find diffs that
            // are correct, but not intuitive, so we need shift them.
            reverseChanges = changeHelper.getChanges();
        }
        return this.ConcatenateChanges(forwardChanges, reverseChanges);
    }
    /**
     * Given the range to compute the diff on, this method finds the point:
     * (midOriginal, midModified)
     * that exists in the middle of the LCS of the two sequences and
     * is the point at which the LCS problem may be broken down recursively.
     * This method will try to keep the LCS trace in memory. If the LCS recursion
     * point is calculated and the full trace is available in memory, then this method
     * will return the change list.
     * @param originalStart The start bound of the original sequence range
     * @param originalEnd The end bound of the original sequence range
     * @param modifiedStart The start bound of the modified sequence range
     * @param modifiedEnd The end bound of the modified sequence range
     * @param midOriginal The middle point of the original sequence range
     * @param midModified The middle point of the modified sequence range
     * @returns The diff changes, if available, otherwise null
     */
    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
        let originalIndex = 0, modifiedIndex = 0;
        let diagonalForwardStart = 0, diagonalForwardEnd = 0;
        let diagonalReverseStart = 0, diagonalReverseEnd = 0;
        // To traverse the edit graph and produce the proper LCS, our actual
        // start position is just outside the given boundary
        originalStart--;
        modifiedStart--;
        // We set these up to make the compiler happy, but they will
        // be replaced before we return with the actual recursion point
        midOriginalArr[0] = 0;
        midModifiedArr[0] = 0;
        // Clear out the history
        this.m_forwardHistory = [];
        this.m_reverseHistory = [];
        // Each cell in the two arrays corresponds to a diagonal in the edit graph.
        // The integer value in the cell represents the originalIndex of the furthest
        // reaching point found so far that ends in that diagonal.
        // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.
        const maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);
        const numDiagonals = maxDifferences + 1;
        const forwardPoints = new Int32Array(numDiagonals);
        const reversePoints = new Int32Array(numDiagonals);
        // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)
        // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)
        const diagonalForwardBase = (modifiedEnd - modifiedStart);
        const diagonalReverseBase = (originalEnd - originalStart);
        // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the
        //    diagonal number (relative to diagonalForwardBase)
        // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the
        //    diagonal number (relative to diagonalReverseBase)
        const diagonalForwardOffset = (originalStart - modifiedStart);
        const diagonalReverseOffset = (originalEnd - modifiedEnd);
        // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers
        //   relative to the start diagonal with diagonal numbers relative to the end diagonal.
        // The Even/Oddn-ness of this delta is important for determining when we should check for overlap
        const delta = diagonalReverseBase - diagonalForwardBase;
        const deltaIsEven = (delta % 2 === 0);
        // Here we set up the start and end points as the furthest points found so far
        // in both the forward and reverse directions, respectively
        forwardPoints[diagonalForwardBase] = originalStart;
        reversePoints[diagonalReverseBase] = originalEnd;
        // Remember if we quit early, and thus need to do a best-effort result instead of a real result.
        quitEarlyArr[0] = false;
        // A couple of points:
        // --With this method, we iterate on the number of differences between the two sequences.
        //   The more differences there actually are, the longer this will take.
        // --Also, as the number of differences increases, we have to search on diagonals further
        //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).
        // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences
        //   is even and odd diagonals only when numDifferences is odd.
        for (let numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {
            let furthestOriginalIndex = 0;
            let furthestModifiedIndex = 0;
            // Run the algorithm in the forward direction
            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
            for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
                // STEP 1: We extend the furthest reaching point in the present diagonal
                // by looking at the diagonals above and below and picking the one whose point
                // is further away from the start point (originalStart, modifiedStart)
                if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {
                    originalIndex = forwardPoints[diagonal + 1];
                }
                else {
                    originalIndex = forwardPoints[diagonal - 1] + 1;
                }
                modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
                // Save the current originalIndex so we can test for false overlap in step 3
                const tempOriginalIndex = originalIndex;
                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal
                // so long as the elements are equal.
                while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
                    originalIndex++;
                    modifiedIndex++;
                }
                forwardPoints[diagonal] = originalIndex;
                if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
                    furthestOriginalIndex = originalIndex;
                    furthestModifiedIndex = modifiedIndex;
                }
                // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)
                // and diagonal is in the range of reverse diagonals computed for numDifferences-1
                // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)
                // then check for overlap.
                if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {
                    if (originalIndex >= reversePoints[diagonal]) {
                        midOriginalArr[0] = originalIndex;
                        midModifiedArr[0] = modifiedIndex;
                        if (tempOriginalIndex <= reversePoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {
                            // BINGO! We overlapped, and we have the full trace in memory!
                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                        }
                        else {
                            // Either false overlap, or we didn't have enough memory for the full trace
                            // Just return the recursion point
                            return null;
                        }
                    }
                }
            }
            // Check to see if we should be quitting early, before moving on to the next iteration.
            const matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {
                // We can't finish, so skip ahead to generating a result from what we have.
                quitEarlyArr[0] = true;
                // Use the furthest distance we got in the forward direction.
                midOriginalArr[0] = furthestOriginalIndex;
                midModifiedArr[0] = furthestModifiedIndex;
                if (matchLengthOfLongest > 0 && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {
                    // Enough of the history is in memory to walk it backwards
                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                }
                else {
                    // We didn't actually remember enough of the history.
                    //Since we are quiting the diff early, we need to shift back the originalStart and modified start
                    //back into the boundary limits since we decremented their value above beyond the boundary limit.
                    originalStart++;
                    modifiedStart++;
                    return [
                        new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
                    ];
                }
            }
            // Run the algorithm in the reverse direction
            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
            for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
                // STEP 1: We extend the furthest reaching point in the present diagonal
                // by looking at the diagonals above and below and picking the one whose point
                // is further away from the start point (originalEnd, modifiedEnd)
                if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {
                    originalIndex = reversePoints[diagonal + 1] - 1;
                }
                else {
                    originalIndex = reversePoints[diagonal - 1];
                }
                modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
                // Save the current originalIndex so we can test for false overlap
                const tempOriginalIndex = originalIndex;
                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal
                // as long as the elements are equal.
                while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
                    originalIndex--;
                    modifiedIndex--;
                }
                reversePoints[diagonal] = originalIndex;
                // STEP 4: If delta is even (overlap first happens on reverse when delta is even)
                // and diagonal is in the range of forward diagonals computed for numDifferences
                // then check for overlap.
                if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
                    if (originalIndex <= forwardPoints[diagonal]) {
                        midOriginalArr[0] = originalIndex;
                        midModifiedArr[0] = modifiedIndex;
                        if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {
                            // BINGO! We overlapped, and we have the full trace in memory!
                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                        }
                        else {
                            // Either false overlap, or we didn't have enough memory for the full trace
                            // Just return the recursion point
                            return null;
                        }
                    }
                }
            }
            // Save current vectors to history before the next iteration
            if (numDifferences <= 1447 /* MaxDifferencesHistory */) {
                // We are allocating space for one extra int, which we fill with
                // the index of the diagonal base index
                let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);
                temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
                MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
                this.m_forwardHistory.push(temp);
                temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);
                temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
                MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
                this.m_reverseHistory.push(temp);
            }
        }
        // If we got here, then we have the full trace in history. We just have to convert it to a change list
        // NOTE: This part is a bit messy
        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
    }
    /**
     * Shifts the given changes to provide a more intuitive diff.
     * While the first element in a diff matches the first element after the diff,
     * we shift the diff down.
     *
     * @param changes The list of changes to shift
     * @returns The shifted changes
     */
    PrettifyChanges(changes) {
        // Shift all the changes down first
        for (let i = 0; i < changes.length; i++) {
            const change = changes[i];
            const originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;
            const modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;
            const checkOriginal = change.originalLength > 0;
            const checkModified = change.modifiedLength > 0;
            while (change.originalStart + change.originalLength < originalStop &&
                change.modifiedStart + change.modifiedLength < modifiedStop &&
                (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) &&
                (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {
                change.originalStart++;
                change.modifiedStart++;
            }
            let mergedChangeArr = [null];
            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {
                changes[i] = mergedChangeArr[0];
                changes.splice(i + 1, 1);
                i--;
                continue;
            }
        }
        // Shift changes back up until we hit empty or whitespace-only lines
        for (let i = changes.length - 1; i >= 0; i--) {
            const change = changes[i];
            let originalStop = 0;
            let modifiedStop = 0;
            if (i > 0) {
                const prevChange = changes[i - 1];
                if (prevChange.originalLength > 0) {
                    originalStop = prevChange.originalStart + prevChange.originalLength;
                }
                if (prevChange.modifiedLength > 0) {
                    modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;
                }
            }
            const checkOriginal = change.originalLength > 0;
            const checkModified = change.modifiedLength > 0;
            let bestDelta = 0;
            let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);
            for (let delta = 1;; delta++) {
                const originalStart = change.originalStart - delta;
                const modifiedStart = change.modifiedStart - delta;
                if (originalStart < originalStop || modifiedStart < modifiedStop) {
                    break;
                }
                if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
                    break;
                }
                if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
                    break;
                }
                const score = this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);
                if (score > bestScore) {
                    bestScore = score;
                    bestDelta = delta;
                }
            }
            change.originalStart -= bestDelta;
            change.modifiedStart -= bestDelta;
        }
        return changes;
    }
    _OriginalIsBoundary(index) {
        if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {
            return true;
        }
        return (this._hasStrings && /^\s*$/.test(this._originalStringElements[index]));
    }
    _OriginalRegionIsBoundary(originalStart, originalLength) {
        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {
            return true;
        }
        if (originalLength > 0) {
            const originalEnd = originalStart + originalLength;
            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {
                return true;
            }
        }
        return false;
    }
    _ModifiedIsBoundary(index) {
        if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {
            return true;
        }
        return (this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index]));
    }
    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {
        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {
            return true;
        }
        if (modifiedLength > 0) {
            const modifiedEnd = modifiedStart + modifiedLength;
            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {
                return true;
            }
        }
        return false;
    }
    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {
        const originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);
        const modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);
        return (originalScore + modifiedScore);
    }
    /**
     * Concatenates the two input DiffChange lists and returns the resulting
     * list.
     * @param The left changes
     * @param The right changes
     * @returns The concatenated list
     */
    ConcatenateChanges(left, right) {
        let mergedChangeArr = [];
        if (left.length === 0 || right.length === 0) {
            return (right.length > 0) ? right : left;
        }
        else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
            // Since we break the problem down recursively, it is possible that we
            // might recurse in the middle of a change thereby splitting it into
            // two changes. Here in the combining stage, we detect and fuse those
            // changes back together
            const result = new Array(left.length + right.length - 1);
            MyArray.Copy(left, 0, result, 0, left.length - 1);
            result[left.length - 1] = mergedChangeArr[0];
            MyArray.Copy(right, 1, result, left.length, right.length - 1);
            return result;
        }
        else {
            const result = new Array(left.length + right.length);
            MyArray.Copy(left, 0, result, 0, left.length);
            MyArray.Copy(right, 0, result, left.length, right.length);
            return result;
        }
    }
    /**
     * Returns true if the two changes overlap and can be merged into a single
     * change
     * @param left The left change
     * @param right The right change
     * @param mergedChange The merged change if the two overlap, null otherwise
     * @returns True if the two changes overlap
     */
    ChangesOverlap(left, right, mergedChangeArr) {
        Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');
        Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');
        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
            const originalStart = left.originalStart;
            let originalLength = left.originalLength;
            const modifiedStart = left.modifiedStart;
            let modifiedLength = left.modifiedLength;
            if (left.originalStart + left.originalLength >= right.originalStart) {
                originalLength = right.originalStart + right.originalLength - left.originalStart;
            }
            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
                modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
            }
            mergedChangeArr[0] = new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
            return true;
        }
        else {
            mergedChangeArr[0] = null;
            return false;
        }
    }
    /**
     * Helper method used to clip a diagonal index to the range of valid
     * diagonals. This also decides whether or not the diagonal index,
     * if it exceeds the boundary, should be clipped to the boundary or clipped
     * one inside the boundary depending on the Even/Odd status of the boundary
     * and numDifferences.
     * @param diagonal The index of the diagonal to clip.
     * @param numDifferences The current number of differences being iterated upon.
     * @param diagonalBaseIndex The base reference diagonal.
     * @param numDiagonals The total number of diagonals.
     * @returns The clipped diagonal index.
     */
    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
        if (diagonal >= 0 && diagonal < numDiagonals) {
            // Nothing to clip, its in range
            return diagonal;
        }
        // diagonalsBelow: The number of diagonals below the reference diagonal
        // diagonalsAbove: The number of diagonals above the reference diagonal
        const diagonalsBelow = diagonalBaseIndex;
        const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
        const diffEven = (numDifferences % 2 === 0);
        if (diagonal < 0) {
            const lowerBoundEven = (diagonalsBelow % 2 === 0);
            return (diffEven === lowerBoundEven) ? 0 : 1;
        }
        else {
            const upperBoundEven = (diagonalsAbove % 2 === 0);
            return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;
        }
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js":
/*!**************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DiffChange": () => (/* binding */ DiffChange)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Represents information about a specific difference between two sequences.
 */
class DiffChange {
    /**
     * Constructs a new DiffChange with the given sequence information
     * and content.
     */
    constructor(originalStart, originalLength, modifiedStart, modifiedLength) {
        //Debug.Assert(originalLength > 0 || modifiedLength > 0, "originalLength and modifiedLength cannot both be <= 0");
        this.originalStart = originalStart;
        this.originalLength = originalLength;
        this.modifiedStart = modifiedStart;
        this.modifiedLength = modifiedLength;
    }
    /**
     * The end point (exclusive) of the change in the original sequence.
     */
    getOriginalEnd() {
        return this.originalStart + this.originalLength;
    }
    /**
     * The end point (exclusive) of the change in the modified sequence.
     */
    getModifiedEnd() {
        return this.modifiedStart + this.modifiedLength;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/errors.js":
/*!*****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/errors.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorHandler": () => (/* binding */ ErrorHandler),
/* harmony export */   "canceled": () => (/* binding */ canceled),
/* harmony export */   "errorHandler": () => (/* binding */ errorHandler),
/* harmony export */   "illegalArgument": () => (/* binding */ illegalArgument),
/* harmony export */   "illegalState": () => (/* binding */ illegalState),
/* harmony export */   "isPromiseCanceledError": () => (/* binding */ isPromiseCanceledError),
/* harmony export */   "onUnexpectedError": () => (/* binding */ onUnexpectedError),
/* harmony export */   "onUnexpectedExternalError": () => (/* binding */ onUnexpectedExternalError),
/* harmony export */   "transformErrorForSerialization": () => (/* binding */ transformErrorForSerialization)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Avoid circular dependency on EventEmitter by implementing a subset of the interface.
class ErrorHandler {
    constructor() {
        this.listeners = [];
        this.unexpectedErrorHandler = function (e) {
            setTimeout(() => {
                if (e.stack) {
                    throw new Error(e.message + '\n\n' + e.stack);
                }
                throw e;
            }, 0);
        };
    }
    emit(e) {
        this.listeners.forEach((listener) => {
            listener(e);
        });
    }
    onUnexpectedError(e) {
        this.unexpectedErrorHandler(e);
        this.emit(e);
    }
    // For external errors, we don't want the listeners to be called
    onUnexpectedExternalError(e) {
        this.unexpectedErrorHandler(e);
    }
}
const errorHandler = new ErrorHandler();
function onUnexpectedError(e) {
    // ignore errors from cancelled promises
    if (!isPromiseCanceledError(e)) {
        errorHandler.onUnexpectedError(e);
    }
    return undefined;
}
function onUnexpectedExternalError(e) {
    // ignore errors from cancelled promises
    if (!isPromiseCanceledError(e)) {
        errorHandler.onUnexpectedExternalError(e);
    }
    return undefined;
}
function transformErrorForSerialization(error) {
    if (error instanceof Error) {
        let { name, message } = error;
        const stack = error.stacktrace || error.stack;
        return {
            $isError: true,
            name,
            message,
            stack
        };
    }
    // return as is
    return error;
}
const canceledName = 'Canceled';
/**
 * Checks if the given error is a promise in canceled state
 */
function isPromiseCanceledError(error) {
    return error instanceof Error && error.name === canceledName && error.message === canceledName;
}
/**
 * Returns an error that signals cancellation.
 */
function canceled() {
    const error = new Error(canceledName);
    error.name = error.message;
    return error;
}
function illegalArgument(name) {
    if (name) {
        return new Error(`Illegal argument: ${name}`);
    }
    else {
        return new Error('Illegal argument');
    }
}
function illegalState(name) {
    if (name) {
        return new Error(`Illegal state: ${name}`);
    }
    else {
        return new Error('Illegal state');
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/event.js":
/*!****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/event.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Emitter": () => (/* binding */ Emitter),
/* harmony export */   "Event": () => (/* binding */ Event),
/* harmony export */   "EventBufferer": () => (/* binding */ EventBufferer),
/* harmony export */   "PauseableEmitter": () => (/* binding */ PauseableEmitter),
/* harmony export */   "Relay": () => (/* binding */ Relay)
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _linkedList_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linkedList.js */ "./node_modules/monaco-editor/esm/vs/base/common/linkedList.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



var Event;
(function (Event) {
    Event.None = () => _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.Disposable.None;
    /**
     * Given an event, returns another event which only fires once.
     */
    function once(event) {
        return (listener, thisArgs = null, disposables) => {
            // we need this, in case the event fires during the listener call
            let didFire = false;
            let result;
            result = event(e => {
                if (didFire) {
                    return;
                }
                else if (result) {
                    result.dispose();
                }
                else {
                    didFire = true;
                }
                return listener.call(thisArgs, e);
            }, null, disposables);
            if (didFire) {
                result.dispose();
            }
            return result;
        };
    }
    Event.once = once;
    /**
     * Given an event and a `map` function, returns another event which maps each element
     * through the mapping function.
     */
    function map(event, map) {
        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables));
    }
    Event.map = map;
    /**
     * Given an event and an `each` function, returns another identical event and calls
     * the `each` function per each element.
     */
    function forEach(event, each) {
        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables));
    }
    Event.forEach = forEach;
    function filter(event, filter) {
        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables));
    }
    Event.filter = filter;
    /**
     * Given an event, returns the same event but typed as `Event<void>`.
     */
    function signal(event) {
        return event;
    }
    Event.signal = signal;
    function any(...events) {
        return (listener, thisArgs = null, disposables) => (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.combinedDisposable)(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));
    }
    Event.any = any;
    /**
     * Given an event and a `merge` function, returns another event which maps each element
     * and the cumulative result through the `merge` function. Similar to `map`, but with memory.
     */
    function reduce(event, merge, initial) {
        let output = initial;
        return map(event, e => {
            output = merge(output, e);
            return output;
        });
    }
    Event.reduce = reduce;
    /**
     * Given a chain of event processing functions (filter, map, etc), each
     * function will be invoked per event & per listener. Snapshotting an event
     * chain allows each function to be invoked just once per event.
     */
    function snapshot(event) {
        let listener;
        const emitter = new Emitter({
            onFirstListenerAdd() {
                listener = event(emitter.fire, emitter);
            },
            onLastListenerRemove() {
                listener.dispose();
            }
        });
        return emitter.event;
    }
    Event.snapshot = snapshot;
    function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold) {
        let subscription;
        let output = undefined;
        let handle = undefined;
        let numDebouncedCalls = 0;
        const emitter = new Emitter({
            leakWarningThreshold,
            onFirstListenerAdd() {
                subscription = event(cur => {
                    numDebouncedCalls++;
                    output = merge(output, cur);
                    if (leading && !handle) {
                        emitter.fire(output);
                        output = undefined;
                    }
                    clearTimeout(handle);
                    handle = setTimeout(() => {
                        const _output = output;
                        output = undefined;
                        handle = undefined;
                        if (!leading || numDebouncedCalls > 1) {
                            emitter.fire(_output);
                        }
                        numDebouncedCalls = 0;
                    }, delay);
                });
            },
            onLastListenerRemove() {
                subscription.dispose();
            }
        });
        return emitter.event;
    }
    Event.debounce = debounce;
    /**
     * Given an event, it returns another event which fires only once and as soon as
     * the input event emits. The event data is the number of millis it took for the
     * event to fire.
     */
    function stopwatch(event) {
        const start = new Date().getTime();
        return map(once(event), _ => new Date().getTime() - start);
    }
    Event.stopwatch = stopwatch;
    /**
     * Given an event, it returns another event which fires only when the event
     * element changes.
     */
    function latch(event) {
        let firstCall = true;
        let cache;
        return filter(event, value => {
            const shouldEmit = firstCall || value !== cache;
            firstCall = false;
            cache = value;
            return shouldEmit;
        });
    }
    Event.latch = latch;
    /**
     * Buffers the provided event until a first listener comes
     * along, at which point fire all the events at once and
     * pipe the event from then on.
     *
     * ```typescript
     * const emitter = new Emitter<number>();
     * const event = emitter.event;
     * const bufferedEvent = buffer(event);
     *
     * emitter.fire(1);
     * emitter.fire(2);
     * emitter.fire(3);
     * // nothing...
     *
     * const listener = bufferedEvent(num => console.log(num));
     * // 1, 2, 3
     *
     * emitter.fire(4);
     * // 4
     * ```
     */
    function buffer(event, nextTick = false, _buffer = []) {
        let buffer = _buffer.slice();
        let listener = event(e => {
            if (buffer) {
                buffer.push(e);
            }
            else {
                emitter.fire(e);
            }
        });
        const flush = () => {
            if (buffer) {
                buffer.forEach(e => emitter.fire(e));
            }
            buffer = null;
        };
        const emitter = new Emitter({
            onFirstListenerAdd() {
                if (!listener) {
                    listener = event(e => emitter.fire(e));
                }
            },
            onFirstListenerDidAdd() {
                if (buffer) {
                    if (nextTick) {
                        setTimeout(flush);
                    }
                    else {
                        flush();
                    }
                }
            },
            onLastListenerRemove() {
                if (listener) {
                    listener.dispose();
                }
                listener = null;
            }
        });
        return emitter.event;
    }
    Event.buffer = buffer;
    class ChainableEvent {
        constructor(event) {
            this.event = event;
        }
        map(fn) {
            return new ChainableEvent(map(this.event, fn));
        }
        forEach(fn) {
            return new ChainableEvent(forEach(this.event, fn));
        }
        filter(fn) {
            return new ChainableEvent(filter(this.event, fn));
        }
        reduce(merge, initial) {
            return new ChainableEvent(reduce(this.event, merge, initial));
        }
        latch() {
            return new ChainableEvent(latch(this.event));
        }
        debounce(merge, delay = 100, leading = false, leakWarningThreshold) {
            return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));
        }
        on(listener, thisArgs, disposables) {
            return this.event(listener, thisArgs, disposables);
        }
        once(listener, thisArgs, disposables) {
            return once(this.event)(listener, thisArgs, disposables);
        }
    }
    function chain(event) {
        return new ChainableEvent(event);
    }
    Event.chain = chain;
    function fromNodeEventEmitter(emitter, eventName, map = id => id) {
        const fn = (...args) => result.fire(map(...args));
        const onFirstListenerAdd = () => emitter.on(eventName, fn);
        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);
        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });
        return result.event;
    }
    Event.fromNodeEventEmitter = fromNodeEventEmitter;
    function fromDOMEventEmitter(emitter, eventName, map = id => id) {
        const fn = (...args) => result.fire(map(...args));
        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);
        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);
        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });
        return result.event;
    }
    Event.fromDOMEventEmitter = fromDOMEventEmitter;
    function fromPromise(promise) {
        const emitter = new Emitter();
        let shouldEmit = false;
        promise
            .then(undefined, () => null)
            .then(() => {
            if (!shouldEmit) {
                setTimeout(() => emitter.fire(undefined), 0);
            }
            else {
                emitter.fire(undefined);
            }
        });
        shouldEmit = true;
        return emitter.event;
    }
    Event.fromPromise = fromPromise;
    function toPromise(event) {
        return new Promise(c => once(event)(c));
    }
    Event.toPromise = toPromise;
})(Event || (Event = {}));
let _globalLeakWarningThreshold = -1;
class LeakageMonitor {
    constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {
        this.customThreshold = customThreshold;
        this.name = name;
        this._warnCountdown = 0;
    }
    dispose() {
        if (this._stacks) {
            this._stacks.clear();
        }
    }
    check(listenerCount) {
        let threshold = _globalLeakWarningThreshold;
        if (typeof this.customThreshold === 'number') {
            threshold = this.customThreshold;
        }
        if (threshold <= 0 || listenerCount < threshold) {
            return undefined;
        }
        if (!this._stacks) {
            this._stacks = new Map();
        }
        const stack = new Error().stack.split('\n').slice(3).join('\n');
        const count = (this._stacks.get(stack) || 0);
        this._stacks.set(stack, count + 1);
        this._warnCountdown -= 1;
        if (this._warnCountdown <= 0) {
            // only warn on first exceed and then every time the limit
            // is exceeded by 50% again
            this._warnCountdown = threshold * 0.5;
            // find most frequent listener and print warning
            let topStack;
            let topCount = 0;
            for (const [stack, count] of this._stacks) {
                if (!topStack || topCount < count) {
                    topStack = stack;
                    topCount = count;
                }
            }
            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);
            console.warn(topStack);
        }
        return () => {
            const count = (this._stacks.get(stack) || 0);
            this._stacks.set(stack, count - 1);
        };
    }
}
/**
 * The Emitter can be used to expose an Event to the public
 * to fire it from the insides.
 * Sample:
    class Document {

        private readonly _onDidChange = new Emitter<(value:string)=>any>();

        public onDidChange = this._onDidChange.event;

        // getter-style
        // get onDidChange(): Event<(value:string)=>any> {
        // 	return this._onDidChange.event;
        // }

        private _doIt() {
            //...
            this._onDidChange.fire(value);
        }
    }
 */
class Emitter {
    constructor(options) {
        this._disposed = false;
        this._options = options;
        this._leakageMon = _globalLeakWarningThreshold > 0
            ? new LeakageMonitor(this._options && this._options.leakWarningThreshold)
            : undefined;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._listeners) {
                    this._listeners = new _linkedList_js__WEBPACK_IMPORTED_MODULE_2__.LinkedList();
                }
                const firstListener = this._listeners.isEmpty();
                if (firstListener && this._options && this._options.onFirstListenerAdd) {
                    this._options.onFirstListenerAdd(this);
                }
                const remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);
                if (firstListener && this._options && this._options.onFirstListenerDidAdd) {
                    this._options.onFirstListenerDidAdd(this);
                }
                if (this._options && this._options.onListenerDidAdd) {
                    this._options.onListenerDidAdd(this, listener, thisArgs);
                }
                // check and record this emitter for potential leakage
                let removeMonitor;
                if (this._leakageMon) {
                    removeMonitor = this._leakageMon.check(this._listeners.size);
                }
                let result;
                result = {
                    dispose: () => {
                        if (removeMonitor) {
                            removeMonitor();
                        }
                        result.dispose = Emitter._noop;
                        if (!this._disposed) {
                            remove();
                            if (this._options && this._options.onLastListenerRemove) {
                                const hasListeners = (this._listeners && !this._listeners.isEmpty());
                                if (!hasListeners) {
                                    this._options.onLastListenerRemove(this);
                                }
                            }
                        }
                    }
                };
                if (disposables instanceof _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.DisposableStore) {
                    disposables.add(result);
                }
                else if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._listeners) {
            // put all [listener,event]-pairs into delivery queue
            // then emit all event. an inner/nested event might be
            // the driver of this
            if (!this._deliveryQueue) {
                this._deliveryQueue = new _linkedList_js__WEBPACK_IMPORTED_MODULE_2__.LinkedList();
            }
            for (let listener of this._listeners) {
                this._deliveryQueue.push([listener, event]);
            }
            while (this._deliveryQueue.size > 0) {
                const [listener, event] = this._deliveryQueue.shift();
                try {
                    if (typeof listener === 'function') {
                        listener.call(undefined, event);
                    }
                    else {
                        listener[0].call(listener[1], event);
                    }
                }
                catch (e) {
                    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError)(e);
                }
            }
        }
    }
    dispose() {
        if (this._listeners) {
            this._listeners.clear();
        }
        if (this._deliveryQueue) {
            this._deliveryQueue.clear();
        }
        if (this._leakageMon) {
            this._leakageMon.dispose();
        }
        this._disposed = true;
    }
}
Emitter._noop = function () { };
class PauseableEmitter extends Emitter {
    constructor(options) {
        super(options);
        this._isPaused = 0;
        this._eventQueue = new _linkedList_js__WEBPACK_IMPORTED_MODULE_2__.LinkedList();
        this._mergeFn = options && options.merge;
    }
    pause() {
        this._isPaused++;
    }
    resume() {
        if (this._isPaused !== 0 && --this._isPaused === 0) {
            if (this._mergeFn) {
                // use the merge function to create a single composite
                // event. make a copy in case firing pauses this emitter
                const events = this._eventQueue.toArray();
                this._eventQueue.clear();
                super.fire(this._mergeFn(events));
            }
            else {
                // no merging, fire each event individually and test
                // that this emitter isn't paused halfway through
                while (!this._isPaused && this._eventQueue.size !== 0) {
                    super.fire(this._eventQueue.shift());
                }
            }
        }
    }
    fire(event) {
        if (this._listeners) {
            if (this._isPaused !== 0) {
                this._eventQueue.push(event);
            }
            else {
                super.fire(event);
            }
        }
    }
}
/**
 * The EventBufferer is useful in situations in which you want
 * to delay firing your events during some code.
 * You can wrap that code and be sure that the event will not
 * be fired during that wrap.
 *
 * ```
 * const emitter: Emitter;
 * const delayer = new EventDelayer();
 * const delayedEvent = delayer.wrapEvent(emitter.event);
 *
 * delayedEvent(console.log);
 *
 * delayer.bufferEvents(() => {
 *   emitter.fire(); // event will not be fired yet
 * });
 *
 * // event will only be fired at this point
 * ```
 */
class EventBufferer {
    constructor() {
        this.buffers = [];
    }
    wrapEvent(event) {
        return (listener, thisArgs, disposables) => {
            return event(i => {
                const buffer = this.buffers[this.buffers.length - 1];
                if (buffer) {
                    buffer.push(() => listener.call(thisArgs, i));
                }
                else {
                    listener.call(thisArgs, i);
                }
            }, undefined, disposables);
        };
    }
    bufferEvents(fn) {
        const buffer = [];
        this.buffers.push(buffer);
        const r = fn();
        this.buffers.pop();
        buffer.forEach(flush => flush());
        return r;
    }
}
/**
 * A Relay is an event forwarder which functions as a replugabble event pipe.
 * Once created, you can connect an input event to it and it will simply forward
 * events from that input event through its own `event` property. The `input`
 * can be changed at any point in time.
 */
class Relay {
    constructor() {
        this.listening = false;
        this.inputEvent = Event.None;
        this.inputEventListener = _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.Disposable.None;
        this.emitter = new Emitter({
            onFirstListenerDidAdd: () => {
                this.listening = true;
                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);
            },
            onLastListenerRemove: () => {
                this.listening = false;
                this.inputEventListener.dispose();
            }
        });
        this.event = this.emitter.event;
    }
    set input(event) {
        this.inputEvent = event;
        if (this.listening) {
            this.inputEventListener.dispose();
            this.inputEventListener = event(this.emitter.fire, this.emitter);
        }
    }
    dispose() {
        this.inputEventListener.dispose();
        this.emitter.dispose();
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/hash.js":
/*!***************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/hash.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringSHA1": () => (/* binding */ StringSHA1),
/* harmony export */   "doHash": () => (/* binding */ doHash),
/* harmony export */   "hash": () => (/* binding */ hash),
/* harmony export */   "stringHash": () => (/* binding */ stringHash)
/* harmony export */ });
/* harmony import */ var _strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Return a hash value for an object.
 */
function hash(obj) {
    return doHash(obj, 0);
}
function doHash(obj, hashVal) {
    switch (typeof obj) {
        case 'object':
            if (obj === null) {
                return numberHash(349, hashVal);
            }
            else if (Array.isArray(obj)) {
                return arrayHash(obj, hashVal);
            }
            return objectHash(obj, hashVal);
        case 'string':
            return stringHash(obj, hashVal);
        case 'boolean':
            return booleanHash(obj, hashVal);
        case 'number':
            return numberHash(obj, hashVal);
        case 'undefined':
            return numberHash(937, hashVal);
        default:
            return numberHash(617, hashVal);
    }
}
function numberHash(val, initialHashVal) {
    return (((initialHashVal << 5) - initialHashVal) + val) | 0; // hashVal * 31 + ch, keep as int32
}
function booleanHash(b, initialHashVal) {
    return numberHash(b ? 433 : 863, initialHashVal);
}
function stringHash(s, hashVal) {
    hashVal = numberHash(149417, hashVal);
    for (let i = 0, length = s.length; i < length; i++) {
        hashVal = numberHash(s.charCodeAt(i), hashVal);
    }
    return hashVal;
}
function arrayHash(arr, initialHashVal) {
    initialHashVal = numberHash(104579, initialHashVal);
    return arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);
}
function objectHash(obj, initialHashVal) {
    initialHashVal = numberHash(181387, initialHashVal);
    return Object.keys(obj).sort().reduce((hashVal, key) => {
        hashVal = stringHash(key, hashVal);
        return doHash(obj[key], hashVal);
    }, initialHashVal);
}
function leftRotate(value, bits, totalBits = 32) {
    // delta + bits = totalBits
    const delta = totalBits - bits;
    // All ones, expect `delta` zeros aligned to the right
    const mask = ~((1 << delta) - 1);
    // Join (value left-shifted `bits` bits) with (masked value right-shifted `delta` bits)
    return ((value << bits) | ((mask & value) >>> delta)) >>> 0;
}
function fill(dest, index = 0, count = dest.byteLength, value = 0) {
    for (let i = 0; i < count; i++) {
        dest[index + i] = value;
    }
}
function leftPad(value, length, char = '0') {
    while (value.length < length) {
        value = char + value;
    }
    return value;
}
function toHexString(value, bitsize = 32) {
    return leftPad((value >>> 0).toString(16), bitsize / 4);
}
/**
 * A SHA1 implementation that works with strings and does not allocate.
 */
class StringSHA1 {
    constructor() {
        this._h0 = 0x67452301;
        this._h1 = 0xEFCDAB89;
        this._h2 = 0x98BADCFE;
        this._h3 = 0x10325476;
        this._h4 = 0xC3D2E1F0;
        this._buff = new Uint8Array(64 /* BLOCK_SIZE */ + 3 /* to fit any utf-8 */);
        this._buffDV = new DataView(this._buff.buffer);
        this._buffLen = 0;
        this._totalLen = 0;
        this._leftoverHighSurrogate = 0;
        this._finished = false;
    }
    update(str) {
        const strLen = str.length;
        if (strLen === 0) {
            return;
        }
        const buff = this._buff;
        let buffLen = this._buffLen;
        let leftoverHighSurrogate = this._leftoverHighSurrogate;
        let charCode;
        let offset;
        if (leftoverHighSurrogate !== 0) {
            charCode = leftoverHighSurrogate;
            offset = -1;
            leftoverHighSurrogate = 0;
        }
        else {
            charCode = str.charCodeAt(0);
            offset = 0;
        }
        while (true) {
            let codePoint = charCode;
            if (_strings_js__WEBPACK_IMPORTED_MODULE_0__.isHighSurrogate(charCode)) {
                if (offset + 1 < strLen) {
                    const nextCharCode = str.charCodeAt(offset + 1);
                    if (_strings_js__WEBPACK_IMPORTED_MODULE_0__.isLowSurrogate(nextCharCode)) {
                        offset++;
                        codePoint = _strings_js__WEBPACK_IMPORTED_MODULE_0__.computeCodePoint(charCode, nextCharCode);
                    }
                    else {
                        // illegal => unicode replacement character
                        codePoint = 65533 /* UNICODE_REPLACEMENT */;
                    }
                }
                else {
                    // last character is a surrogate pair
                    leftoverHighSurrogate = charCode;
                    break;
                }
            }
            else if (_strings_js__WEBPACK_IMPORTED_MODULE_0__.isLowSurrogate(charCode)) {
                // illegal => unicode replacement character
                codePoint = 65533 /* UNICODE_REPLACEMENT */;
            }
            buffLen = this._push(buff, buffLen, codePoint);
            offset++;
            if (offset < strLen) {
                charCode = str.charCodeAt(offset);
            }
            else {
                break;
            }
        }
        this._buffLen = buffLen;
        this._leftoverHighSurrogate = leftoverHighSurrogate;
    }
    _push(buff, buffLen, codePoint) {
        if (codePoint < 0x0080) {
            buff[buffLen++] = codePoint;
        }
        else if (codePoint < 0x0800) {
            buff[buffLen++] = 0b11000000 | ((codePoint & 0b00000000000000000000011111000000) >>> 6);
            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);
        }
        else if (codePoint < 0x10000) {
            buff[buffLen++] = 0b11100000 | ((codePoint & 0b00000000000000001111000000000000) >>> 12);
            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);
            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);
        }
        else {
            buff[buffLen++] = 0b11110000 | ((codePoint & 0b00000000000111000000000000000000) >>> 18);
            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000111111000000000000) >>> 12);
            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);
            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);
        }
        if (buffLen >= 64 /* BLOCK_SIZE */) {
            this._step();
            buffLen -= 64 /* BLOCK_SIZE */;
            this._totalLen += 64 /* BLOCK_SIZE */;
            // take last 3 in case of UTF8 overflow
            buff[0] = buff[64 /* BLOCK_SIZE */ + 0];
            buff[1] = buff[64 /* BLOCK_SIZE */ + 1];
            buff[2] = buff[64 /* BLOCK_SIZE */ + 2];
        }
        return buffLen;
    }
    digest() {
        if (!this._finished) {
            this._finished = true;
            if (this._leftoverHighSurrogate) {
                // illegal => unicode replacement character
                this._leftoverHighSurrogate = 0;
                this._buffLen = this._push(this._buff, this._buffLen, 65533 /* UNICODE_REPLACEMENT */);
            }
            this._totalLen += this._buffLen;
            this._wrapUp();
        }
        return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
    }
    _wrapUp() {
        this._buff[this._buffLen++] = 0x80;
        fill(this._buff, this._buffLen);
        if (this._buffLen > 56) {
            this._step();
            fill(this._buff);
        }
        // this will fit because the mantissa can cover up to 52 bits
        const ml = 8 * this._totalLen;
        this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
        this._buffDV.setUint32(60, ml % 4294967296, false);
        this._step();
    }
    _step() {
        const bigBlock32 = StringSHA1._bigBlock32;
        const data = this._buffDV;
        for (let j = 0; j < 64 /* 16*4 */; j += 4) {
            bigBlock32.setUint32(j, data.getUint32(j, false), false);
        }
        for (let j = 64; j < 320 /* 80*4 */; j += 4) {
            bigBlock32.setUint32(j, leftRotate((bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false)), 1), false);
        }
        let a = this._h0;
        let b = this._h1;
        let c = this._h2;
        let d = this._h3;
        let e = this._h4;
        let f, k;
        let temp;
        for (let j = 0; j < 80; j++) {
            if (j < 20) {
                f = (b & c) | ((~b) & d);
                k = 0x5A827999;
            }
            else if (j < 40) {
                f = b ^ c ^ d;
                k = 0x6ED9EBA1;
            }
            else if (j < 60) {
                f = (b & c) | (b & d) | (c & d);
                k = 0x8F1BBCDC;
            }
            else {
                f = b ^ c ^ d;
                k = 0xCA62C1D6;
            }
            temp = (leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false)) & 0xffffffff;
            e = d;
            d = c;
            c = leftRotate(b, 30);
            b = a;
            a = temp;
        }
        this._h0 = (this._h0 + a) & 0xffffffff;
        this._h1 = (this._h1 + b) & 0xffffffff;
        this._h2 = (this._h2 + c) & 0xffffffff;
        this._h3 = (this._h3 + d) & 0xffffffff;
        this._h4 = (this._h4 + e) & 0xffffffff;
    }
}
StringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320)); // 80 * 4 = 320


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/iterator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/iterator.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Iterable": () => (/* binding */ Iterable)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var Iterable;
(function (Iterable) {
    function is(thing) {
        return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';
    }
    Iterable.is = is;
    const _empty = Object.freeze([]);
    function empty() {
        return _empty;
    }
    Iterable.empty = empty;
    function* single(element) {
        yield element;
    }
    Iterable.single = single;
    function from(iterable) {
        return iterable || _empty;
    }
    Iterable.from = from;
    function first(iterable) {
        return iterable[Symbol.iterator]().next().value;
    }
    Iterable.first = first;
    function some(iterable, predicate) {
        for (const element of iterable) {
            if (predicate(element)) {
                return true;
            }
        }
        return false;
    }
    Iterable.some = some;
    function* filter(iterable, predicate) {
        for (const element of iterable) {
            if (predicate(element)) {
                yield element;
            }
        }
    }
    Iterable.filter = filter;
    function* map(iterable, fn) {
        for (const element of iterable) {
            yield fn(element);
        }
    }
    Iterable.map = map;
    function* concat(...iterables) {
        for (const iterable of iterables) {
            for (const element of iterable) {
                yield element;
            }
        }
    }
    Iterable.concat = concat;
    /**
     * Consumes `atMost` elements from iterable and returns the consumed elements,
     * and an iterable for the rest of the elements.
     */
    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
        const consumed = [];
        if (atMost === 0) {
            return [consumed, iterable];
        }
        const iterator = iterable[Symbol.iterator]();
        for (let i = 0; i < atMost; i++) {
            const next = iterator.next();
            if (next.done) {
                return [consumed, Iterable.empty()];
            }
            consumed.push(next.value);
        }
        return [consumed, { [Symbol.iterator]() { return iterator; } }];
    }
    Iterable.consume = consume;
})(Iterable || (Iterable = {}));


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js":
/*!*******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChordKeybinding": () => (/* binding */ ChordKeybinding),
/* harmony export */   "KeyChord": () => (/* binding */ KeyChord),
/* harmony export */   "KeyCodeUtils": () => (/* binding */ KeyCodeUtils),
/* harmony export */   "ResolvedKeybinding": () => (/* binding */ ResolvedKeybinding),
/* harmony export */   "ResolvedKeybindingPart": () => (/* binding */ ResolvedKeybindingPart),
/* harmony export */   "SimpleKeybinding": () => (/* binding */ SimpleKeybinding),
/* harmony export */   "createKeybinding": () => (/* binding */ createKeybinding),
/* harmony export */   "createSimpleKeybinding": () => (/* binding */ createSimpleKeybinding)
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

class KeyCodeStrMap {
    constructor() {
        this._keyCodeToStr = [];
        this._strToKeyCode = Object.create(null);
    }
    define(keyCode, str) {
        this._keyCodeToStr[keyCode] = str;
        this._strToKeyCode[str.toLowerCase()] = keyCode;
    }
    keyCodeToStr(keyCode) {
        return this._keyCodeToStr[keyCode];
    }
    strToKeyCode(str) {
        return this._strToKeyCode[str.toLowerCase()] || 0 /* Unknown */;
    }
}
const uiMap = new KeyCodeStrMap();
const userSettingsUSMap = new KeyCodeStrMap();
const userSettingsGeneralMap = new KeyCodeStrMap();
(function () {
    function define(keyCode, uiLabel, usUserSettingsLabel = uiLabel, generalUserSettingsLabel = usUserSettingsLabel) {
        uiMap.define(keyCode, uiLabel);
        userSettingsUSMap.define(keyCode, usUserSettingsLabel);
        userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel);
    }
    define(0 /* Unknown */, 'unknown');
    define(1 /* Backspace */, 'Backspace');
    define(2 /* Tab */, 'Tab');
    define(3 /* Enter */, 'Enter');
    define(4 /* Shift */, 'Shift');
    define(5 /* Ctrl */, 'Ctrl');
    define(6 /* Alt */, 'Alt');
    define(7 /* PauseBreak */, 'PauseBreak');
    define(8 /* CapsLock */, 'CapsLock');
    define(9 /* Escape */, 'Escape');
    define(10 /* Space */, 'Space');
    define(11 /* PageUp */, 'PageUp');
    define(12 /* PageDown */, 'PageDown');
    define(13 /* End */, 'End');
    define(14 /* Home */, 'Home');
    define(15 /* LeftArrow */, 'LeftArrow', 'Left');
    define(16 /* UpArrow */, 'UpArrow', 'Up');
    define(17 /* RightArrow */, 'RightArrow', 'Right');
    define(18 /* DownArrow */, 'DownArrow', 'Down');
    define(19 /* Insert */, 'Insert');
    define(20 /* Delete */, 'Delete');
    define(21 /* KEY_0 */, '0');
    define(22 /* KEY_1 */, '1');
    define(23 /* KEY_2 */, '2');
    define(24 /* KEY_3 */, '3');
    define(25 /* KEY_4 */, '4');
    define(26 /* KEY_5 */, '5');
    define(27 /* KEY_6 */, '6');
    define(28 /* KEY_7 */, '7');
    define(29 /* KEY_8 */, '8');
    define(30 /* KEY_9 */, '9');
    define(31 /* KEY_A */, 'A');
    define(32 /* KEY_B */, 'B');
    define(33 /* KEY_C */, 'C');
    define(34 /* KEY_D */, 'D');
    define(35 /* KEY_E */, 'E');
    define(36 /* KEY_F */, 'F');
    define(37 /* KEY_G */, 'G');
    define(38 /* KEY_H */, 'H');
    define(39 /* KEY_I */, 'I');
    define(40 /* KEY_J */, 'J');
    define(41 /* KEY_K */, 'K');
    define(42 /* KEY_L */, 'L');
    define(43 /* KEY_M */, 'M');
    define(44 /* KEY_N */, 'N');
    define(45 /* KEY_O */, 'O');
    define(46 /* KEY_P */, 'P');
    define(47 /* KEY_Q */, 'Q');
    define(48 /* KEY_R */, 'R');
    define(49 /* KEY_S */, 'S');
    define(50 /* KEY_T */, 'T');
    define(51 /* KEY_U */, 'U');
    define(52 /* KEY_V */, 'V');
    define(53 /* KEY_W */, 'W');
    define(54 /* KEY_X */, 'X');
    define(55 /* KEY_Y */, 'Y');
    define(56 /* KEY_Z */, 'Z');
    define(57 /* Meta */, 'Meta');
    define(58 /* ContextMenu */, 'ContextMenu');
    define(59 /* F1 */, 'F1');
    define(60 /* F2 */, 'F2');
    define(61 /* F3 */, 'F3');
    define(62 /* F4 */, 'F4');
    define(63 /* F5 */, 'F5');
    define(64 /* F6 */, 'F6');
    define(65 /* F7 */, 'F7');
    define(66 /* F8 */, 'F8');
    define(67 /* F9 */, 'F9');
    define(68 /* F10 */, 'F10');
    define(69 /* F11 */, 'F11');
    define(70 /* F12 */, 'F12');
    define(71 /* F13 */, 'F13');
    define(72 /* F14 */, 'F14');
    define(73 /* F15 */, 'F15');
    define(74 /* F16 */, 'F16');
    define(75 /* F17 */, 'F17');
    define(76 /* F18 */, 'F18');
    define(77 /* F19 */, 'F19');
    define(78 /* NumLock */, 'NumLock');
    define(79 /* ScrollLock */, 'ScrollLock');
    define(80 /* US_SEMICOLON */, ';', ';', 'OEM_1');
    define(81 /* US_EQUAL */, '=', '=', 'OEM_PLUS');
    define(82 /* US_COMMA */, ',', ',', 'OEM_COMMA');
    define(83 /* US_MINUS */, '-', '-', 'OEM_MINUS');
    define(84 /* US_DOT */, '.', '.', 'OEM_PERIOD');
    define(85 /* US_SLASH */, '/', '/', 'OEM_2');
    define(86 /* US_BACKTICK */, '`', '`', 'OEM_3');
    define(110 /* ABNT_C1 */, 'ABNT_C1');
    define(111 /* ABNT_C2 */, 'ABNT_C2');
    define(87 /* US_OPEN_SQUARE_BRACKET */, '[', '[', 'OEM_4');
    define(88 /* US_BACKSLASH */, '\\', '\\', 'OEM_5');
    define(89 /* US_CLOSE_SQUARE_BRACKET */, ']', ']', 'OEM_6');
    define(90 /* US_QUOTE */, '\'', '\'', 'OEM_7');
    define(91 /* OEM_8 */, 'OEM_8');
    define(92 /* OEM_102 */, 'OEM_102');
    define(93 /* NUMPAD_0 */, 'NumPad0');
    define(94 /* NUMPAD_1 */, 'NumPad1');
    define(95 /* NUMPAD_2 */, 'NumPad2');
    define(96 /* NUMPAD_3 */, 'NumPad3');
    define(97 /* NUMPAD_4 */, 'NumPad4');
    define(98 /* NUMPAD_5 */, 'NumPad5');
    define(99 /* NUMPAD_6 */, 'NumPad6');
    define(100 /* NUMPAD_7 */, 'NumPad7');
    define(101 /* NUMPAD_8 */, 'NumPad8');
    define(102 /* NUMPAD_9 */, 'NumPad9');
    define(103 /* NUMPAD_MULTIPLY */, 'NumPad_Multiply');
    define(104 /* NUMPAD_ADD */, 'NumPad_Add');
    define(105 /* NUMPAD_SEPARATOR */, 'NumPad_Separator');
    define(106 /* NUMPAD_SUBTRACT */, 'NumPad_Subtract');
    define(107 /* NUMPAD_DECIMAL */, 'NumPad_Decimal');
    define(108 /* NUMPAD_DIVIDE */, 'NumPad_Divide');
})();
var KeyCodeUtils;
(function (KeyCodeUtils) {
    function toString(keyCode) {
        return uiMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils.toString = toString;
    function fromString(key) {
        return uiMap.strToKeyCode(key);
    }
    KeyCodeUtils.fromString = fromString;
    function toUserSettingsUS(keyCode) {
        return userSettingsUSMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils.toUserSettingsUS = toUserSettingsUS;
    function toUserSettingsGeneral(keyCode) {
        return userSettingsGeneralMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils.toUserSettingsGeneral = toUserSettingsGeneral;
    function fromUserSettings(key) {
        return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);
    }
    KeyCodeUtils.fromUserSettings = fromUserSettings;
})(KeyCodeUtils || (KeyCodeUtils = {}));
function KeyChord(firstPart, secondPart) {
    const chordPart = ((secondPart & 0x0000FFFF) << 16) >>> 0;
    return (firstPart | chordPart) >>> 0;
}
function createKeybinding(keybinding, OS) {
    if (keybinding === 0) {
        return null;
    }
    const firstPart = (keybinding & 0x0000FFFF) >>> 0;
    const chordPart = (keybinding & 0xFFFF0000) >>> 16;
    if (chordPart !== 0) {
        return new ChordKeybinding([
            createSimpleKeybinding(firstPart, OS),
            createSimpleKeybinding(chordPart, OS)
        ]);
    }
    return new ChordKeybinding([createSimpleKeybinding(firstPart, OS)]);
}
function createSimpleKeybinding(keybinding, OS) {
    const ctrlCmd = (keybinding & 2048 /* CtrlCmd */ ? true : false);
    const winCtrl = (keybinding & 256 /* WinCtrl */ ? true : false);
    const ctrlKey = (OS === 2 /* Macintosh */ ? winCtrl : ctrlCmd);
    const shiftKey = (keybinding & 1024 /* Shift */ ? true : false);
    const altKey = (keybinding & 512 /* Alt */ ? true : false);
    const metaKey = (OS === 2 /* Macintosh */ ? ctrlCmd : winCtrl);
    const keyCode = (keybinding & 255 /* KeyCode */);
    return new SimpleKeybinding(ctrlKey, shiftKey, altKey, metaKey, keyCode);
}
class SimpleKeybinding {
    constructor(ctrlKey, shiftKey, altKey, metaKey, keyCode) {
        this.ctrlKey = ctrlKey;
        this.shiftKey = shiftKey;
        this.altKey = altKey;
        this.metaKey = metaKey;
        this.keyCode = keyCode;
    }
    equals(other) {
        return (this.ctrlKey === other.ctrlKey
            && this.shiftKey === other.shiftKey
            && this.altKey === other.altKey
            && this.metaKey === other.metaKey
            && this.keyCode === other.keyCode);
    }
    isModifierKey() {
        return (this.keyCode === 0 /* Unknown */
            || this.keyCode === 5 /* Ctrl */
            || this.keyCode === 57 /* Meta */
            || this.keyCode === 6 /* Alt */
            || this.keyCode === 4 /* Shift */);
    }
    toChord() {
        return new ChordKeybinding([this]);
    }
    /**
     * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
     */
    isDuplicateModifierCase() {
        return ((this.ctrlKey && this.keyCode === 5 /* Ctrl */)
            || (this.shiftKey && this.keyCode === 4 /* Shift */)
            || (this.altKey && this.keyCode === 6 /* Alt */)
            || (this.metaKey && this.keyCode === 57 /* Meta */));
    }
}
class ChordKeybinding {
    constructor(parts) {
        if (parts.length === 0) {
            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.illegalArgument)(`parts`);
        }
        this.parts = parts;
    }
}
class ResolvedKeybindingPart {
    constructor(ctrlKey, shiftKey, altKey, metaKey, kbLabel, kbAriaLabel) {
        this.ctrlKey = ctrlKey;
        this.shiftKey = shiftKey;
        this.altKey = altKey;
        this.metaKey = metaKey;
        this.keyLabel = kbLabel;
        this.keyAriaLabel = kbAriaLabel;
    }
}
/**
 * A resolved keybinding. Can be a simple keybinding or a chord keybinding.
 */
class ResolvedKeybinding {
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js":
/*!********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Disposable": () => (/* binding */ Disposable),
/* harmony export */   "DisposableStore": () => (/* binding */ DisposableStore),
/* harmony export */   "ImmortalReference": () => (/* binding */ ImmortalReference),
/* harmony export */   "MultiDisposeError": () => (/* binding */ MultiDisposeError),
/* harmony export */   "MutableDisposable": () => (/* binding */ MutableDisposable),
/* harmony export */   "combinedDisposable": () => (/* binding */ combinedDisposable),
/* harmony export */   "dispose": () => (/* binding */ dispose),
/* harmony export */   "isDisposable": () => (/* binding */ isDisposable),
/* harmony export */   "toDisposable": () => (/* binding */ toDisposable)
/* harmony export */ });
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./iterator.js */ "./node_modules/monaco-editor/esm/vs/base/common/iterator.js");

/**
 * Enables logging of potentially leaked disposables.
 *
 * A disposable is considered leaked if it is not disposed or not registered as the child of
 * another disposable. This tracking is very simple an only works for classes that either
 * extend Disposable or use a DisposableStore. This means there are a lot of false positives.
 */
const TRACK_DISPOSABLES = false;
const __is_disposable_tracked__ = '__is_disposable_tracked__';
function markTracked(x) {
    if (!TRACK_DISPOSABLES) {
        return;
    }
    if (x && x !== Disposable.None) {
        try {
            x[__is_disposable_tracked__] = true;
        }
        catch (_a) {
            // noop
        }
    }
}
function trackDisposable(x) {
    if (!TRACK_DISPOSABLES) {
        return x;
    }
    const stack = new Error('Potentially leaked disposable').stack;
    setTimeout(() => {
        if (!x[__is_disposable_tracked__]) {
            console.log(stack);
        }
    }, 3000);
    return x;
}
class MultiDisposeError extends Error {
    constructor(errors) {
        super(`Encounter errors while disposing of store. Errors: [${errors.join(', ')}]`);
        this.errors = errors;
    }
}
function isDisposable(thing) {
    return typeof thing.dispose === 'function' && thing.dispose.length === 0;
}
function dispose(arg) {
    if (_iterator_js__WEBPACK_IMPORTED_MODULE_0__.Iterable.is(arg)) {
        let errors = [];
        for (const d of arg) {
            if (d) {
                markTracked(d);
                try {
                    d.dispose();
                }
                catch (e) {
                    errors.push(e);
                }
            }
        }
        if (errors.length === 1) {
            throw errors[0];
        }
        else if (errors.length > 1) {
            throw new MultiDisposeError(errors);
        }
        return Array.isArray(arg) ? [] : arg;
    }
    else if (arg) {
        markTracked(arg);
        arg.dispose();
        return arg;
    }
}
function combinedDisposable(...disposables) {
    disposables.forEach(markTracked);
    return trackDisposable({ dispose: () => dispose(disposables) });
}
function toDisposable(fn) {
    const self = trackDisposable({
        dispose: () => {
            markTracked(self);
            fn();
        }
    });
    return self;
}
class DisposableStore {
    constructor() {
        this._toDispose = new Set();
        this._isDisposed = false;
    }
    /**
     * Dispose of all registered disposables and mark this object as disposed.
     *
     * Any future disposables added to this object will be disposed of on `add`.
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        markTracked(this);
        this._isDisposed = true;
        this.clear();
    }
    /**
     * Dispose of all registered disposables but do not mark this object as disposed.
     */
    clear() {
        try {
            dispose(this._toDispose.values());
        }
        finally {
            this._toDispose.clear();
        }
    }
    add(t) {
        if (!t) {
            return t;
        }
        if (t === this) {
            throw new Error('Cannot register a disposable on itself!');
        }
        markTracked(t);
        if (this._isDisposed) {
            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {
                console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);
            }
        }
        else {
            this._toDispose.add(t);
        }
        return t;
    }
}
DisposableStore.DISABLE_DISPOSED_WARNING = false;
class Disposable {
    constructor() {
        this._store = new DisposableStore();
        trackDisposable(this);
    }
    dispose() {
        markTracked(this);
        this._store.dispose();
    }
    _register(t) {
        if (t === this) {
            throw new Error('Cannot register a disposable on itself!');
        }
        return this._store.add(t);
    }
}
Disposable.None = Object.freeze({ dispose() { } });
/**
 * Manages the lifecycle of a disposable value that may be changed.
 *
 * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can
 * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.
 */
class MutableDisposable {
    constructor() {
        this._isDisposed = false;
        trackDisposable(this);
    }
    get value() {
        return this._isDisposed ? undefined : this._value;
    }
    set value(value) {
        if (this._isDisposed || value === this._value) {
            return;
        }
        if (this._value) {
            this._value.dispose();
        }
        if (value) {
            markTracked(value);
        }
        this._value = value;
    }
    clear() {
        this.value = undefined;
    }
    dispose() {
        this._isDisposed = true;
        markTracked(this);
        if (this._value) {
            this._value.dispose();
        }
        this._value = undefined;
    }
}
class ImmortalReference {
    constructor(object) {
        this.object = object;
    }
    dispose() { }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/linkedList.js":
/*!*********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/linkedList.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkedList": () => (/* binding */ LinkedList)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class Node {
    constructor(element) {
        this.element = element;
        this.next = Node.Undefined;
        this.prev = Node.Undefined;
    }
}
Node.Undefined = new Node(undefined);
class LinkedList {
    constructor() {
        this._first = Node.Undefined;
        this._last = Node.Undefined;
        this._size = 0;
    }
    get size() {
        return this._size;
    }
    isEmpty() {
        return this._first === Node.Undefined;
    }
    clear() {
        this._first = Node.Undefined;
        this._last = Node.Undefined;
        this._size = 0;
    }
    unshift(element) {
        return this._insert(element, false);
    }
    push(element) {
        return this._insert(element, true);
    }
    _insert(element, atTheEnd) {
        const newNode = new Node(element);
        if (this._first === Node.Undefined) {
            this._first = newNode;
            this._last = newNode;
        }
        else if (atTheEnd) {
            // push
            const oldLast = this._last;
            this._last = newNode;
            newNode.prev = oldLast;
            oldLast.next = newNode;
        }
        else {
            // unshift
            const oldFirst = this._first;
            this._first = newNode;
            newNode.next = oldFirst;
            oldFirst.prev = newNode;
        }
        this._size += 1;
        let didRemove = false;
        return () => {
            if (!didRemove) {
                didRemove = true;
                this._remove(newNode);
            }
        };
    }
    shift() {
        if (this._first === Node.Undefined) {
            return undefined;
        }
        else {
            const res = this._first.element;
            this._remove(this._first);
            return res;
        }
    }
    pop() {
        if (this._last === Node.Undefined) {
            return undefined;
        }
        else {
            const res = this._last.element;
            this._remove(this._last);
            return res;
        }
    }
    _remove(node) {
        if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
            // middle
            const anchor = node.prev;
            anchor.next = node.next;
            node.next.prev = anchor;
        }
        else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
            // only node
            this._first = Node.Undefined;
            this._last = Node.Undefined;
        }
        else if (node.next === Node.Undefined) {
            // last
            this._last = this._last.prev;
            this._last.next = Node.Undefined;
        }
        else if (node.prev === Node.Undefined) {
            // first
            this._first = this._first.next;
            this._first.prev = Node.Undefined;
        }
        // done
        this._size -= 1;
    }
    *[Symbol.iterator]() {
        let node = this._first;
        while (node !== Node.Undefined) {
            yield node.element;
            node = node.next;
        }
    }
    toArray() {
        const result = [];
        for (let node = this._first; node !== Node.Undefined; node = node.next) {
            result.push(node.element);
        }
        return result;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/path.js":
/*!***************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/path.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "basename": () => (/* binding */ basename),
/* harmony export */   "dirname": () => (/* binding */ dirname),
/* harmony export */   "extname": () => (/* binding */ extname),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "posix": () => (/* binding */ posix),
/* harmony export */   "relative": () => (/* binding */ relative),
/* harmony export */   "resolve": () => (/* binding */ resolve),
/* harmony export */   "sep": () => (/* binding */ sep),
/* harmony export */   "win32": () => (/* binding */ win32)
/* harmony export */ });
/* harmony import */ var _process_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./process.js */ "./node_modules/monaco-editor/esm/vs/base/common/process.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace
// Copied from: https://github.com/nodejs/node/blob/v12.8.1/lib/path.js
/**
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

const CHAR_UPPERCASE_A = 65; /* A */
const CHAR_LOWERCASE_A = 97; /* a */
const CHAR_UPPERCASE_Z = 90; /* Z */
const CHAR_LOWERCASE_Z = 122; /* z */
const CHAR_DOT = 46; /* . */
const CHAR_FORWARD_SLASH = 47; /* / */
const CHAR_BACKWARD_SLASH = 92; /* \ */
const CHAR_COLON = 58; /* : */
const CHAR_QUESTION_MARK = 63; /* ? */
class ErrorInvalidArgType extends Error {
    constructor(name, expected, actual) {
        // determiner: 'must be' or 'must not be'
        let determiner;
        if (typeof expected === 'string' && expected.indexOf('not ') === 0) {
            determiner = 'must not be';
            expected = expected.replace(/^not /, '');
        }
        else {
            determiner = 'must be';
        }
        const type = name.indexOf('.') !== -1 ? 'property' : 'argument';
        let msg = `The "${name}" ${type} ${determiner} of type ${expected}`;
        msg += `. Received type ${typeof actual}`;
        super(msg);
        this.code = 'ERR_INVALID_ARG_TYPE';
    }
}
function validateString(value, name) {
    if (typeof value !== 'string') {
        throw new ErrorInvalidArgType(name, 'string', value);
    }
}
function isPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
}
function isPosixPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH;
}
function isWindowsDeviceRoot(code) {
    return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z ||
        code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;
}
// Resolves . and .. elements in a path with directory names
function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
    let res = '';
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = 0;
    for (let i = 0; i <= path.length; ++i) {
        if (i < path.length) {
            code = path.charCodeAt(i);
        }
        else if (isPathSeparator(code)) {
            break;
        }
        else {
            code = CHAR_FORWARD_SLASH;
        }
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {
                // NOOP
            }
            else if (dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 ||
                    res.charCodeAt(res.length - 1) !== CHAR_DOT ||
                    res.charCodeAt(res.length - 2) !== CHAR_DOT) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = '';
                            lastSegmentLength = 0;
                        }
                        else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                    else if (res.length !== 0) {
                        res = '';
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    res += res.length > 0 ? `${separator}..` : '..';
                    lastSegmentLength = 2;
                }
            }
            else {
                if (res.length > 0) {
                    res += `${separator}${path.slice(lastSlash + 1, i)}`;
                }
                else {
                    res = path.slice(lastSlash + 1, i);
                }
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        }
        else if (code === CHAR_DOT && dots !== -1) {
            ++dots;
        }
        else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep, pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
        throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);
    }
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base ||
        `${pathObject.name || ''}${pathObject.ext || ''}`;
    if (!dir) {
        return base;
    }
    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;
}
const win32 = {
    // path.resolve([from ...], to)
    resolve(...pathSegments) {
        let resolvedDevice = '';
        let resolvedTail = '';
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1; i--) {
            let path;
            if (i >= 0) {
                path = pathSegments[i];
                validateString(path, 'path');
                // Skip empty entries
                if (path.length === 0) {
                    continue;
                }
            }
            else if (resolvedDevice.length === 0) {
                path = _process_js__WEBPACK_IMPORTED_MODULE_0__.cwd();
            }
            else {
                // Windows has the concept of drive-specific current working
                // directories. If we've resolved a drive letter but not yet an
                // absolute path, get cwd for that drive, or the process cwd if
                // the drive cwd is not available. We're sure the device is not
                // a UNC path at this points, because UNC paths are always absolute.
                path = _process_js__WEBPACK_IMPORTED_MODULE_0__.env[`=${resolvedDevice}`] || _process_js__WEBPACK_IMPORTED_MODULE_0__.cwd();
                // Verify that a cwd was found and that it actually points
                // to our drive. If not, default to the drive's root.
                if (path === undefined ||
                    path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&
                        path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
                    path = `${resolvedDevice}\\`;
                }
            }
            const len = path.length;
            let rootEnd = 0;
            let device = '';
            let isAbsolute = false;
            const code = path.charCodeAt(0);
            // Try to match a root
            if (len === 1) {
                if (isPathSeparator(code)) {
                    // `path` contains just a path separator
                    rootEnd = 1;
                    isAbsolute = true;
                }
            }
            else if (isPathSeparator(code)) {
                // Possible UNC root
                // If we started with a separator, we know we at least have an
                // absolute path of some kind (UNC or otherwise)
                isAbsolute = true;
                if (isPathSeparator(path.charCodeAt(1))) {
                    // Matched double path separator at beginning
                    let j = 2;
                    let last = j;
                    // Match 1 or more non-path separators
                    while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                        j++;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        // Matched!
                        last = j;
                        // Match 1 or more path separators
                        while (j < len && isPathSeparator(path.charCodeAt(j))) {
                            j++;
                        }
                        if (j < len && j !== last) {
                            // Matched!
                            last = j;
                            // Match 1 or more non-path separators
                            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                                j++;
                            }
                            if (j === len || j !== last) {
                                // We matched a UNC root
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                }
                else {
                    rootEnd = 1;
                }
            }
            else if (isWindowsDeviceRoot(code) &&
                path.charCodeAt(1) === CHAR_COLON) {
                // Possible device root
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
                    // Treat separator following drive name as an absolute path
                    // indicator
                    isAbsolute = true;
                    rootEnd = 3;
                }
            }
            if (device.length > 0) {
                if (resolvedDevice.length > 0) {
                    if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                        // This path points to another device so it is not applicable
                        continue;
                    }
                }
                else {
                    resolvedDevice = device;
                }
            }
            if (resolvedAbsolute) {
                if (resolvedDevice.length > 0) {
                    break;
                }
            }
            else {
                resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
                resolvedAbsolute = isAbsolute;
                if (isAbsolute && resolvedDevice.length > 0) {
                    break;
                }
            }
        }
        // At this point the path should be resolved to a full absolute path,
        // but handle relative paths to be safe (might happen when process.cwd()
        // fails)
        // Normalize the tail path
        resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\', isPathSeparator);
        return resolvedAbsolute ?
            `${resolvedDevice}\\${resolvedTail}` :
            `${resolvedDevice}${resolvedTail}` || '.';
    },
    normalize(path) {
        validateString(path, 'path');
        const len = path.length;
        if (len === 0) {
            return '.';
        }
        let rootEnd = 0;
        let device;
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        // Try to match a root
        if (len === 1) {
            // `path` contains just a single char, exit early to avoid
            // unnecessary work
            return isPosixPathSeparator(code) ? '\\' : path;
        }
        if (isPathSeparator(code)) {
            // Possible UNC root
            // If we started with a separator, we know we at least have an absolute
            // path of some kind (UNC or otherwise)
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
                // Matched double path separator at beginning
                let j = 2;
                let last = j;
                // Match 1 or more non-path separators
                while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    // Matched!
                    last = j;
                    // Match 1 or more path separators
                    while (j < len && isPathSeparator(path.charCodeAt(j))) {
                        j++;
                    }
                    if (j < len && j !== last) {
                        // Matched!
                        last = j;
                        // Match 1 or more non-path separators
                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                            j++;
                        }
                        if (j === len) {
                            // We matched a UNC root only
                            // Return the normalized version of the UNC root since there
                            // is nothing left to process
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        }
                        if (j !== last) {
                            // We matched a UNC root with leftovers
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            }
            else {
                rootEnd = 1;
            }
        }
        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            // Possible device root
            device = path.slice(0, 2);
            rootEnd = 2;
            if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
                // Treat separator following drive name as an absolute path
                // indicator
                isAbsolute = true;
                rootEnd = 3;
            }
        }
        let tail = rootEnd < len ?
            normalizeString(path.slice(rootEnd), !isAbsolute, '\\', isPathSeparator) :
            '';
        if (tail.length === 0 && !isAbsolute) {
            tail = '.';
        }
        if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
            tail += '\\';
        }
        if (device === undefined) {
            return isAbsolute ? `\\${tail}` : tail;
        }
        return isAbsolute ? `${device}\\${tail}` : `${device}${tail}`;
    },
    isAbsolute(path) {
        validateString(path, 'path');
        const len = path.length;
        if (len === 0) {
            return false;
        }
        const code = path.charCodeAt(0);
        return isPathSeparator(code) ||
            // Possible device root
            len > 2 &&
                isWindowsDeviceRoot(code) &&
                path.charCodeAt(1) === CHAR_COLON &&
                isPathSeparator(path.charCodeAt(2));
    },
    join(...paths) {
        if (paths.length === 0) {
            return '.';
        }
        let joined;
        let firstPart;
        for (let i = 0; i < paths.length; ++i) {
            const arg = paths[i];
            validateString(arg, 'path');
            if (arg.length > 0) {
                if (joined === undefined) {
                    joined = firstPart = arg;
                }
                else {
                    joined += `\\${arg}`;
                }
            }
        }
        if (joined === undefined) {
            return '.';
        }
        // Make sure that the joined path doesn't start with two slashes, because
        // normalize() will mistake it for an UNC path then.
        //
        // This step is skipped when it is very clear that the user actually
        // intended to point at an UNC path. This is assumed when the first
        // non-empty string arguments starts with exactly two slashes followed by
        // at least one more non-slash character.
        //
        // Note that for normalize() to treat a path as an UNC path it needs to
        // have at least 2 components, so we don't filter for that here.
        // This means that the user can use join to construct UNC paths from
        // a server name and a share name; for example:
        //   path.join('//server', 'share') -> '\\\\server\\share\\')
        let needsReplace = true;
        let slashCount = 0;
        if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {
            ++slashCount;
            const firstLen = firstPart.length;
            if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) {
                        ++slashCount;
                    }
                    else {
                        // We matched a UNC path in the first part
                        needsReplace = false;
                    }
                }
            }
        }
        if (needsReplace) {
            // Find any more consecutive slashes we need to replace
            while (slashCount < joined.length &&
                isPathSeparator(joined.charCodeAt(slashCount))) {
                slashCount++;
            }
            // Replace the slashes if needed
            if (slashCount >= 2) {
                joined = `\\${joined.slice(slashCount)}`;
            }
        }
        return win32.normalize(joined);
    },
    // It will solve the relative path from `from` to `to`, for instance:
    //  from = 'C:\\orandea\\test\\aaa'
    //  to = 'C:\\orandea\\impl\\bbb'
    // The output of the function should be: '..\\..\\impl\\bbb'
    relative(from, to) {
        validateString(from, 'from');
        validateString(to, 'to');
        if (from === to) {
            return '';
        }
        const fromOrig = win32.resolve(from);
        const toOrig = win32.resolve(to);
        if (fromOrig === toOrig) {
            return '';
        }
        from = fromOrig.toLowerCase();
        to = toOrig.toLowerCase();
        if (from === to) {
            return '';
        }
        // Trim any leading backslashes
        let fromStart = 0;
        while (fromStart < from.length &&
            from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
            fromStart++;
        }
        // Trim trailing backslashes (applicable to UNC paths only)
        let fromEnd = from.length;
        while (fromEnd - 1 > fromStart &&
            from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
            fromEnd--;
        }
        const fromLen = fromEnd - fromStart;
        // Trim any leading backslashes
        let toStart = 0;
        while (toStart < to.length &&
            to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
            toStart++;
        }
        // Trim trailing backslashes (applicable to UNC paths only)
        let toEnd = to.length;
        while (toEnd - 1 > toStart &&
            to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
            toEnd--;
        }
        const toLen = toEnd - toStart;
        // Compare paths to find the longest common path from root
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i < length; i++) {
            const fromCode = from.charCodeAt(fromStart + i);
            if (fromCode !== to.charCodeAt(toStart + i)) {
                break;
            }
            else if (fromCode === CHAR_BACKWARD_SLASH) {
                lastCommonSep = i;
            }
        }
        // We found a mismatch before the first common path separator was seen, so
        // return the original `to`.
        if (i !== length) {
            if (lastCommonSep === -1) {
                return toOrig;
            }
        }
        else {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
                    // We get here if `from` is the exact base path for `to`.
                    // For example: from='C:\\foo\\bar'; to='C:\\foo\\bar\\baz'
                    return toOrig.slice(toStart + i + 1);
                }
                if (i === 2) {
                    // We get here if `from` is the device root.
                    // For example: from='C:\\'; to='C:\\foo'
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
                    // We get here if `to` is the exact base path for `from`.
                    // For example: from='C:\\foo\\bar'; to='C:\\foo'
                    lastCommonSep = i;
                }
                else if (i === 2) {
                    // We get here if `to` is the device root.
                    // For example: from='C:\\foo\\bar'; to='C:\\'
                    lastCommonSep = 3;
                }
            }
            if (lastCommonSep === -1) {
                lastCommonSep = 0;
            }
        }
        let out = '';
        // Generate the relative path based on the path difference between `to` and
        // `from`
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
                out += out.length === 0 ? '..' : '\\..';
            }
        }
        toStart += lastCommonSep;
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts
        if (out.length > 0) {
            return `${out}${toOrig.slice(toStart, toEnd)}`;
        }
        if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
            ++toStart;
        }
        return toOrig.slice(toStart, toEnd);
    },
    toNamespacedPath(path) {
        // Note: this will *probably* throw somewhere.
        if (typeof path !== 'string') {
            return path;
        }
        if (path.length === 0) {
            return '';
        }
        const resolvedPath = win32.resolve(path);
        if (resolvedPath.length <= 2) {
            return path;
        }
        if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
            // Possible UNC root
            if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
                    // Matched non-long UNC root, convert the path to a long UNC path
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        }
        else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&
            resolvedPath.charCodeAt(1) === CHAR_COLON &&
            resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
            // Matched device root, convert the path to a long UNC path
            return `\\\\?\\${resolvedPath}`;
        }
        return path;
    },
    dirname(path) {
        validateString(path, 'path');
        const len = path.length;
        if (len === 0) {
            return '.';
        }
        let rootEnd = -1;
        let offset = 0;
        const code = path.charCodeAt(0);
        if (len === 1) {
            // `path` contains just a path separator, exit early to avoid
            // unnecessary work or a dot.
            return isPathSeparator(code) ? path : '.';
        }
        // Try to match a root
        if (isPathSeparator(code)) {
            // Possible UNC root
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                // Matched double path separator at beginning
                let j = 2;
                let last = j;
                // Match 1 or more non-path separators
                while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                }
                if (j < len && j !== last) {
                    // Matched!
                    last = j;
                    // Match 1 or more path separators
                    while (j < len && isPathSeparator(path.charCodeAt(j))) {
                        j++;
                    }
                    if (j < len && j !== last) {
                        // Matched!
                        last = j;
                        // Match 1 or more non-path separators
                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                            j++;
                        }
                        if (j === len) {
                            // We matched a UNC root only
                            return path;
                        }
                        if (j !== last) {
                            // We matched a UNC root with leftovers
                            // Offset by 1 to include the separator after the UNC root to
                            // treat it as a "normal root" on top of a (UNC) root
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
            // Possible device root
        }
        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;
            offset = rootEnd;
        }
        let end = -1;
        let matchedSlash = true;
        for (let i = len - 1; i >= offset; --i) {
            if (isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                // We saw the first non-path separator
                matchedSlash = false;
            }
        }
        if (end === -1) {
            if (rootEnd === -1) {
                return '.';
            }
            end = rootEnd;
        }
        return path.slice(0, end);
    },
    basename(path, ext) {
        if (ext !== undefined) {
            validateString(ext, 'ext');
        }
        validateString(path, 'path');
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        // Check for a drive letter prefix so as not to mistake the following
        // path separator as an extra separator at the end of the path that can be
        // disregarded
        if (path.length >= 2 &&
            isWindowsDeviceRoot(path.charCodeAt(0)) &&
            path.charCodeAt(1) === CHAR_COLON) {
            start = 2;
        }
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext === path) {
                return '';
            }
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= start; --i) {
                const code = path.charCodeAt(i);
                if (isPathSeparator(code)) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                // We matched the extension, so mark this as the end of our path
                                // component
                                end = i;
                            }
                        }
                        else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end) {
                end = firstNonSlashEnd;
            }
            else if (end === -1) {
                end = path.length;
            }
            return path.slice(start, end);
        }
        for (i = path.length - 1; i >= start; --i) {
            if (isPathSeparator(path.charCodeAt(i))) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            }
            else if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // path component
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) {
            return '';
        }
        return path.slice(start, end);
    },
    extname(path) {
        validateString(path, 'path');
        let start = 0;
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        // Check for a drive letter prefix so as not to mistake the following
        // path separator as an extra separator at the end of the path that can be
        // disregarded
        if (path.length >= 2 &&
            path.charCodeAt(1) === CHAR_COLON &&
            isWindowsDeviceRoot(path.charCodeAt(0))) {
            start = startPart = 2;
        }
        for (let i = path.length - 1; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) {
                    startDot = i;
                }
                else if (preDotState !== 1) {
                    preDotState = 1;
                }
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 &&
                startDot === end - 1 &&
                startDot === startPart + 1)) {
            return '';
        }
        return path.slice(startDot, end);
    },
    format: _format.bind(null, '\\'),
    parse(path) {
        validateString(path, 'path');
        const ret = { root: '', dir: '', base: '', ext: '', name: '' };
        if (path.length === 0) {
            return ret;
        }
        const len = path.length;
        let rootEnd = 0;
        let code = path.charCodeAt(0);
        if (len === 1) {
            if (isPathSeparator(code)) {
                // `path` contains just a path separator, exit early to avoid
                // unnecessary work
                ret.root = ret.dir = path;
                return ret;
            }
            ret.base = ret.name = path;
            return ret;
        }
        // Try to match a root
        if (isPathSeparator(code)) {
            // Possible UNC root
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                // Matched double path separator at beginning
                let j = 2;
                let last = j;
                // Match 1 or more non-path separators
                while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                }
                if (j < len && j !== last) {
                    // Matched!
                    last = j;
                    // Match 1 or more path separators
                    while (j < len && isPathSeparator(path.charCodeAt(j))) {
                        j++;
                    }
                    if (j < len && j !== last) {
                        // Matched!
                        last = j;
                        // Match 1 or more non-path separators
                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                            j++;
                        }
                        if (j === len) {
                            // We matched a UNC root only
                            rootEnd = j;
                        }
                        else if (j !== last) {
                            // We matched a UNC root with leftovers
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        }
        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            // Possible device root
            if (len <= 2) {
                // `path` contains just a drive root, exit early to avoid
                // unnecessary work
                ret.root = ret.dir = path;
                return ret;
            }
            rootEnd = 2;
            if (isPathSeparator(path.charCodeAt(2))) {
                if (len === 3) {
                    // `path` contains just a drive root, exit early to avoid
                    // unnecessary work
                    ret.root = ret.dir = path;
                    return ret;
                }
                rootEnd = 3;
            }
        }
        if (rootEnd > 0) {
            ret.root = path.slice(0, rootEnd);
        }
        let startDot = -1;
        let startPart = rootEnd;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        // Get non-dir info
        for (; i >= rootEnd; --i) {
            code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) {
                    startDot = i;
                }
                else if (preDotState !== 1) {
                    preDotState = 1;
                }
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (end !== -1) {
            if (startDot === -1 ||
                // We saw a non-dot character immediately before the dot
                preDotState === 0 ||
                // The (right-most) trimmed path component is exactly '..'
                (preDotState === 1 &&
                    startDot === end - 1 &&
                    startDot === startPart + 1)) {
                ret.base = ret.name = path.slice(startPart, end);
            }
            else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
                ret.ext = path.slice(startDot, end);
            }
        }
        // If the directory is the root, use the entire root as the `dir` including
        // the trailing slash if any (`C:\abc` -> `C:\`). Otherwise, strip out the
        // trailing slash (`C:\abc\def` -> `C:\abc`).
        if (startPart > 0 && startPart !== rootEnd) {
            ret.dir = path.slice(0, startPart - 1);
        }
        else {
            ret.dir = ret.root;
        }
        return ret;
    },
    sep: '\\',
    delimiter: ';',
    win32: null,
    posix: null
};
const posix = {
    // path.resolve([from ...], to)
    resolve(...pathSegments) {
        let resolvedPath = '';
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            const path = i >= 0 ? pathSegments[i] : _process_js__WEBPACK_IMPORTED_MODULE_0__.cwd();
            validateString(path, 'path');
            // Skip empty entries
            if (path.length === 0) {
                continue;
            }
            resolvedPath = `${path}/${resolvedPath}`;
            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        // Normalize the path
        resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);
        if (resolvedAbsolute) {
            return `/${resolvedPath}`;
        }
        return resolvedPath.length > 0 ? resolvedPath : '.';
    },
    normalize(path) {
        validateString(path, 'path');
        if (path.length === 0) {
            return '.';
        }
        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;
        // Normalize the path
        path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);
        if (path.length === 0) {
            if (isAbsolute) {
                return '/';
            }
            return trailingSeparator ? './' : '.';
        }
        if (trailingSeparator) {
            path += '/';
        }
        return isAbsolute ? `/${path}` : path;
    },
    isAbsolute(path) {
        validateString(path, 'path');
        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    },
    join(...paths) {
        if (paths.length === 0) {
            return '.';
        }
        let joined;
        for (let i = 0; i < paths.length; ++i) {
            const arg = paths[i];
            validateString(arg, 'path');
            if (arg.length > 0) {
                if (joined === undefined) {
                    joined = arg;
                }
                else {
                    joined += `/${arg}`;
                }
            }
        }
        if (joined === undefined) {
            return '.';
        }
        return posix.normalize(joined);
    },
    relative(from, to) {
        validateString(from, 'from');
        validateString(to, 'to');
        if (from === to) {
            return '';
        }
        // Trim leading forward slashes.
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) {
            return '';
        }
        const fromStart = 1;
        const fromEnd = from.length;
        const fromLen = fromEnd - fromStart;
        const toStart = 1;
        const toLen = to.length - toStart;
        // Compare paths to find the longest common path from root
        const length = (fromLen < toLen ? fromLen : toLen);
        let lastCommonSep = -1;
        let i = 0;
        for (; i < length; i++) {
            const fromCode = from.charCodeAt(fromStart + i);
            if (fromCode !== to.charCodeAt(toStart + i)) {
                break;
            }
            else if (fromCode === CHAR_FORWARD_SLASH) {
                lastCommonSep = i;
            }
        }
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
                    // We get here if `from` is the exact base path for `to`.
                    // For example: from='/foo/bar'; to='/foo/bar/baz'
                    return to.slice(toStart + i + 1);
                }
                if (i === 0) {
                    // We get here if `from` is the root
                    // For example: from='/'; to='/foo'
                    return to.slice(toStart + i);
                }
            }
            else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
                    // We get here if `to` is the exact base path for `from`.
                    // For example: from='/foo/bar/baz'; to='/foo/bar'
                    lastCommonSep = i;
                }
                else if (i === 0) {
                    // We get here if `to` is the root.
                    // For example: from='/foo/bar'; to='/'
                    lastCommonSep = 0;
                }
            }
        }
        let out = '';
        // Generate the relative path based on the path difference between `to`
        // and `from`.
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
                out += out.length === 0 ? '..' : '/..';
            }
        }
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts.
        return `${out}${to.slice(toStart + lastCommonSep)}`;
    },
    toNamespacedPath(path) {
        // Non-op on posix systems
        return path;
    },
    dirname(path) {
        validateString(path, 'path');
        if (path.length === 0) {
            return '.';
        }
        const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        let end = -1;
        let matchedSlash = true;
        for (let i = path.length - 1; i >= 1; --i) {
            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                // We saw the first non-path separator
                matchedSlash = false;
            }
        }
        if (end === -1) {
            return hasRoot ? '/' : '.';
        }
        if (hasRoot && end === 1) {
            return '//';
        }
        return path.slice(0, end);
    },
    basename(path, ext) {
        if (ext !== undefined) {
            validateString(ext, 'ext');
        }
        validateString(path, 'path');
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext === path) {
                return '';
            }
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= 0; --i) {
                const code = path.charCodeAt(i);
                if (code === CHAR_FORWARD_SLASH) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                // We matched the extension, so mark this as the end of our path
                                // component
                                end = i;
                            }
                        }
                        else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end) {
                end = firstNonSlashEnd;
            }
            else if (end === -1) {
                end = path.length;
            }
            return path.slice(start, end);
        }
        for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            }
            else if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // path component
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) {
            return '';
        }
        return path.slice(start, end);
    },
    extname(path) {
        validateString(path, 'path');
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        for (let i = path.length - 1; i >= 0; --i) {
            const code = path.charCodeAt(i);
            if (code === CHAR_FORWARD_SLASH) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) {
                    startDot = i;
                }
                else if (preDotState !== 1) {
                    preDotState = 1;
                }
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 &&
                startDot === end - 1 &&
                startDot === startPart + 1)) {
            return '';
        }
        return path.slice(startDot, end);
    },
    format: _format.bind(null, '/'),
    parse(path) {
        validateString(path, 'path');
        const ret = { root: '', dir: '', base: '', ext: '', name: '' };
        if (path.length === 0) {
            return ret;
        }
        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        let start;
        if (isAbsolute) {
            ret.root = '/';
            start = 1;
        }
        else {
            start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        // Get non-dir info
        for (; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (code === CHAR_FORWARD_SLASH) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) {
                    startDot = i;
                }
                else if (preDotState !== 1) {
                    preDotState = 1;
                }
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (end !== -1) {
            const start = startPart === 0 && isAbsolute ? 1 : startPart;
            if (startDot === -1 ||
                // We saw a non-dot character immediately before the dot
                preDotState === 0 ||
                // The (right-most) trimmed path component is exactly '..'
                (preDotState === 1 &&
                    startDot === end - 1 &&
                    startDot === startPart + 1)) {
                ret.base = ret.name = path.slice(start, end);
            }
            else {
                ret.name = path.slice(start, startDot);
                ret.base = path.slice(start, end);
                ret.ext = path.slice(startDot, end);
            }
        }
        if (startPart > 0) {
            ret.dir = path.slice(0, startPart - 1);
        }
        else if (isAbsolute) {
            ret.dir = '/';
        }
        return ret;
    },
    sep: '/',
    delimiter: ':',
    win32: null,
    posix: null
};
posix.win32 = win32.win32 = win32;
posix.posix = win32.posix = posix;
const normalize = (_process_js__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.normalize : posix.normalize);
const resolve = (_process_js__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.resolve : posix.resolve);
const relative = (_process_js__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.relative : posix.relative);
const dirname = (_process_js__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.dirname : posix.dirname);
const basename = (_process_js__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.basename : posix.basename);
const extname = (_process_js__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.extname : posix.extname);
const sep = (_process_js__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.sep : posix.sep);


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/platform.js":
/*!*******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/platform.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OS": () => (/* binding */ OS),
/* harmony export */   "globals": () => (/* binding */ globals),
/* harmony export */   "isIOS": () => (/* binding */ isIOS),
/* harmony export */   "isLinux": () => (/* binding */ isLinux),
/* harmony export */   "isLittleEndian": () => (/* binding */ isLittleEndian),
/* harmony export */   "isMacintosh": () => (/* binding */ isMacintosh),
/* harmony export */   "isNative": () => (/* binding */ isNative),
/* harmony export */   "isWeb": () => (/* binding */ isWeb),
/* harmony export */   "isWindows": () => (/* binding */ isWindows),
/* harmony export */   "setImmediate": () => (/* binding */ setImmediate)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const LANGUAGE_DEFAULT = 'en';
let _isWindows = false;
let _isMacintosh = false;
let _isLinux = false;
let _isNative = false;
let _isWeb = false;
let _isIOS = false;
let _locale = undefined;
let _language = LANGUAGE_DEFAULT;
let _translationsConfigFile = undefined;
let _userAgent = undefined;
const isElectronRenderer = (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions.electron !== 'undefined' && process.type === 'renderer');
// OS detection
if (typeof navigator === 'object' && !isElectronRenderer) {
    _userAgent = navigator.userAgent;
    _isWindows = _userAgent.indexOf('Windows') >= 0;
    _isMacintosh = _userAgent.indexOf('Macintosh') >= 0;
    _isIOS = (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
    _isLinux = _userAgent.indexOf('Linux') >= 0;
    _isWeb = true;
    _locale = navigator.language;
    _language = _locale;
}
else if (typeof process === 'object') {
    _isWindows = (process.platform === 'win32');
    _isMacintosh = (process.platform === 'darwin');
    _isLinux = (process.platform === 'linux');
    _locale = LANGUAGE_DEFAULT;
    _language = LANGUAGE_DEFAULT;
    const rawNlsConfig = process.env['VSCODE_NLS_CONFIG'];
    if (rawNlsConfig) {
        try {
            const nlsConfig = JSON.parse(rawNlsConfig);
            const resolved = nlsConfig.availableLanguages['*'];
            _locale = nlsConfig.locale;
            // VSCode's default language is 'en'
            _language = resolved ? resolved : LANGUAGE_DEFAULT;
            _translationsConfigFile = nlsConfig._translationsConfigFile;
        }
        catch (e) {
        }
    }
    _isNative = true;
}
let _platform = 0 /* Web */;
if (_isMacintosh) {
    _platform = 1 /* Mac */;
}
else if (_isWindows) {
    _platform = 3 /* Windows */;
}
else if (_isLinux) {
    _platform = 2 /* Linux */;
}
const isWindows = _isWindows;
const isMacintosh = _isMacintosh;
const isLinux = _isLinux;
const isNative = _isNative;
const isWeb = _isWeb;
const isIOS = _isIOS;
const _globals = (typeof self === 'object' ? self : typeof __webpack_require__.g === 'object' ? __webpack_require__.g : {});
const globals = _globals;
const setImmediate = (function defineSetImmediate() {
    if (globals.setImmediate) {
        return globals.setImmediate.bind(globals);
    }
    if (typeof globals.postMessage === 'function' && !globals.importScripts) {
        let pending = [];
        globals.addEventListener('message', (e) => {
            if (e.data && e.data.vscodeSetImmediateId) {
                for (let i = 0, len = pending.length; i < len; i++) {
                    const candidate = pending[i];
                    if (candidate.id === e.data.vscodeSetImmediateId) {
                        pending.splice(i, 1);
                        candidate.callback();
                        return;
                    }
                }
            }
        });
        let lastId = 0;
        return (callback) => {
            const myId = ++lastId;
            pending.push({
                id: myId,
                callback: callback
            });
            globals.postMessage({ vscodeSetImmediateId: myId }, '*');
        };
    }
    if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {
        return process.nextTick.bind(process);
    }
    const _promise = Promise.resolve();
    return (callback) => _promise.then(callback);
})();
const OS = (_isMacintosh || _isIOS ? 2 /* Macintosh */ : (_isWindows ? 1 /* Windows */ : 3 /* Linux */));
let _isLittleEndian = true;
let _isLittleEndianComputed = false;
function isLittleEndian() {
    if (!_isLittleEndianComputed) {
        _isLittleEndianComputed = true;
        const test = new Uint8Array(2);
        test[0] = 1;
        test[1] = 2;
        const view = new Uint16Array(test.buffer);
        _isLittleEndian = (view[0] === (2 << 8) + 1);
    }
    return _isLittleEndian;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/process.js":
/*!******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/process.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cwd": () => (/* binding */ cwd),
/* harmony export */   "env": () => (/* binding */ env),
/* harmony export */   "platform": () => (/* binding */ platform)
/* harmony export */ });
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform.js */ "./node_modules/monaco-editor/esm/vs/base/common/platform.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const safeProcess = (typeof process === 'undefined') ? {
    cwd() { return '/'; },
    env: Object.create(null),
    get platform() { return _platform_js__WEBPACK_IMPORTED_MODULE_0__.isWindows ? 'win32' : _platform_js__WEBPACK_IMPORTED_MODULE_0__.isMacintosh ? 'darwin' : 'linux'; },
    nextTick(callback) { return (0,_platform_js__WEBPACK_IMPORTED_MODULE_0__.setImmediate)(callback); }
} : process;
const cwd = safeProcess.cwd;
const env = safeProcess.env;
const platform = safeProcess.platform;


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/strings.js":
/*!******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/strings.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UNUSUAL_LINE_TERMINATORS": () => (/* binding */ UNUSUAL_LINE_TERMINATORS),
/* harmony export */   "UTF8_BOM_CHARACTER": () => (/* binding */ UTF8_BOM_CHARACTER),
/* harmony export */   "breakBetweenGraphemeBreakType": () => (/* binding */ breakBetweenGraphemeBreakType),
/* harmony export */   "commonPrefixLength": () => (/* binding */ commonPrefixLength),
/* harmony export */   "commonSuffixLength": () => (/* binding */ commonSuffixLength),
/* harmony export */   "compare": () => (/* binding */ compare),
/* harmony export */   "compareIgnoreCase": () => (/* binding */ compareIgnoreCase),
/* harmony export */   "compareSubstring": () => (/* binding */ compareSubstring),
/* harmony export */   "compareSubstringIgnoreCase": () => (/* binding */ compareSubstringIgnoreCase),
/* harmony export */   "computeCodePoint": () => (/* binding */ computeCodePoint),
/* harmony export */   "containsEmoji": () => (/* binding */ containsEmoji),
/* harmony export */   "containsFullWidthCharacter": () => (/* binding */ containsFullWidthCharacter),
/* harmony export */   "containsRTL": () => (/* binding */ containsRTL),
/* harmony export */   "containsUnusualLineTerminators": () => (/* binding */ containsUnusualLineTerminators),
/* harmony export */   "containsUppercaseCharacter": () => (/* binding */ containsUppercaseCharacter),
/* harmony export */   "convertSimple2RegExpPattern": () => (/* binding */ convertSimple2RegExpPattern),
/* harmony export */   "createRegExp": () => (/* binding */ createRegExp),
/* harmony export */   "decodeUTF8": () => (/* binding */ decodeUTF8),
/* harmony export */   "endsWith": () => (/* binding */ endsWith),
/* harmony export */   "equalsIgnoreCase": () => (/* binding */ equalsIgnoreCase),
/* harmony export */   "escape": () => (/* binding */ escape),
/* harmony export */   "escapeRegExpCharacters": () => (/* binding */ escapeRegExpCharacters),
/* harmony export */   "firstNonWhitespaceIndex": () => (/* binding */ firstNonWhitespaceIndex),
/* harmony export */   "format": () => (/* binding */ format),
/* harmony export */   "getGraphemeBreakType": () => (/* binding */ getGraphemeBreakType),
/* harmony export */   "getLeadingWhitespace": () => (/* binding */ getLeadingWhitespace),
/* harmony export */   "getNextCodePoint": () => (/* binding */ getNextCodePoint),
/* harmony export */   "isBasicASCII": () => (/* binding */ isBasicASCII),
/* harmony export */   "isEmojiImprecise": () => (/* binding */ isEmojiImprecise),
/* harmony export */   "isFalsyOrWhitespace": () => (/* binding */ isFalsyOrWhitespace),
/* harmony export */   "isFullWidthCharacter": () => (/* binding */ isFullWidthCharacter),
/* harmony export */   "isHighSurrogate": () => (/* binding */ isHighSurrogate),
/* harmony export */   "isLowSurrogate": () => (/* binding */ isLowSurrogate),
/* harmony export */   "isLowerAsciiLetter": () => (/* binding */ isLowerAsciiLetter),
/* harmony export */   "isUpperAsciiLetter": () => (/* binding */ isUpperAsciiLetter),
/* harmony export */   "lastNonWhitespaceIndex": () => (/* binding */ lastNonWhitespaceIndex),
/* harmony export */   "ltrim": () => (/* binding */ ltrim),
/* harmony export */   "nextCharLength": () => (/* binding */ nextCharLength),
/* harmony export */   "pad": () => (/* binding */ pad),
/* harmony export */   "prevCharLength": () => (/* binding */ prevCharLength),
/* harmony export */   "regExpFlags": () => (/* binding */ regExpFlags),
/* harmony export */   "regExpLeadsToEndlessLoop": () => (/* binding */ regExpLeadsToEndlessLoop),
/* harmony export */   "rtrim": () => (/* binding */ rtrim),
/* harmony export */   "singleLetterHash": () => (/* binding */ singleLetterHash),
/* harmony export */   "startsWith": () => (/* binding */ startsWith),
/* harmony export */   "startsWithIgnoreCase": () => (/* binding */ startsWithIgnoreCase),
/* harmony export */   "startsWithUTF8BOM": () => (/* binding */ startsWithUTF8BOM),
/* harmony export */   "stripWildcards": () => (/* binding */ stripWildcards),
/* harmony export */   "trim": () => (/* binding */ trim)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function isFalsyOrWhitespace(str) {
    if (!str || typeof str !== 'string') {
        return true;
    }
    return str.trim().length === 0;
}
/**
 * @deprecated ES6: use `String.padStart`
 */
function pad(n, l, char = '0') {
    const str = '' + n;
    const r = [str];
    for (let i = str.length; i < l; i++) {
        r.push(char);
    }
    return r.reverse().join('');
}
const _formatRegexp = /{(\d+)}/g;
/**
 * Helper to produce a string with a variable number of arguments. Insert variable segments
 * into the string using the {n} notation where N is the index of the argument following the string.
 * @param value string to which formatting is applied
 * @param args replacements for {n}-entries
 */
function format(value, ...args) {
    if (args.length === 0) {
        return value;
    }
    return value.replace(_formatRegexp, function (match, group) {
        const idx = parseInt(group, 10);
        return isNaN(idx) || idx < 0 || idx >= args.length ?
            match :
            args[idx];
    });
}
/**
 * Converts HTML characters inside the string to use entities instead. Makes the string safe from
 * being used e.g. in HTMLElement.innerHTML.
 */
function escape(html) {
    return html.replace(/[<>&]/g, function (match) {
        switch (match) {
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '&': return '&amp;';
            default: return match;
        }
    });
}
/**
 * Escapes regular expression characters in a given string
 */
function escapeRegExpCharacters(value) {
    return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, '\\$&');
}
/**
 * Removes all occurrences of needle from the beginning and end of haystack.
 * @param haystack string to trim
 * @param needle the thing to trim (default is a blank)
 */
function trim(haystack, needle = ' ') {
    const trimmed = ltrim(haystack, needle);
    return rtrim(trimmed, needle);
}
/**
 * Removes all occurrences of needle from the beginning of haystack.
 * @param haystack string to trim
 * @param needle the thing to trim
 */
function ltrim(haystack, needle) {
    if (!haystack || !needle) {
        return haystack;
    }
    const needleLen = needle.length;
    if (needleLen === 0 || haystack.length === 0) {
        return haystack;
    }
    let offset = 0;
    while (haystack.indexOf(needle, offset) === offset) {
        offset = offset + needleLen;
    }
    return haystack.substring(offset);
}
/**
 * Removes all occurrences of needle from the end of haystack.
 * @param haystack string to trim
 * @param needle the thing to trim
 */
function rtrim(haystack, needle) {
    if (!haystack || !needle) {
        return haystack;
    }
    const needleLen = needle.length, haystackLen = haystack.length;
    if (needleLen === 0 || haystackLen === 0) {
        return haystack;
    }
    let offset = haystackLen, idx = -1;
    while (true) {
        idx = haystack.lastIndexOf(needle, offset - 1);
        if (idx === -1 || idx + needleLen !== offset) {
            break;
        }
        if (idx === 0) {
            return '';
        }
        offset = idx;
    }
    return haystack.substring(0, offset);
}
function convertSimple2RegExpPattern(pattern) {
    return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&').replace(/[\*]/g, '.*');
}
function stripWildcards(pattern) {
    return pattern.replace(/\*/g, '');
}
/**
 * @deprecated ES6: use `String.startsWith`
 */
function startsWith(haystack, needle) {
    if (haystack.length < needle.length) {
        return false;
    }
    if (haystack === needle) {
        return true;
    }
    for (let i = 0; i < needle.length; i++) {
        if (haystack[i] !== needle[i]) {
            return false;
        }
    }
    return true;
}
/**
 * @deprecated ES6: use `String.endsWith`
 */
function endsWith(haystack, needle) {
    const diff = haystack.length - needle.length;
    if (diff > 0) {
        return haystack.indexOf(needle, diff) === diff;
    }
    else if (diff === 0) {
        return haystack === needle;
    }
    else {
        return false;
    }
}
function createRegExp(searchString, isRegex, options = {}) {
    if (!searchString) {
        throw new Error('Cannot create regex from empty string');
    }
    if (!isRegex) {
        searchString = escapeRegExpCharacters(searchString);
    }
    if (options.wholeWord) {
        if (!/\B/.test(searchString.charAt(0))) {
            searchString = '\\b' + searchString;
        }
        if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
            searchString = searchString + '\\b';
        }
    }
    let modifiers = '';
    if (options.global) {
        modifiers += 'g';
    }
    if (!options.matchCase) {
        modifiers += 'i';
    }
    if (options.multiline) {
        modifiers += 'm';
    }
    if (options.unicode) {
        modifiers += 'u';
    }
    return new RegExp(searchString, modifiers);
}
function regExpLeadsToEndlessLoop(regexp) {
    // Exit early if it's one of these special cases which are meant to match
    // against an empty string
    if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\s*$') {
        return false;
    }
    // We check against an empty string. If the regular expression doesn't advance
    // (e.g. ends in an endless loop) it will match an empty string.
    const match = regexp.exec('');
    return !!(match && regexp.lastIndex === 0);
}
function regExpFlags(regexp) {
    return (regexp.global ? 'g' : '')
        + (regexp.ignoreCase ? 'i' : '')
        + (regexp.multiline ? 'm' : '')
        + (regexp /* standalone editor compilation */.unicode ? 'u' : '');
}
/**
 * Returns first index of the string that is not whitespace.
 * If string is empty or contains only whitespaces, returns -1
 */
function firstNonWhitespaceIndex(str) {
    for (let i = 0, len = str.length; i < len; i++) {
        const chCode = str.charCodeAt(i);
        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
            return i;
        }
    }
    return -1;
}
/**
 * Returns the leading whitespace of the string.
 * If the string contains only whitespaces, returns entire string
 */
function getLeadingWhitespace(str, start = 0, end = str.length) {
    for (let i = start; i < end; i++) {
        const chCode = str.charCodeAt(i);
        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
            return str.substring(start, i);
        }
    }
    return str.substring(start, end);
}
/**
 * Returns last index of the string that is not whitespace.
 * If string is empty or contains only whitespaces, returns -1
 */
function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
    for (let i = startIndex; i >= 0; i--) {
        const chCode = str.charCodeAt(i);
        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
            return i;
        }
    }
    return -1;
}
function compare(a, b) {
    if (a < b) {
        return -1;
    }
    else if (a > b) {
        return 1;
    }
    else {
        return 0;
    }
}
function compareSubstring(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
    for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
        let codeA = a.charCodeAt(aStart);
        let codeB = b.charCodeAt(bStart);
        if (codeA < codeB) {
            return -1;
        }
        else if (codeA > codeB) {
            return 1;
        }
    }
    const aLen = aEnd - aStart;
    const bLen = bEnd - bStart;
    if (aLen < bLen) {
        return -1;
    }
    else if (aLen > bLen) {
        return 1;
    }
    return 0;
}
function compareIgnoreCase(a, b) {
    return compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);
}
function compareSubstringIgnoreCase(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
    for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
        let codeA = a.charCodeAt(aStart);
        let codeB = b.charCodeAt(bStart);
        if (codeA === codeB) {
            // equal
            continue;
        }
        const diff = codeA - codeB;
        if (diff === 32 && isUpperAsciiLetter(codeB)) { //codeB =[65-90] && codeA =[97-122]
            continue;
        }
        else if (diff === -32 && isUpperAsciiLetter(codeA)) { //codeB =[97-122] && codeA =[65-90]
            continue;
        }
        if (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {
            //
            return diff;
        }
        else {
            return compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);
        }
    }
    const aLen = aEnd - aStart;
    const bLen = bEnd - bStart;
    if (aLen < bLen) {
        return -1;
    }
    else if (aLen > bLen) {
        return 1;
    }
    return 0;
}
function isLowerAsciiLetter(code) {
    return code >= 97 /* a */ && code <= 122 /* z */;
}
function isUpperAsciiLetter(code) {
    return code >= 65 /* A */ && code <= 90 /* Z */;
}
function isAsciiLetter(code) {
    return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);
}
function equalsIgnoreCase(a, b) {
    return a.length === b.length && doEqualsIgnoreCase(a, b);
}
function doEqualsIgnoreCase(a, b, stopAt = a.length) {
    for (let i = 0; i < stopAt; i++) {
        const codeA = a.charCodeAt(i);
        const codeB = b.charCodeAt(i);
        if (codeA === codeB) {
            continue;
        }
        // a-z A-Z
        if (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {
            const diff = Math.abs(codeA - codeB);
            if (diff !== 0 && diff !== 32) {
                return false;
            }
        }
        // Any other charcode
        else {
            if (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {
                return false;
            }
        }
    }
    return true;
}
function startsWithIgnoreCase(str, candidate) {
    const candidateLength = candidate.length;
    if (candidate.length > str.length) {
        return false;
    }
    return doEqualsIgnoreCase(str, candidate, candidateLength);
}
/**
 * @returns the length of the common prefix of the two strings.
 */
function commonPrefixLength(a, b) {
    let i, len = Math.min(a.length, b.length);
    for (i = 0; i < len; i++) {
        if (a.charCodeAt(i) !== b.charCodeAt(i)) {
            return i;
        }
    }
    return len;
}
/**
 * @returns the length of the common suffix of the two strings.
 */
function commonSuffixLength(a, b) {
    let i, len = Math.min(a.length, b.length);
    const aLastIndex = a.length - 1;
    const bLastIndex = b.length - 1;
    for (i = 0; i < len; i++) {
        if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {
            return i;
        }
    }
    return len;
}
/**
 * See http://en.wikipedia.org/wiki/Surrogate_pair
 */
function isHighSurrogate(charCode) {
    return (0xD800 <= charCode && charCode <= 0xDBFF);
}
/**
 * See http://en.wikipedia.org/wiki/Surrogate_pair
 */
function isLowSurrogate(charCode) {
    return (0xDC00 <= charCode && charCode <= 0xDFFF);
}
/**
 * See http://en.wikipedia.org/wiki/Surrogate_pair
 */
function computeCodePoint(highSurrogate, lowSurrogate) {
    return ((highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000;
}
/**
 * get the code point that begins at offset `offset`
 */
function getNextCodePoint(str, len, offset) {
    const charCode = str.charCodeAt(offset);
    if (isHighSurrogate(charCode) && offset + 1 < len) {
        const nextCharCode = str.charCodeAt(offset + 1);
        if (isLowSurrogate(nextCharCode)) {
            return computeCodePoint(charCode, nextCharCode);
        }
    }
    return charCode;
}
/**
 * get the code point that ends right before offset `offset`
 */
function getPrevCodePoint(str, offset) {
    const charCode = str.charCodeAt(offset - 1);
    if (isLowSurrogate(charCode) && offset > 1) {
        const prevCharCode = str.charCodeAt(offset - 2);
        if (isHighSurrogate(prevCharCode)) {
            return computeCodePoint(prevCharCode, charCode);
        }
    }
    return charCode;
}
function nextCharLength(str, offset) {
    const graphemeBreakTree = GraphemeBreakTree.getInstance();
    const initialOffset = offset;
    const len = str.length;
    const initialCodePoint = getNextCodePoint(str, len, offset);
    offset += (initialCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);
    let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(initialCodePoint);
    while (offset < len) {
        const nextCodePoint = getNextCodePoint(str, len, offset);
        const nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(nextCodePoint);
        if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {
            break;
        }
        offset += (nextCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);
        graphemeBreakType = nextGraphemeBreakType;
    }
    return (offset - initialOffset);
}
function prevCharLength(str, offset) {
    const graphemeBreakTree = GraphemeBreakTree.getInstance();
    const initialOffset = offset;
    const initialCodePoint = getPrevCodePoint(str, offset);
    offset -= (initialCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);
    let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(initialCodePoint);
    while (offset > 0) {
        const prevCodePoint = getPrevCodePoint(str, offset);
        const prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(prevCodePoint);
        if (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {
            break;
        }
        offset -= (prevCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);
        graphemeBreakType = prevGraphemeBreakType;
    }
    return (initialOffset - offset);
}
/**
 * A manual decoding of a UTF8 string.
 * Use only in environments which do not offer native conversion methods!
 */
function decodeUTF8(buffer) {
    // https://en.wikipedia.org/wiki/UTF-8
    const len = buffer.byteLength;
    const result = [];
    let offset = 0;
    while (offset < len) {
        const v0 = buffer[offset];
        let codePoint;
        if (v0 >= 0b11110000 && offset + 3 < len) {
            // 4 bytes
            codePoint = ((((buffer[offset++] & 0b00000111) << 18) >>> 0)
                | (((buffer[offset++] & 0b00111111) << 12) >>> 0)
                | (((buffer[offset++] & 0b00111111) << 6) >>> 0)
                | (((buffer[offset++] & 0b00111111) << 0) >>> 0));
        }
        else if (v0 >= 0b11100000 && offset + 2 < len) {
            // 3 bytes
            codePoint = ((((buffer[offset++] & 0b00001111) << 12) >>> 0)
                | (((buffer[offset++] & 0b00111111) << 6) >>> 0)
                | (((buffer[offset++] & 0b00111111) << 0) >>> 0));
        }
        else if (v0 >= 0b11000000 && offset + 1 < len) {
            // 2 bytes
            codePoint = ((((buffer[offset++] & 0b00011111) << 6) >>> 0)
                | (((buffer[offset++] & 0b00111111) << 0) >>> 0));
        }
        else {
            // 1 byte
            codePoint = buffer[offset++];
        }
        if ((codePoint >= 0 && codePoint <= 0xD7FF) || (codePoint >= 0xE000 && codePoint <= 0xFFFF)) {
            // Basic Multilingual Plane
            result.push(String.fromCharCode(codePoint));
        }
        else if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
            // Supplementary Planes
            const uPrime = codePoint - 0x10000;
            const w1 = 0xD800 + ((uPrime & 0b11111111110000000000) >>> 10);
            const w2 = 0xDC00 + ((uPrime & 0b00000000001111111111) >>> 0);
            result.push(String.fromCharCode(w1));
            result.push(String.fromCharCode(w2));
        }
        else {
            // illegal code point
            result.push(String.fromCharCode(0xFFFD));
        }
    }
    return result.join('');
}
/**
 * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-rtl-test.js
 */
const CONTAINS_RTL = /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u08BD\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE33\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDCFF]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD50-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
/**
 * Returns true if `str` contains any Unicode character that is classified as "R" or "AL".
 */
function containsRTL(str) {
    return CONTAINS_RTL.test(str);
}
/**
 * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-emoji-test.js
 */
const CONTAINS_EMOJI = /(?:[\u231A\u231B\u23F0\u23F3\u2600-\u27BF\u2B50\u2B55]|\uD83C[\uDDE6-\uDDFF\uDF00-\uDFFF]|\uD83D[\uDC00-\uDE4F\uDE80-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD00-\uDDFF\uDE70-\uDE73\uDE78-\uDE82\uDE90-\uDE95])/;
function containsEmoji(str) {
    return CONTAINS_EMOJI.test(str);
}
const IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
/**
 * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \n, \r, \t
 */
function isBasicASCII(str) {
    return IS_BASIC_ASCII.test(str);
}
const UNUSUAL_LINE_TERMINATORS = /[\u2028\u2029]/; // LINE SEPARATOR (LS) or PARAGRAPH SEPARATOR (PS)
/**
 * Returns true if `str` contains unusual line terminators, like LS or PS
 */
function containsUnusualLineTerminators(str) {
    return UNUSUAL_LINE_TERMINATORS.test(str);
}
function containsFullWidthCharacter(str) {
    for (let i = 0, len = str.length; i < len; i++) {
        if (isFullWidthCharacter(str.charCodeAt(i))) {
            return true;
        }
    }
    return false;
}
function isFullWidthCharacter(charCode) {
    // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns
    // http://jrgraphix.net/research/unicode_blocks.php
    //          2E80 — 2EFF   CJK Radicals Supplement
    //          2F00 — 2FDF   Kangxi Radicals
    //          2FF0 — 2FFF   Ideographic Description Characters
    //          3000 — 303F   CJK Symbols and Punctuation
    //          3040 — 309F   Hiragana
    //          30A0 — 30FF   Katakana
    //          3100 — 312F   Bopomofo
    //          3130 — 318F   Hangul Compatibility Jamo
    //          3190 — 319F   Kanbun
    //          31A0 — 31BF   Bopomofo Extended
    //          31F0 — 31FF   Katakana Phonetic Extensions
    //          3200 — 32FF   Enclosed CJK Letters and Months
    //          3300 — 33FF   CJK Compatibility
    //          3400 — 4DBF   CJK Unified Ideographs Extension A
    //          4DC0 — 4DFF   Yijing Hexagram Symbols
    //          4E00 — 9FFF   CJK Unified Ideographs
    //          A000 — A48F   Yi Syllables
    //          A490 — A4CF   Yi Radicals
    //          AC00 — D7AF   Hangul Syllables
    // [IGNORE] D800 — DB7F   High Surrogates
    // [IGNORE] DB80 — DBFF   High Private Use Surrogates
    // [IGNORE] DC00 — DFFF   Low Surrogates
    // [IGNORE] E000 — F8FF   Private Use Area
    //          F900 — FAFF   CJK Compatibility Ideographs
    // [IGNORE] FB00 — FB4F   Alphabetic Presentation Forms
    // [IGNORE] FB50 — FDFF   Arabic Presentation Forms-A
    // [IGNORE] FE00 — FE0F   Variation Selectors
    // [IGNORE] FE20 — FE2F   Combining Half Marks
    // [IGNORE] FE30 — FE4F   CJK Compatibility Forms
    // [IGNORE] FE50 — FE6F   Small Form Variants
    // [IGNORE] FE70 — FEFF   Arabic Presentation Forms-B
    //          FF00 — FFEF   Halfwidth and Fullwidth Forms
    //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]
    //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E
    // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul
    // [IGNORE] FFF0 — FFFF   Specials
    charCode = +charCode; // @perf
    return ((charCode >= 0x2E80 && charCode <= 0xD7AF)
        || (charCode >= 0xF900 && charCode <= 0xFAFF)
        || (charCode >= 0xFF01 && charCode <= 0xFF5E));
}
/**
 * A fast function (therefore imprecise) to check if code points are emojis.
 * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-emoji-test.js
 */
function isEmojiImprecise(x) {
    return ((x >= 0x1F1E6 && x <= 0x1F1FF) || (x >= 9728 && x <= 10175) || (x >= 127744 && x <= 128591)
        || (x >= 128640 && x <= 128764) || (x >= 128992 && x <= 129003) || (x >= 129280 && x <= 129535)
        || (x >= 129648 && x <= 129651) || (x >= 129656 && x <= 129666) || (x >= 129680 && x <= 129685));
}
// -- UTF-8 BOM
const UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* UTF8_BOM */);
function startsWithUTF8BOM(str) {
    return !!(str && str.length > 0 && str.charCodeAt(0) === 65279 /* UTF8_BOM */);
}
function containsUppercaseCharacter(target, ignoreEscapedChars = false) {
    if (!target) {
        return false;
    }
    if (ignoreEscapedChars) {
        target = target.replace(/\\./g, '');
    }
    return target.toLowerCase() !== target;
}
/**
 * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.
 */
function singleLetterHash(n) {
    const LETTERS_CNT = (90 /* Z */ - 65 /* A */ + 1);
    n = n % (2 * LETTERS_CNT);
    if (n < LETTERS_CNT) {
        return String.fromCharCode(97 /* a */ + n);
    }
    return String.fromCharCode(65 /* A */ + n - LETTERS_CNT);
}
//#region Unicode Grapheme Break
function getGraphemeBreakType(codePoint) {
    const graphemeBreakTree = GraphemeBreakTree.getInstance();
    return graphemeBreakTree.getGraphemeBreakType(codePoint);
}
function breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {
    // http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules
    // !!! Let's make the common case a bit faster
    if (breakTypeA === 0 /* Other */) {
        // see https://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakTest-13.0.0d10.html#table
        return (breakTypeB !== 5 /* Extend */ && breakTypeB !== 7 /* SpacingMark */);
    }
    // Do not break between a CR and LF. Otherwise, break before and after controls.
    // GB3                                        CR × LF
    // GB4                       (Control | CR | LF) ÷
    // GB5                                           ÷ (Control | CR | LF)
    if (breakTypeA === 2 /* CR */) {
        if (breakTypeB === 3 /* LF */) {
            return false; // GB3
        }
    }
    if (breakTypeA === 4 /* Control */ || breakTypeA === 2 /* CR */ || breakTypeA === 3 /* LF */) {
        return true; // GB4
    }
    if (breakTypeB === 4 /* Control */ || breakTypeB === 2 /* CR */ || breakTypeB === 3 /* LF */) {
        return true; // GB5
    }
    // Do not break Hangul syllable sequences.
    // GB6                                         L × (L | V | LV | LVT)
    // GB7                                  (LV | V) × (V | T)
    // GB8                                 (LVT | T) × T
    if (breakTypeA === 8 /* L */) {
        if (breakTypeB === 8 /* L */ || breakTypeB === 9 /* V */ || breakTypeB === 11 /* LV */ || breakTypeB === 12 /* LVT */) {
            return false; // GB6
        }
    }
    if (breakTypeA === 11 /* LV */ || breakTypeA === 9 /* V */) {
        if (breakTypeB === 9 /* V */ || breakTypeB === 10 /* T */) {
            return false; // GB7
        }
    }
    if (breakTypeA === 12 /* LVT */ || breakTypeA === 10 /* T */) {
        if (breakTypeB === 10 /* T */) {
            return false; // GB8
        }
    }
    // Do not break before extending characters or ZWJ.
    // GB9                                           × (Extend | ZWJ)
    if (breakTypeB === 5 /* Extend */ || breakTypeB === 13 /* ZWJ */) {
        return false; // GB9
    }
    // The GB9a and GB9b rules only apply to extended grapheme clusters:
    // Do not break before SpacingMarks, or after Prepend characters.
    // GB9a                                          × SpacingMark
    // GB9b                                  Prepend ×
    if (breakTypeB === 7 /* SpacingMark */) {
        return false; // GB9a
    }
    if (breakTypeA === 1 /* Prepend */) {
        return false; // GB9b
    }
    // Do not break within emoji modifier sequences or emoji zwj sequences.
    // GB11    \p{Extended_Pictographic} Extend* ZWJ × \p{Extended_Pictographic}
    if (breakTypeA === 13 /* ZWJ */ && breakTypeB === 14 /* Extended_Pictographic */) {
        // Note: we are not implementing the rule entirely here to avoid introducing states
        return false; // GB11
    }
    // GB12                          sot (RI RI)* RI × RI
    // GB13                        [^RI] (RI RI)* RI × RI
    if (breakTypeA === 6 /* Regional_Indicator */ && breakTypeB === 6 /* Regional_Indicator */) {
        // Note: we are not implementing the rule entirely here to avoid introducing states
        return false; // GB12 & GB13
    }
    // GB999                                     Any ÷ Any
    return true;
}
class GraphemeBreakTree {
    constructor() {
        this._data = getGraphemeBreakRawData();
    }
    static getInstance() {
        if (!GraphemeBreakTree._INSTANCE) {
            GraphemeBreakTree._INSTANCE = new GraphemeBreakTree();
        }
        return GraphemeBreakTree._INSTANCE;
    }
    getGraphemeBreakType(codePoint) {
        // !!! Let's make 7bit ASCII a bit faster: 0..31
        if (codePoint < 32) {
            if (codePoint === 10 /* LineFeed */) {
                return 3 /* LF */;
            }
            if (codePoint === 13 /* CarriageReturn */) {
                return 2 /* CR */;
            }
            return 4 /* Control */;
        }
        // !!! Let's make 7bit ASCII a bit faster: 32..126
        if (codePoint < 127) {
            return 0 /* Other */;
        }
        const data = this._data;
        const nodeCount = data.length / 3;
        let nodeIndex = 1;
        while (nodeIndex <= nodeCount) {
            if (codePoint < data[3 * nodeIndex]) {
                // go left
                nodeIndex = 2 * nodeIndex;
            }
            else if (codePoint > data[3 * nodeIndex + 1]) {
                // go right
                nodeIndex = 2 * nodeIndex + 1;
            }
            else {
                // hit
                return data[3 * nodeIndex + 2];
            }
        }
        return 0 /* Other */;
    }
}
GraphemeBreakTree._INSTANCE = null;
function getGraphemeBreakRawData() {
    // generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-grapheme-break.js
    return JSON.parse('[0,0,0,51592,51592,11,44424,44424,11,72251,72254,5,7150,7150,7,48008,48008,11,55176,55176,11,128420,128420,14,3276,3277,5,9979,9980,14,46216,46216,11,49800,49800,11,53384,53384,11,70726,70726,5,122915,122916,5,129320,129327,14,2558,2558,5,5906,5908,5,9762,9763,14,43360,43388,8,45320,45320,11,47112,47112,11,48904,48904,11,50696,50696,11,52488,52488,11,54280,54280,11,70082,70083,1,71350,71350,7,73111,73111,5,127892,127893,14,128726,128727,14,129473,129474,14,2027,2035,5,2901,2902,5,3784,3789,5,6754,6754,5,8418,8420,5,9877,9877,14,11088,11088,14,44008,44008,5,44872,44872,11,45768,45768,11,46664,46664,11,47560,47560,11,48456,48456,11,49352,49352,11,50248,50248,11,51144,51144,11,52040,52040,11,52936,52936,11,53832,53832,11,54728,54728,11,69811,69814,5,70459,70460,5,71096,71099,7,71998,71998,5,72874,72880,5,119149,119149,7,127374,127374,14,128335,128335,14,128482,128482,14,128765,128767,14,129399,129400,14,129680,129685,14,1476,1477,5,2377,2380,7,2759,2760,5,3137,3140,7,3458,3459,7,4153,4154,5,6432,6434,5,6978,6978,5,7675,7679,5,9723,9726,14,9823,9823,14,9919,9923,14,10035,10036,14,42736,42737,5,43596,43596,5,44200,44200,11,44648,44648,11,45096,45096,11,45544,45544,11,45992,45992,11,46440,46440,11,46888,46888,11,47336,47336,11,47784,47784,11,48232,48232,11,48680,48680,11,49128,49128,11,49576,49576,11,50024,50024,11,50472,50472,11,50920,50920,11,51368,51368,11,51816,51816,11,52264,52264,11,52712,52712,11,53160,53160,11,53608,53608,11,54056,54056,11,54504,54504,11,54952,54952,11,68108,68111,5,69933,69940,5,70197,70197,7,70498,70499,7,70845,70845,5,71229,71229,5,71727,71735,5,72154,72155,5,72344,72345,5,73023,73029,5,94095,94098,5,121403,121452,5,126981,127182,14,127538,127546,14,127990,127990,14,128391,128391,14,128445,128449,14,128500,128505,14,128752,128752,14,129160,129167,14,129356,129356,14,129432,129442,14,129648,129651,14,129751,131069,14,173,173,4,1757,1757,1,2274,2274,1,2494,2494,5,2641,2641,5,2876,2876,5,3014,3016,7,3262,3262,7,3393,3396,5,3570,3571,7,3968,3972,5,4228,4228,7,6086,6086,5,6679,6680,5,6912,6915,5,7080,7081,5,7380,7392,5,8252,8252,14,9096,9096,14,9748,9749,14,9784,9786,14,9833,9850,14,9890,9894,14,9938,9938,14,9999,9999,14,10085,10087,14,12349,12349,14,43136,43137,7,43454,43456,7,43755,43755,7,44088,44088,11,44312,44312,11,44536,44536,11,44760,44760,11,44984,44984,11,45208,45208,11,45432,45432,11,45656,45656,11,45880,45880,11,46104,46104,11,46328,46328,11,46552,46552,11,46776,46776,11,47000,47000,11,47224,47224,11,47448,47448,11,47672,47672,11,47896,47896,11,48120,48120,11,48344,48344,11,48568,48568,11,48792,48792,11,49016,49016,11,49240,49240,11,49464,49464,11,49688,49688,11,49912,49912,11,50136,50136,11,50360,50360,11,50584,50584,11,50808,50808,11,51032,51032,11,51256,51256,11,51480,51480,11,51704,51704,11,51928,51928,11,52152,52152,11,52376,52376,11,52600,52600,11,52824,52824,11,53048,53048,11,53272,53272,11,53496,53496,11,53720,53720,11,53944,53944,11,54168,54168,11,54392,54392,11,54616,54616,11,54840,54840,11,55064,55064,11,65438,65439,5,69633,69633,5,69837,69837,1,70018,70018,7,70188,70190,7,70368,70370,7,70465,70468,7,70712,70719,5,70835,70840,5,70850,70851,5,71132,71133,5,71340,71340,7,71458,71461,5,71985,71989,7,72002,72002,7,72193,72202,5,72281,72283,5,72766,72766,7,72885,72886,5,73104,73105,5,92912,92916,5,113824,113827,4,119173,119179,5,121505,121519,5,125136,125142,5,127279,127279,14,127489,127490,14,127570,127743,14,127900,127901,14,128254,128254,14,128369,128370,14,128400,128400,14,128425,128432,14,128468,128475,14,128489,128494,14,128715,128720,14,128745,128745,14,128759,128760,14,129004,129023,14,129296,129304,14,129340,129342,14,129388,129392,14,129404,129407,14,129454,129455,14,129485,129487,14,129659,129663,14,129719,129727,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2363,2363,7,2402,2403,5,2507,2508,7,2622,2624,7,2691,2691,7,2786,2787,5,2881,2884,5,3006,3006,5,3072,3072,5,3170,3171,5,3267,3268,7,3330,3331,7,3406,3406,1,3538,3540,5,3655,3662,5,3897,3897,5,4038,4038,5,4184,4185,5,4352,4447,8,6068,6069,5,6155,6157,5,6448,6449,7,6742,6742,5,6783,6783,5,6966,6970,5,7042,7042,7,7143,7143,7,7212,7219,5,7412,7412,5,8206,8207,4,8294,8303,4,8596,8601,14,9410,9410,14,9742,9742,14,9757,9757,14,9770,9770,14,9794,9794,14,9828,9828,14,9855,9855,14,9882,9882,14,9900,9903,14,9929,9933,14,9963,9967,14,9987,9988,14,10006,10006,14,10062,10062,14,10175,10175,14,11744,11775,5,42607,42607,5,43043,43044,7,43263,43263,5,43444,43445,7,43569,43570,5,43698,43700,5,43766,43766,5,44032,44032,11,44144,44144,11,44256,44256,11,44368,44368,11,44480,44480,11,44592,44592,11,44704,44704,11,44816,44816,11,44928,44928,11,45040,45040,11,45152,45152,11,45264,45264,11,45376,45376,11,45488,45488,11,45600,45600,11,45712,45712,11,45824,45824,11,45936,45936,11,46048,46048,11,46160,46160,11,46272,46272,11,46384,46384,11,46496,46496,11,46608,46608,11,46720,46720,11,46832,46832,11,46944,46944,11,47056,47056,11,47168,47168,11,47280,47280,11,47392,47392,11,47504,47504,11,47616,47616,11,47728,47728,11,47840,47840,11,47952,47952,11,48064,48064,11,48176,48176,11,48288,48288,11,48400,48400,11,48512,48512,11,48624,48624,11,48736,48736,11,48848,48848,11,48960,48960,11,49072,49072,11,49184,49184,11,49296,49296,11,49408,49408,11,49520,49520,11,49632,49632,11,49744,49744,11,49856,49856,11,49968,49968,11,50080,50080,11,50192,50192,11,50304,50304,11,50416,50416,11,50528,50528,11,50640,50640,11,50752,50752,11,50864,50864,11,50976,50976,11,51088,51088,11,51200,51200,11,51312,51312,11,51424,51424,11,51536,51536,11,51648,51648,11,51760,51760,11,51872,51872,11,51984,51984,11,52096,52096,11,52208,52208,11,52320,52320,11,52432,52432,11,52544,52544,11,52656,52656,11,52768,52768,11,52880,52880,11,52992,52992,11,53104,53104,11,53216,53216,11,53328,53328,11,53440,53440,11,53552,53552,11,53664,53664,11,53776,53776,11,53888,53888,11,54000,54000,11,54112,54112,11,54224,54224,11,54336,54336,11,54448,54448,11,54560,54560,11,54672,54672,11,54784,54784,11,54896,54896,11,55008,55008,11,55120,55120,11,64286,64286,5,66272,66272,5,68900,68903,5,69762,69762,7,69817,69818,5,69927,69931,5,70003,70003,5,70070,70078,5,70094,70094,7,70194,70195,7,70206,70206,5,70400,70401,5,70463,70463,7,70475,70477,7,70512,70516,5,70722,70724,5,70832,70832,5,70842,70842,5,70847,70848,5,71088,71089,7,71102,71102,7,71219,71226,5,71231,71232,5,71342,71343,7,71453,71455,5,71463,71467,5,71737,71738,5,71995,71996,5,72000,72000,7,72145,72147,7,72160,72160,5,72249,72249,7,72273,72278,5,72330,72342,5,72752,72758,5,72850,72871,5,72882,72883,5,73018,73018,5,73031,73031,5,73109,73109,5,73461,73462,7,94031,94031,5,94192,94193,7,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,126976,126979,14,127184,127231,14,127344,127345,14,127405,127461,14,127514,127514,14,127561,127567,14,127778,127779,14,127896,127896,14,127985,127986,14,127995,127999,5,128326,128328,14,128360,128366,14,128378,128378,14,128394,128397,14,128405,128406,14,128422,128423,14,128435,128443,14,128453,128464,14,128479,128480,14,128484,128487,14,128496,128498,14,128640,128709,14,128723,128724,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129096,129103,14,129292,129292,14,129311,129311,14,129329,129330,14,129344,129349,14,129360,129374,14,129394,129394,14,129402,129402,14,129413,129425,14,129445,129450,14,129466,129471,14,129483,129483,14,129511,129535,14,129653,129655,14,129667,129670,14,129705,129711,14,129731,129743,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2307,2307,7,2366,2368,7,2382,2383,7,2434,2435,7,2497,2500,5,2519,2519,5,2563,2563,7,2631,2632,5,2677,2677,5,2750,2752,7,2763,2764,7,2817,2817,5,2879,2879,5,2891,2892,7,2914,2915,5,3008,3008,5,3021,3021,5,3076,3076,5,3146,3149,5,3202,3203,7,3264,3265,7,3271,3272,7,3298,3299,5,3390,3390,5,3402,3404,7,3426,3427,5,3535,3535,5,3544,3550,7,3635,3635,7,3763,3763,7,3893,3893,5,3953,3966,5,3981,3991,5,4145,4145,7,4157,4158,5,4209,4212,5,4237,4237,5,4520,4607,10,5970,5971,5,6071,6077,5,6089,6099,5,6277,6278,5,6439,6440,5,6451,6456,7,6683,6683,5,6744,6750,5,6765,6770,7,6846,6846,5,6964,6964,5,6972,6972,5,7019,7027,5,7074,7077,5,7083,7085,5,7146,7148,7,7154,7155,7,7222,7223,5,7394,7400,5,7416,7417,5,8204,8204,5,8233,8233,4,8288,8292,4,8413,8416,5,8482,8482,14,8986,8987,14,9193,9203,14,9654,9654,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9775,14,9792,9792,14,9800,9811,14,9825,9826,14,9831,9831,14,9852,9853,14,9872,9873,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9936,9936,14,9941,9960,14,9974,9974,14,9982,9985,14,9992,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10145,10145,14,11013,11015,14,11503,11505,5,12334,12335,5,12951,12951,14,42612,42621,5,43014,43014,5,43047,43047,7,43204,43205,5,43335,43345,5,43395,43395,7,43450,43451,7,43561,43566,5,43573,43574,5,43644,43644,5,43710,43711,5,43758,43759,7,44005,44005,5,44012,44012,7,44060,44060,11,44116,44116,11,44172,44172,11,44228,44228,11,44284,44284,11,44340,44340,11,44396,44396,11,44452,44452,11,44508,44508,11,44564,44564,11,44620,44620,11,44676,44676,11,44732,44732,11,44788,44788,11,44844,44844,11,44900,44900,11,44956,44956,11,45012,45012,11,45068,45068,11,45124,45124,11,45180,45180,11,45236,45236,11,45292,45292,11,45348,45348,11,45404,45404,11,45460,45460,11,45516,45516,11,45572,45572,11,45628,45628,11,45684,45684,11,45740,45740,11,45796,45796,11,45852,45852,11,45908,45908,11,45964,45964,11,46020,46020,11,46076,46076,11,46132,46132,11,46188,46188,11,46244,46244,11,46300,46300,11,46356,46356,11,46412,46412,11,46468,46468,11,46524,46524,11,46580,46580,11,46636,46636,11,46692,46692,11,46748,46748,11,46804,46804,11,46860,46860,11,46916,46916,11,46972,46972,11,47028,47028,11,47084,47084,11,47140,47140,11,47196,47196,11,47252,47252,11,47308,47308,11,47364,47364,11,47420,47420,11,47476,47476,11,47532,47532,11,47588,47588,11,47644,47644,11,47700,47700,11,47756,47756,11,47812,47812,11,47868,47868,11,47924,47924,11,47980,47980,11,48036,48036,11,48092,48092,11,48148,48148,11,48204,48204,11,48260,48260,11,48316,48316,11,48372,48372,11,48428,48428,11,48484,48484,11,48540,48540,11,48596,48596,11,48652,48652,11,48708,48708,11,48764,48764,11,48820,48820,11,48876,48876,11,48932,48932,11,48988,48988,11,49044,49044,11,49100,49100,11,49156,49156,11,49212,49212,11,49268,49268,11,49324,49324,11,49380,49380,11,49436,49436,11,49492,49492,11,49548,49548,11,49604,49604,11,49660,49660,11,49716,49716,11,49772,49772,11,49828,49828,11,49884,49884,11,49940,49940,11,49996,49996,11,50052,50052,11,50108,50108,11,50164,50164,11,50220,50220,11,50276,50276,11,50332,50332,11,50388,50388,11,50444,50444,11,50500,50500,11,50556,50556,11,50612,50612,11,50668,50668,11,50724,50724,11,50780,50780,11,50836,50836,11,50892,50892,11,50948,50948,11,51004,51004,11,51060,51060,11,51116,51116,11,51172,51172,11,51228,51228,11,51284,51284,11,51340,51340,11,51396,51396,11,51452,51452,11,51508,51508,11,51564,51564,11,51620,51620,11,51676,51676,11,51732,51732,11,51788,51788,11,51844,51844,11,51900,51900,11,51956,51956,11,52012,52012,11,52068,52068,11,52124,52124,11,52180,52180,11,52236,52236,11,52292,52292,11,52348,52348,11,52404,52404,11,52460,52460,11,52516,52516,11,52572,52572,11,52628,52628,11,52684,52684,11,52740,52740,11,52796,52796,11,52852,52852,11,52908,52908,11,52964,52964,11,53020,53020,11,53076,53076,11,53132,53132,11,53188,53188,11,53244,53244,11,53300,53300,11,53356,53356,11,53412,53412,11,53468,53468,11,53524,53524,11,53580,53580,11,53636,53636,11,53692,53692,11,53748,53748,11,53804,53804,11,53860,53860,11,53916,53916,11,53972,53972,11,54028,54028,11,54084,54084,11,54140,54140,11,54196,54196,11,54252,54252,11,54308,54308,11,54364,54364,11,54420,54420,11,54476,54476,11,54532,54532,11,54588,54588,11,54644,54644,11,54700,54700,11,54756,54756,11,54812,54812,11,54868,54868,11,54924,54924,11,54980,54980,11,55036,55036,11,55092,55092,11,55148,55148,11,55216,55238,9,65056,65071,5,65529,65531,4,68097,68099,5,68159,68159,5,69446,69456,5,69688,69702,5,69808,69810,7,69815,69816,7,69821,69821,1,69888,69890,5,69932,69932,7,69957,69958,7,70016,70017,5,70067,70069,7,70079,70080,7,70089,70092,5,70095,70095,5,70191,70193,5,70196,70196,5,70198,70199,5,70367,70367,5,70371,70378,5,70402,70403,7,70462,70462,5,70464,70464,5,70471,70472,7,70487,70487,5,70502,70508,5,70709,70711,7,70720,70721,7,70725,70725,7,70750,70750,5,70833,70834,7,70841,70841,7,70843,70844,7,70846,70846,7,70849,70849,7,71087,71087,5,71090,71093,5,71100,71101,5,71103,71104,5,71216,71218,7,71227,71228,7,71230,71230,7,71339,71339,5,71341,71341,5,71344,71349,5,71351,71351,5,71456,71457,7,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123628,123631,5,125252,125258,5,126980,126980,14,127183,127183,14,127245,127247,14,127340,127343,14,127358,127359,14,127377,127386,14,127462,127487,6,127491,127503,14,127535,127535,14,127548,127551,14,127568,127569,14,127744,127777,14,127780,127891,14,127894,127895,14,127897,127899,14,127902,127984,14,127987,127989,14,127991,127994,14,128000,128253,14,128255,128317,14,128329,128334,14,128336,128359,14,128367,128368,14,128371,128377,14,128379,128390,14,128392,128393,14,128398,128399,14,128401,128404,14,128407,128419,14,128421,128421,14,128424,128424,14,128433,128434,14,128444,128444,14,128450,128452,14,128465,128467,14,128476,128478,14,128481,128481,14,128483,128483,14,128488,128488,14,128495,128495,14,128499,128499,14,128506,128591,14,128710,128714,14,128721,128722,14,128725,128725,14,128728,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129664,129666,14,129671,129679,14,129686,129704,14,129712,129718,14,129728,129730,14,129744,129750,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2259,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3134,3136,5,3142,3144,5,3157,3158,5,3201,3201,5,3260,3260,5,3263,3263,5,3266,3266,5,3270,3270,5,3274,3275,7,3285,3286,5,3328,3329,5,3387,3388,5,3391,3392,7,3398,3400,7,3405,3405,5,3415,3415,5,3457,3457,5,3530,3530,5,3536,3537,7,3542,3542,5,3551,3551,5,3633,3633,5,3636,3642,5,3761,3761,5,3764,3772,5,3864,3865,5,3895,3895,5,3902,3903,7,3967,3967,7,3974,3975,5,3993,4028,5,4141,4144,5,4146,4151,5,4155,4156,7,4182,4183,7,4190,4192,5,4226,4226,5,4229,4230,5,4253,4253,5,4448,4519,9,4957,4959,5,5938,5940,5,6002,6003,5,6070,6070,7,6078,6085,7,6087,6088,7,6109,6109,5,6158,6158,4,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6848,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7673,5,8203,8203,4,8205,8205,13,8232,8232,4,8234,8238,4,8265,8265,14,8293,8293,4,8400,8412,5,8417,8417,5,8421,8432,5,8505,8505,14,8617,8618,14,9000,9000,14,9167,9167,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9776,9783,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9935,14,9937,9937,14,9939,9940,14,9961,9962,14,9968,9973,14,9975,9978,14,9981,9981,14,9986,9986,14,9989,9989,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10084,14,10133,10135,14,10160,10160,14,10548,10549,14,11035,11036,14,11093,11093,14,11647,11647,5,12330,12333,5,12336,12336,14,12441,12442,5,12953,12953,14,42608,42610,5,42654,42655,5,43010,43010,5,43019,43019,5,43045,43046,5,43052,43052,5,43188,43203,7,43232,43249,5,43302,43309,5,43346,43347,7,43392,43394,5,43443,43443,5,43446,43449,5,43452,43453,5,43493,43493,5,43567,43568,7,43571,43572,7,43587,43587,5,43597,43597,7,43696,43696,5,43703,43704,5,43713,43713,5,43756,43757,5,43765,43765,7,44003,44004,7,44006,44007,7,44009,44010,7,44013,44013,5,44033,44059,12,44061,44087,12,44089,44115,12,44117,44143,12,44145,44171,12,44173,44199,12,44201,44227,12,44229,44255,12,44257,44283,12,44285,44311,12,44313,44339,12,44341,44367,12,44369,44395,12,44397,44423,12,44425,44451,12,44453,44479,12,44481,44507,12,44509,44535,12,44537,44563,12,44565,44591,12,44593,44619,12,44621,44647,12,44649,44675,12,44677,44703,12,44705,44731,12,44733,44759,12,44761,44787,12,44789,44815,12,44817,44843,12,44845,44871,12,44873,44899,12,44901,44927,12,44929,44955,12,44957,44983,12,44985,45011,12,45013,45039,12,45041,45067,12,45069,45095,12,45097,45123,12,45125,45151,12,45153,45179,12,45181,45207,12,45209,45235,12,45237,45263,12,45265,45291,12,45293,45319,12,45321,45347,12,45349,45375,12,45377,45403,12,45405,45431,12,45433,45459,12,45461,45487,12,45489,45515,12,45517,45543,12,45545,45571,12,45573,45599,12,45601,45627,12,45629,45655,12,45657,45683,12,45685,45711,12,45713,45739,12,45741,45767,12,45769,45795,12,45797,45823,12,45825,45851,12,45853,45879,12,45881,45907,12,45909,45935,12,45937,45963,12,45965,45991,12,45993,46019,12,46021,46047,12,46049,46075,12,46077,46103,12,46105,46131,12,46133,46159,12,46161,46187,12,46189,46215,12,46217,46243,12,46245,46271,12,46273,46299,12,46301,46327,12,46329,46355,12,46357,46383,12,46385,46411,12,46413,46439,12,46441,46467,12,46469,46495,12,46497,46523,12,46525,46551,12,46553,46579,12,46581,46607,12,46609,46635,12,46637,46663,12,46665,46691,12,46693,46719,12,46721,46747,12,46749,46775,12,46777,46803,12,46805,46831,12,46833,46859,12,46861,46887,12,46889,46915,12,46917,46943,12,46945,46971,12,46973,46999,12,47001,47027,12,47029,47055,12,47057,47083,12,47085,47111,12,47113,47139,12,47141,47167,12,47169,47195,12,47197,47223,12,47225,47251,12,47253,47279,12,47281,47307,12,47309,47335,12,47337,47363,12,47365,47391,12,47393,47419,12,47421,47447,12,47449,47475,12,47477,47503,12,47505,47531,12,47533,47559,12,47561,47587,12,47589,47615,12,47617,47643,12,47645,47671,12,47673,47699,12,47701,47727,12,47729,47755,12,47757,47783,12,47785,47811,12,47813,47839,12,47841,47867,12,47869,47895,12,47897,47923,12,47925,47951,12,47953,47979,12,47981,48007,12,48009,48035,12,48037,48063,12,48065,48091,12,48093,48119,12,48121,48147,12,48149,48175,12,48177,48203,12,48205,48231,12,48233,48259,12,48261,48287,12,48289,48315,12,48317,48343,12,48345,48371,12,48373,48399,12,48401,48427,12,48429,48455,12,48457,48483,12,48485,48511,12,48513,48539,12,48541,48567,12,48569,48595,12,48597,48623,12,48625,48651,12,48653,48679,12,48681,48707,12,48709,48735,12,48737,48763,12,48765,48791,12,48793,48819,12,48821,48847,12,48849,48875,12,48877,48903,12,48905,48931,12,48933,48959,12,48961,48987,12,48989,49015,12,49017,49043,12,49045,49071,12,49073,49099,12,49101,49127,12,49129,49155,12,49157,49183,12,49185,49211,12,49213,49239,12,49241,49267,12,49269,49295,12,49297,49323,12,49325,49351,12,49353,49379,12,49381,49407,12,49409,49435,12,49437,49463,12,49465,49491,12,49493,49519,12,49521,49547,12,49549,49575,12,49577,49603,12,49605,49631,12,49633,49659,12,49661,49687,12,49689,49715,12,49717,49743,12,49745,49771,12,49773,49799,12,49801,49827,12,49829,49855,12,49857,49883,12,49885,49911,12,49913,49939,12,49941,49967,12,49969,49995,12,49997,50023,12,50025,50051,12,50053,50079,12,50081,50107,12,50109,50135,12,50137,50163,12,50165,50191,12,50193,50219,12,50221,50247,12,50249,50275,12,50277,50303,12,50305,50331,12,50333,50359,12,50361,50387,12,50389,50415,12,50417,50443,12,50445,50471,12,50473,50499,12,50501,50527,12,50529,50555,12,50557,50583,12,50585,50611,12,50613,50639,12,50641,50667,12,50669,50695,12,50697,50723,12,50725,50751,12,50753,50779,12,50781,50807,12,50809,50835,12,50837,50863,12,50865,50891,12,50893,50919,12,50921,50947,12,50949,50975,12,50977,51003,12,51005,51031,12,51033,51059,12,51061,51087,12,51089,51115,12,51117,51143,12,51145,51171,12,51173,51199,12,51201,51227,12,51229,51255,12,51257,51283,12,51285,51311,12,51313,51339,12,51341,51367,12,51369,51395,12,51397,51423,12,51425,51451,12,51453,51479,12,51481,51507,12,51509,51535,12,51537,51563,12,51565,51591,12,51593,51619,12,51621,51647,12,51649,51675,12,51677,51703,12,51705,51731,12,51733,51759,12,51761,51787,12,51789,51815,12,51817,51843,12,51845,51871,12,51873,51899,12,51901,51927,12,51929,51955,12,51957,51983,12,51985,52011,12,52013,52039,12,52041,52067,12,52069,52095,12,52097,52123,12,52125,52151,12,52153,52179,12,52181,52207,12,52209,52235,12,52237,52263,12,52265,52291,12,52293,52319,12,52321,52347,12,52349,52375,12,52377,52403,12,52405,52431,12,52433,52459,12,52461,52487,12,52489,52515,12,52517,52543,12,52545,52571,12,52573,52599,12,52601,52627,12,52629,52655,12,52657,52683,12,52685,52711,12,52713,52739,12,52741,52767,12,52769,52795,12,52797,52823,12,52825,52851,12,52853,52879,12,52881,52907,12,52909,52935,12,52937,52963,12,52965,52991,12,52993,53019,12,53021,53047,12,53049,53075,12,53077,53103,12,53105,53131,12,53133,53159,12,53161,53187,12,53189,53215,12,53217,53243,12,53245,53271,12,53273,53299,12,53301,53327,12,53329,53355,12,53357,53383,12,53385,53411,12,53413,53439,12,53441,53467,12,53469,53495,12,53497,53523,12,53525,53551,12,53553,53579,12,53581,53607,12,53609,53635,12,53637,53663,12,53665,53691,12,53693,53719,12,53721,53747,12,53749,53775,12,53777,53803,12,53805,53831,12,53833,53859,12,53861,53887,12,53889,53915,12,53917,53943,12,53945,53971,12,53973,53999,12,54001,54027,12,54029,54055,12,54057,54083,12,54085,54111,12,54113,54139,12,54141,54167,12,54169,54195,12,54197,54223,12,54225,54251,12,54253,54279,12,54281,54307,12,54309,54335,12,54337,54363,12,54365,54391,12,54393,54419,12,54421,54447,12,54449,54475,12,54477,54503,12,54505,54531,12,54533,54559,12,54561,54587,12,54589,54615,12,54617,54643,12,54645,54671,12,54673,54699,12,54701,54727,12,54729,54755,12,54757,54783,12,54785,54811,12,54813,54839,12,54841,54867,12,54869,54895,12,54897,54923,12,54925,54951,12,54953,54979,12,54981,55007,12,55009,55035,12,55037,55063,12,55065,55091,12,55093,55119,12,55121,55147,12,55149,55175,12,55177,55203,12,55243,55291,10,65024,65039,5,65279,65279,4,65520,65528,4,66045,66045,5,66422,66426,5,68101,68102,5,68152,68154,5,68325,68326,5,69291,69292,5,69632,69632,7,69634,69634,7,69759,69761,5]');
}
//#endregion


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/types.js":
/*!****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/types.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assertIsDefined": () => (/* binding */ assertIsDefined),
/* harmony export */   "assertType": () => (/* binding */ assertType),
/* harmony export */   "createProxyObject": () => (/* binding */ createProxyObject),
/* harmony export */   "getAllMethodNames": () => (/* binding */ getAllMethodNames),
/* harmony export */   "getAllPropertyNames": () => (/* binding */ getAllPropertyNames),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBoolean": () => (/* binding */ isBoolean),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isUndefined": () => (/* binding */ isUndefined),
/* harmony export */   "isUndefinedOrNull": () => (/* binding */ isUndefinedOrNull),
/* harmony export */   "validateConstraint": () => (/* binding */ validateConstraint),
/* harmony export */   "validateConstraints": () => (/* binding */ validateConstraints),
/* harmony export */   "withNullAsUndefined": () => (/* binding */ withNullAsUndefined)
/* harmony export */ });
/**
 * @returns whether the provided parameter is a JavaScript Array or not.
 */
function isArray(array) {
    return Array.isArray(array);
}
/**
 * @returns whether the provided parameter is a JavaScript String or not.
 */
function isString(str) {
    return (typeof str === 'string');
}
/**
 *
 * @returns whether the provided parameter is of type `object` but **not**
 *	`null`, an `array`, a `regexp`, nor a `date`.
 */
function isObject(obj) {
    // The method can't do a type cast since there are type (like strings) which
    // are subclasses of any put not positvely matched by the function. Hence type
    // narrowing results in wrong results.
    return typeof obj === 'object'
        && obj !== null
        && !Array.isArray(obj)
        && !(obj instanceof RegExp)
        && !(obj instanceof Date);
}
/**
 * In **contrast** to just checking `typeof` this will return `false` for `NaN`.
 * @returns whether the provided parameter is a JavaScript Number or not.
 */
function isNumber(obj) {
    return (typeof obj === 'number' && !isNaN(obj));
}
/**
 * @returns whether the provided parameter is a JavaScript Boolean or not.
 */
function isBoolean(obj) {
    return (obj === true || obj === false);
}
/**
 * @returns whether the provided parameter is undefined.
 */
function isUndefined(obj) {
    return (typeof obj === 'undefined');
}
/**
 * @returns whether the provided parameter is undefined or null.
 */
function isUndefinedOrNull(obj) {
    return (isUndefined(obj) || obj === null);
}
function assertType(condition, type) {
    if (!condition) {
        throw new Error(type ? `Unexpected type, expected '${type}'` : 'Unexpected type');
    }
}
/**
 * Asserts that the argument passed in is neither undefined nor null.
 */
function assertIsDefined(arg) {
    if (isUndefinedOrNull(arg)) {
        throw new Error('Assertion Failed: argument is undefined or null');
    }
    return arg;
}
/**
 * @returns whether the provided parameter is a JavaScript Function or not.
 */
function isFunction(obj) {
    return (typeof obj === 'function');
}
function validateConstraints(args, constraints) {
    const len = Math.min(args.length, constraints.length);
    for (let i = 0; i < len; i++) {
        validateConstraint(args[i], constraints[i]);
    }
}
function validateConstraint(arg, constraint) {
    if (isString(constraint)) {
        if (typeof arg !== constraint) {
            throw new Error(`argument does not match constraint: typeof ${constraint}`);
        }
    }
    else if (isFunction(constraint)) {
        try {
            if (arg instanceof constraint) {
                return;
            }
        }
        catch (_a) {
            // ignore
        }
        if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {
            return;
        }
        if (constraint.length === 1 && constraint.call(undefined, arg) === true) {
            return;
        }
        throw new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);
    }
}
function getAllPropertyNames(obj) {
    let res = [];
    let proto = Object.getPrototypeOf(obj);
    while (Object.prototype !== proto) {
        res = res.concat(Object.getOwnPropertyNames(proto));
        proto = Object.getPrototypeOf(proto);
    }
    return res;
}
function getAllMethodNames(obj) {
    const methods = [];
    for (const prop of getAllPropertyNames(obj)) {
        if (typeof obj[prop] === 'function') {
            methods.push(prop);
        }
    }
    return methods;
}
function createProxyObject(methodNames, invoke) {
    const createProxyMethod = (method) => {
        return function () {
            const args = Array.prototype.slice.call(arguments, 0);
            return invoke(method, args);
        };
    };
    let result = {};
    for (const methodName of methodNames) {
        result[methodName] = createProxyMethod(methodName);
    }
    return result;
}
/**
 * Converts null to undefined, passes all other values through.
 */
function withNullAsUndefined(x) {
    return x === null ? undefined : x;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/uint.js":
/*!***************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/uint.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "toUint32": () => (/* binding */ toUint32),
/* harmony export */   "toUint8": () => (/* binding */ toUint8)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function toUint8(v) {
    if (v < 0) {
        return 0;
    }
    if (v > 255 /* MAX_UINT_8 */) {
        return 255 /* MAX_UINT_8 */;
    }
    return v | 0;
}
function toUint32(v) {
    if (v < 0) {
        return 0;
    }
    if (v > 4294967295 /* MAX_UINT_32 */) {
        return 4294967295 /* MAX_UINT_32 */;
    }
    return v | 0;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/uri.js":
/*!**************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/uri.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "URI": () => (/* binding */ URI),
/* harmony export */   "uriToFsPath": () => (/* binding */ uriToFsPath)
/* harmony export */ });
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform.js */ "./node_modules/monaco-editor/esm/vs/base/common/platform.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path.js */ "./node_modules/monaco-editor/esm/vs/base/common/path.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


const _schemePattern = /^\w[\w\d+.-]*$/;
const _singleSlashStart = /^\//;
const _doubleSlashStart = /^\/\//;
function _validateUri(ret, _strict) {
    // scheme, must be set
    if (!ret.scheme && _strict) {
        throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
    }
    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1
    // ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
    if (ret.scheme && !_schemePattern.test(ret.scheme)) {
        throw new Error('[UriError]: Scheme contains illegal characters.');
    }
    // path, http://tools.ietf.org/html/rfc3986#section-3.3
    // If a URI contains an authority component, then the path component
    // must either be empty or begin with a slash ("/") character.  If a URI
    // does not contain an authority component, then the path cannot begin
    // with two slash characters ("//").
    if (ret.path) {
        if (ret.authority) {
            if (!_singleSlashStart.test(ret.path)) {
                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            }
        }
        else {
            if (_doubleSlashStart.test(ret.path)) {
                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
            }
        }
    }
}
// for a while we allowed uris *without* schemes and this is the migration
// for them, e.g. an uri without scheme and without strict-mode warns and falls
// back to the file-scheme. that should cause the least carnage and still be a
// clear warning
function _schemeFix(scheme, _strict) {
    if (!scheme && !_strict) {
        return 'file';
    }
    return scheme;
}
// implements a bit of https://tools.ietf.org/html/rfc3986#section-5
function _referenceResolution(scheme, path) {
    // the slash-character is our 'default base' as we don't
    // support constructing URIs relative to other URIs. This
    // also means that we alter and potentially break paths.
    // see https://tools.ietf.org/html/rfc3986#section-5.1.4
    switch (scheme) {
        case 'https':
        case 'http':
        case 'file':
            if (!path) {
                path = _slash;
            }
            else if (path[0] !== _slash) {
                path = _slash + path;
            }
            break;
    }
    return path;
}
const _empty = '';
const _slash = '/';
const _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
/**
 * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
 * This class is a simple parser which creates the basic component parts
 * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
 * and encoding.
 *
 * ```txt
 *       foo://example.com:8042/over/there?name=ferret#nose
 *       \_/   \______________/\_________/ \_________/ \__/
 *        |           |            |            |        |
 *     scheme     authority       path        query   fragment
 *        |   _____________________|__
 *       / \ /                        \
 *       urn:example:animal:ferret:nose
 * ```
 */
class URI {
    /**
     * @internal
     */
    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
        if (typeof schemeOrData === 'object') {
            this.scheme = schemeOrData.scheme || _empty;
            this.authority = schemeOrData.authority || _empty;
            this.path = schemeOrData.path || _empty;
            this.query = schemeOrData.query || _empty;
            this.fragment = schemeOrData.fragment || _empty;
            // no validation because it's this URI
            // that creates uri components.
            // _validateUri(this);
        }
        else {
            this.scheme = _schemeFix(schemeOrData, _strict);
            this.authority = authority || _empty;
            this.path = _referenceResolution(this.scheme, path || _empty);
            this.query = query || _empty;
            this.fragment = fragment || _empty;
            _validateUri(this, _strict);
        }
    }
    static isUri(thing) {
        if (thing instanceof URI) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return typeof thing.authority === 'string'
            && typeof thing.fragment === 'string'
            && typeof thing.path === 'string'
            && typeof thing.query === 'string'
            && typeof thing.scheme === 'string'
            && typeof thing.fsPath === 'function'
            && typeof thing.with === 'function'
            && typeof thing.toString === 'function';
    }
    // ---- filesystem path -----------------------
    /**
     * Returns a string representing the corresponding file system path of this URI.
     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
     * platform specific path separator.
     *
     * * Will *not* validate the path for invalid characters and semantics.
     * * Will *not* look at the scheme of this URI.
     * * The result shall *not* be used for display purposes but for accessing a file on disk.
     *
     *
     * The *difference* to `URI#path` is the use of the platform specific separator and the handling
     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
     *
     * ```ts
        const u = URI.parse('file://server/c$/folder/file.txt')
        u.authority === 'server'
        u.path === '/shares/c$/file.txt'
        u.fsPath === '\\server\c$\folder\file.txt'
    ```
     *
     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
     * with URIs that represent files on disk (`file` scheme).
     */
    get fsPath() {
        // if (this.scheme !== 'file') {
        // 	console.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);
        // }
        return uriToFsPath(this, false);
    }
    // ---- modify to new -------------------------
    with(change) {
        if (!change) {
            return this;
        }
        let { scheme, authority, path, query, fragment } = change;
        if (scheme === undefined) {
            scheme = this.scheme;
        }
        else if (scheme === null) {
            scheme = _empty;
        }
        if (authority === undefined) {
            authority = this.authority;
        }
        else if (authority === null) {
            authority = _empty;
        }
        if (path === undefined) {
            path = this.path;
        }
        else if (path === null) {
            path = _empty;
        }
        if (query === undefined) {
            query = this.query;
        }
        else if (query === null) {
            query = _empty;
        }
        if (fragment === undefined) {
            fragment = this.fragment;
        }
        else if (fragment === null) {
            fragment = _empty;
        }
        if (scheme === this.scheme
            && authority === this.authority
            && path === this.path
            && query === this.query
            && fragment === this.fragment) {
            return this;
        }
        return new Uri(scheme, authority, path, query, fragment);
    }
    // ---- parse & validate ------------------------
    /**
     * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,
     * `file:///usr/home`, or `scheme:with/path`.
     *
     * @param value A string which represents an URI (see `URI#toString`).
     */
    static parse(value, _strict = false) {
        const match = _regexp.exec(value);
        if (!match) {
            return new Uri(_empty, _empty, _empty, _empty, _empty);
        }
        return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
    }
    /**
     * Creates a new URI from a file system path, e.g. `c:\my\files`,
     * `/usr/home`, or `\\server\share\some\path`.
     *
     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
     * `URI.parse('file://' + path)` because the path might contain characters that are
     * interpreted (# and ?). See the following sample:
     * ```ts
    const good = URI.file('/coding/c#/project1');
    good.scheme === 'file';
    good.path === '/coding/c#/project1';
    good.fragment === '';
    const bad = URI.parse('file://' + '/coding/c#/project1');
    bad.scheme === 'file';
    bad.path === '/coding/c'; // path is now broken
    bad.fragment === '/project1';
    ```
     *
     * @param path A file system path (see `URI#fsPath`)
     */
    static file(path) {
        let authority = _empty;
        // normalize to fwd-slashes on windows,
        // on other systems bwd-slashes are valid
        // filename character, eg /f\oo/ba\r.txt
        if (_platform_js__WEBPACK_IMPORTED_MODULE_0__.isWindows) {
            path = path.replace(/\\/g, _slash);
        }
        // check for authority as used in UNC shares
        // or use the path as given
        if (path[0] === _slash && path[1] === _slash) {
            const idx = path.indexOf(_slash, 2);
            if (idx === -1) {
                authority = path.substring(2);
                path = _slash;
            }
            else {
                authority = path.substring(2, idx);
                path = path.substring(idx) || _slash;
            }
        }
        return new Uri('file', authority, path, _empty, _empty);
    }
    static from(components) {
        return new Uri(components.scheme, components.authority, components.path, components.query, components.fragment);
    }
    /**
     * Join a URI path with path fragments and normalizes the resulting path.
     *
     * @param uri The input URI.
     * @param pathFragment The path fragment to add to the URI path.
     * @returns The resulting URI.
     */
    static joinPath(uri, ...pathFragment) {
        if (!uri.path) {
            throw new Error(`[UriError]: cannot call joinPaths on URI without path`);
        }
        let newPath;
        if (_platform_js__WEBPACK_IMPORTED_MODULE_0__.isWindows && uri.scheme === 'file') {
            newPath = URI.file(_path_js__WEBPACK_IMPORTED_MODULE_1__.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
        }
        else {
            newPath = _path_js__WEBPACK_IMPORTED_MODULE_1__.posix.join(uri.path, ...pathFragment);
        }
        return uri.with({ path: newPath });
    }
    // ---- printing/externalize ---------------------------
    /**
     * Creates a string representation for this URI. It's guaranteed that calling
     * `URI.parse` with the result of this function creates an URI which is equal
     * to this URI.
     *
     * * The result shall *not* be used for display purposes but for externalization or transport.
     * * The result will be encoded using the percentage encoding and encoding happens mostly
     * ignore the scheme-specific encoding rules.
     *
     * @param skipEncoding Do not encode the result, default is `false`
     */
    toString(skipEncoding = false) {
        return _asFormatted(this, skipEncoding);
    }
    toJSON() {
        return this;
    }
    static revive(data) {
        if (!data) {
            return data;
        }
        else if (data instanceof URI) {
            return data;
        }
        else {
            const result = new Uri(data);
            result._formatted = data.external;
            result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;
            return result;
        }
    }
}
const _pathSepMarker = _platform_js__WEBPACK_IMPORTED_MODULE_0__.isWindows ? 1 : undefined;
// This class exists so that URI is compatibile with vscode.Uri (API).
class Uri extends URI {
    constructor() {
        super(...arguments);
        this._formatted = null;
        this._fsPath = null;
    }
    get fsPath() {
        if (!this._fsPath) {
            this._fsPath = uriToFsPath(this, false);
        }
        return this._fsPath;
    }
    toString(skipEncoding = false) {
        if (!skipEncoding) {
            if (!this._formatted) {
                this._formatted = _asFormatted(this, false);
            }
            return this._formatted;
        }
        else {
            // we don't cache that
            return _asFormatted(this, true);
        }
    }
    toJSON() {
        const res = {
            $mid: 1
        };
        // cached state
        if (this._fsPath) {
            res.fsPath = this._fsPath;
            res._sep = _pathSepMarker;
        }
        if (this._formatted) {
            res.external = this._formatted;
        }
        // uri components
        if (this.path) {
            res.path = this.path;
        }
        if (this.scheme) {
            res.scheme = this.scheme;
        }
        if (this.authority) {
            res.authority = this.authority;
        }
        if (this.query) {
            res.query = this.query;
        }
        if (this.fragment) {
            res.fragment = this.fragment;
        }
        return res;
    }
}
// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2
const encodeTable = {
    [58 /* Colon */]: '%3A',
    [47 /* Slash */]: '%2F',
    [63 /* QuestionMark */]: '%3F',
    [35 /* Hash */]: '%23',
    [91 /* OpenSquareBracket */]: '%5B',
    [93 /* CloseSquareBracket */]: '%5D',
    [64 /* AtSign */]: '%40',
    [33 /* ExclamationMark */]: '%21',
    [36 /* DollarSign */]: '%24',
    [38 /* Ampersand */]: '%26',
    [39 /* SingleQuote */]: '%27',
    [40 /* OpenParen */]: '%28',
    [41 /* CloseParen */]: '%29',
    [42 /* Asterisk */]: '%2A',
    [43 /* Plus */]: '%2B',
    [44 /* Comma */]: '%2C',
    [59 /* Semicolon */]: '%3B',
    [61 /* Equals */]: '%3D',
    [32 /* Space */]: '%20',
};
function encodeURIComponentFast(uriComponent, allowSlash) {
    let res = undefined;
    let nativeEncodePos = -1;
    for (let pos = 0; pos < uriComponent.length; pos++) {
        const code = uriComponent.charCodeAt(pos);
        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3
        if ((code >= 97 /* a */ && code <= 122 /* z */)
            || (code >= 65 /* A */ && code <= 90 /* Z */)
            || (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */)
            || code === 45 /* Dash */
            || code === 46 /* Period */
            || code === 95 /* Underline */
            || code === 126 /* Tilde */
            || (allowSlash && code === 47 /* Slash */)) {
            // check if we are delaying native encode
            if (nativeEncodePos !== -1) {
                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                nativeEncodePos = -1;
            }
            // check if we write into a new string (by default we try to return the param)
            if (res !== undefined) {
                res += uriComponent.charAt(pos);
            }
        }
        else {
            // encoding needed, we need to allocate a new string
            if (res === undefined) {
                res = uriComponent.substr(0, pos);
            }
            // check with default table first
            const escaped = encodeTable[code];
            if (escaped !== undefined) {
                // check if we are delaying native encode
                if (nativeEncodePos !== -1) {
                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                    nativeEncodePos = -1;
                }
                // append escaped variant to result
                res += escaped;
            }
            else if (nativeEncodePos === -1) {
                // use native encode only when needed
                nativeEncodePos = pos;
            }
        }
    }
    if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
    }
    return res !== undefined ? res : uriComponent;
}
function encodeURIComponentMinimal(path) {
    let res = undefined;
    for (let pos = 0; pos < path.length; pos++) {
        const code = path.charCodeAt(pos);
        if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {
            if (res === undefined) {
                res = path.substr(0, pos);
            }
            res += encodeTable[code];
        }
        else {
            if (res !== undefined) {
                res += path[pos];
            }
        }
    }
    return res !== undefined ? res : path;
}
/**
 * Compute `fsPath` for the given uri
 */
function uriToFsPath(uri, keepDriveLetterCasing) {
    let value;
    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {
        // unc path: file://shares/c$/far/boo
        value = `//${uri.authority}${uri.path}`;
    }
    else if (uri.path.charCodeAt(0) === 47 /* Slash */
        && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)
        && uri.path.charCodeAt(2) === 58 /* Colon */) {
        if (!keepDriveLetterCasing) {
            // windows drive letter: file:///c:/far/boo
            value = uri.path[1].toLowerCase() + uri.path.substr(2);
        }
        else {
            value = uri.path.substr(1);
        }
    }
    else {
        // other path
        value = uri.path;
    }
    if (_platform_js__WEBPACK_IMPORTED_MODULE_0__.isWindows) {
        value = value.replace(/\//g, '\\');
    }
    return value;
}
/**
 * Create the external version of a uri
 */
function _asFormatted(uri, skipEncoding) {
    const encoder = !skipEncoding
        ? encodeURIComponentFast
        : encodeURIComponentMinimal;
    let res = '';
    let { scheme, authority, path, query, fragment } = uri;
    if (scheme) {
        res += scheme;
        res += ':';
    }
    if (authority || scheme === 'file') {
        res += _slash;
        res += _slash;
    }
    if (authority) {
        let idx = authority.indexOf('@');
        if (idx !== -1) {
            // <user>@<auth>
            const userinfo = authority.substr(0, idx);
            authority = authority.substr(idx + 1);
            idx = userinfo.indexOf(':');
            if (idx === -1) {
                res += encoder(userinfo, false);
            }
            else {
                // <user>:<pass>@<auth>
                res += encoder(userinfo.substr(0, idx), false);
                res += ':';
                res += encoder(userinfo.substr(idx + 1), false);
            }
            res += '@';
        }
        authority = authority.toLowerCase();
        idx = authority.indexOf(':');
        if (idx === -1) {
            res += encoder(authority, false);
        }
        else {
            // <auth>:<port>
            res += encoder(authority.substr(0, idx), false);
            res += authority.substr(idx);
        }
    }
    if (path) {
        // lower-case windows drive letters in /C:/fff or C:/fff
        if (path.length >= 3 && path.charCodeAt(0) === 47 /* Slash */ && path.charCodeAt(2) === 58 /* Colon */) {
            const code = path.charCodeAt(1);
            if (code >= 65 /* A */ && code <= 90 /* Z */) {
                path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // "/c:".length === 3
            }
        }
        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {
            const code = path.charCodeAt(0);
            if (code >= 65 /* A */ && code <= 90 /* Z */) {
                path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // "/c:".length === 3
            }
        }
        // encode the rest of the path
        res += encoder(path, true);
    }
    if (query) {
        res += '?';
        res += encoder(query, false);
    }
    if (fragment) {
        res += '#';
        res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;
    }
    return res;
}
// --- decode
function decodeURIComponentGraceful(str) {
    try {
        return decodeURIComponent(str);
    }
    catch (_a) {
        if (str.length > 3) {
            return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
        }
        else {
            return str;
        }
    }
}
const _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function percentDecode(str) {
    if (!str.match(_rEncodedAsHex)) {
        return str;
    }
    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js":
/*!******************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SimpleWorkerClient": () => (/* binding */ SimpleWorkerClient),
/* harmony export */   "SimpleWorkerServer": () => (/* binding */ SimpleWorkerServer),
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "logOnceWebWorkerWarning": () => (/* binding */ logOnceWebWorkerWarning)
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform.js */ "./node_modules/monaco-editor/esm/vs/base/common/platform.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../types.js */ "./node_modules/monaco-editor/esm/vs/base/common/types.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




const INITIALIZE = '$initialize';
let webWorkerWarningLogged = false;
function logOnceWebWorkerWarning(err) {
    if (!_platform_js__WEBPACK_IMPORTED_MODULE_2__.isWeb) {
        // running tests
        return;
    }
    if (!webWorkerWarningLogged) {
        webWorkerWarningLogged = true;
        console.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/Microsoft/monaco-editor#faq');
    }
    console.warn(err.message);
}
class SimpleWorkerProtocol {
    constructor(handler) {
        this._workerId = -1;
        this._handler = handler;
        this._lastSentReq = 0;
        this._pendingReplies = Object.create(null);
    }
    setWorkerId(workerId) {
        this._workerId = workerId;
    }
    sendMessage(method, args) {
        let req = String(++this._lastSentReq);
        return new Promise((resolve, reject) => {
            this._pendingReplies[req] = {
                resolve: resolve,
                reject: reject
            };
            this._send({
                vsWorker: this._workerId,
                req: req,
                method: method,
                args: args
            });
        });
    }
    handleMessage(message) {
        if (!message || !message.vsWorker) {
            return;
        }
        if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
            return;
        }
        this._handleMessage(message);
    }
    _handleMessage(msg) {
        if (msg.seq) {
            let replyMessage = msg;
            if (!this._pendingReplies[replyMessage.seq]) {
                console.warn('Got reply to unknown seq');
                return;
            }
            let reply = this._pendingReplies[replyMessage.seq];
            delete this._pendingReplies[replyMessage.seq];
            if (replyMessage.err) {
                let err = replyMessage.err;
                if (replyMessage.err.$isError) {
                    err = new Error();
                    err.name = replyMessage.err.name;
                    err.message = replyMessage.err.message;
                    err.stack = replyMessage.err.stack;
                }
                reply.reject(err);
                return;
            }
            reply.resolve(replyMessage.res);
            return;
        }
        let requestMessage = msg;
        let req = requestMessage.req;
        let result = this._handler.handleMessage(requestMessage.method, requestMessage.args);
        result.then((r) => {
            this._send({
                vsWorker: this._workerId,
                seq: req,
                res: r,
                err: undefined
            });
        }, (e) => {
            if (e.detail instanceof Error) {
                // Loading errors have a detail property that points to the actual error
                e.detail = (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.transformErrorForSerialization)(e.detail);
            }
            this._send({
                vsWorker: this._workerId,
                seq: req,
                res: undefined,
                err: (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.transformErrorForSerialization)(e)
            });
        });
    }
    _send(msg) {
        let transfer = [];
        if (msg.req) {
            const m = msg;
            for (let i = 0; i < m.args.length; i++) {
                if (m.args[i] instanceof ArrayBuffer) {
                    transfer.push(m.args[i]);
                }
            }
        }
        else {
            const m = msg;
            if (m.res instanceof ArrayBuffer) {
                transfer.push(m.res);
            }
        }
        this._handler.sendMessage(msg, transfer);
    }
}
/**
 * Main thread side
 */
class SimpleWorkerClient extends _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.Disposable {
    constructor(workerFactory, moduleId, host) {
        super();
        let lazyProxyReject = null;
        this._worker = this._register(workerFactory.create('vs/base/common/worker/simpleWorker', (msg) => {
            this._protocol.handleMessage(msg);
        }, (err) => {
            // in Firefox, web workers fail lazily :(
            // we will reject the proxy
            if (lazyProxyReject) {
                lazyProxyReject(err);
            }
        }));
        this._protocol = new SimpleWorkerProtocol({
            sendMessage: (msg, transfer) => {
                this._worker.postMessage(msg, transfer);
            },
            handleMessage: (method, args) => {
                if (typeof host[method] !== 'function') {
                    return Promise.reject(new Error('Missing method ' + method + ' on main thread host.'));
                }
                try {
                    return Promise.resolve(host[method].apply(host, args));
                }
                catch (e) {
                    return Promise.reject(e);
                }
            }
        });
        this._protocol.setWorkerId(this._worker.getId());
        // Gather loader configuration
        let loaderConfiguration = null;
        if (typeof self.require !== 'undefined' && typeof self.require.getConfig === 'function') {
            // Get the configuration from the Monaco AMD Loader
            loaderConfiguration = self.require.getConfig();
        }
        else if (typeof self.requirejs !== 'undefined') {
            // Get the configuration from requirejs
            loaderConfiguration = self.requirejs.s.contexts._.config;
        }
        const hostMethods = _types_js__WEBPACK_IMPORTED_MODULE_3__.getAllMethodNames(host);
        // Send initialize message
        this._onModuleLoaded = this._protocol.sendMessage(INITIALIZE, [
            this._worker.getId(),
            JSON.parse(JSON.stringify(loaderConfiguration)),
            moduleId,
            hostMethods,
        ]);
        // Create proxy to loaded code
        const proxyMethodRequest = (method, args) => {
            return this._request(method, args);
        };
        this._lazyProxy = new Promise((resolve, reject) => {
            lazyProxyReject = reject;
            this._onModuleLoaded.then((availableMethods) => {
                resolve(_types_js__WEBPACK_IMPORTED_MODULE_3__.createProxyObject(availableMethods, proxyMethodRequest));
            }, (e) => {
                reject(e);
                this._onError('Worker failed to load ' + moduleId, e);
            });
        });
    }
    getProxyObject() {
        return this._lazyProxy;
    }
    _request(method, args) {
        return new Promise((resolve, reject) => {
            this._onModuleLoaded.then(() => {
                this._protocol.sendMessage(method, args).then(resolve, reject);
            }, reject);
        });
    }
    _onError(message, error) {
        console.error(message);
        console.info(error);
    }
}
/**
 * Worker side
 */
class SimpleWorkerServer {
    constructor(postMessage, requestHandlerFactory) {
        this._requestHandlerFactory = requestHandlerFactory;
        this._requestHandler = null;
        this._protocol = new SimpleWorkerProtocol({
            sendMessage: (msg, transfer) => {
                postMessage(msg, transfer);
            },
            handleMessage: (method, args) => this._handleMessage(method, args)
        });
    }
    onmessage(msg) {
        this._protocol.handleMessage(msg);
    }
    _handleMessage(method, args) {
        if (method === INITIALIZE) {
            return this.initialize(args[0], args[1], args[2], args[3]);
        }
        if (!this._requestHandler || typeof this._requestHandler[method] !== 'function') {
            return Promise.reject(new Error('Missing requestHandler or method: ' + method));
        }
        try {
            return Promise.resolve(this._requestHandler[method].apply(this._requestHandler, args));
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
    initialize(workerId, loaderConfig, moduleId, hostMethods) {
        this._protocol.setWorkerId(workerId);
        const proxyMethodRequest = (method, args) => {
            return this._protocol.sendMessage(method, args);
        };
        const hostProxy = _types_js__WEBPACK_IMPORTED_MODULE_3__.createProxyObject(hostMethods, proxyMethodRequest);
        if (this._requestHandlerFactory) {
            // static request handler
            this._requestHandler = this._requestHandlerFactory(hostProxy);
            return Promise.resolve(_types_js__WEBPACK_IMPORTED_MODULE_3__.getAllMethodNames(this._requestHandler));
        }
        if (loaderConfig) {
            // Remove 'baseUrl', handling it is beyond scope for now
            if (typeof loaderConfig.baseUrl !== 'undefined') {
                delete loaderConfig['baseUrl'];
            }
            if (typeof loaderConfig.paths !== 'undefined') {
                if (typeof loaderConfig.paths.vs !== 'undefined') {
                    delete loaderConfig.paths['vs'];
                }
            }
            // Since this is in a web worker, enable catching errors
            loaderConfig.catchError = true;
            self.require.config(loaderConfig);
        }
        return new Promise((resolve, reject) => {
            // Use the global require to be sure to get the global config
            self.require([moduleId], (module) => {
                this._requestHandler = module.create(hostProxy);
                if (!this._requestHandler) {
                    reject(new Error(`No RequestHandler!`));
                    return;
                }
                resolve(_types_js__WEBPACK_IMPORTED_MODULE_3__.getAllMethodNames(this._requestHandler));
            }, reject);
        });
    }
}
/**
 * Called on the worker side
 */
function create(postMessage) {
    return new SimpleWorkerServer(postMessage, null);
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CharacterClassifier": () => (/* binding */ CharacterClassifier),
/* harmony export */   "CharacterSet": () => (/* binding */ CharacterSet)
/* harmony export */ });
/* harmony import */ var _base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/uint.js */ "./node_modules/monaco-editor/esm/vs/base/common/uint.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * A fast character classifier that uses a compact array for ASCII values.
 */
class CharacterClassifier {
    constructor(_defaultValue) {
        let defaultValue = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)(_defaultValue);
        this._defaultValue = defaultValue;
        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);
        this._map = new Map();
    }
    static _createAsciiMap(defaultValue) {
        let asciiMap = new Uint8Array(256);
        for (let i = 0; i < 256; i++) {
            asciiMap[i] = defaultValue;
        }
        return asciiMap;
    }
    set(charCode, _value) {
        let value = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)(_value);
        if (charCode >= 0 && charCode < 256) {
            this._asciiMap[charCode] = value;
        }
        else {
            this._map.set(charCode, value);
        }
    }
    get(charCode) {
        if (charCode >= 0 && charCode < 256) {
            return this._asciiMap[charCode];
        }
        else {
            return (this._map.get(charCode) || this._defaultValue);
        }
    }
}
class CharacterSet {
    constructor() {
        this._actual = new CharacterClassifier(0 /* False */);
    }
    add(charCode) {
        this._actual.set(charCode, 1 /* True */);
    }
    has(charCode) {
        return (this._actual.get(charCode) === 1 /* True */);
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js":
/*!**************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/position.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Position": () => (/* binding */ Position)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * A position in the editor.
 */
class Position {
    constructor(lineNumber, column) {
        this.lineNumber = lineNumber;
        this.column = column;
    }
    /**
     * Create a new position from this position.
     *
     * @param newLineNumber new line number
     * @param newColumn new column
     */
    with(newLineNumber = this.lineNumber, newColumn = this.column) {
        if (newLineNumber === this.lineNumber && newColumn === this.column) {
            return this;
        }
        else {
            return new Position(newLineNumber, newColumn);
        }
    }
    /**
     * Derive a new position from this position.
     *
     * @param deltaLineNumber line number delta
     * @param deltaColumn column delta
     */
    delta(deltaLineNumber = 0, deltaColumn = 0) {
        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
    }
    /**
     * Test if this position equals other position
     */
    equals(other) {
        return Position.equals(this, other);
    }
    /**
     * Test if position `a` equals position `b`
     */
    static equals(a, b) {
        if (!a && !b) {
            return true;
        }
        return (!!a &&
            !!b &&
            a.lineNumber === b.lineNumber &&
            a.column === b.column);
    }
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be false.
     */
    isBefore(other) {
        return Position.isBefore(this, other);
    }
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be false.
     */
    static isBefore(a, b) {
        if (a.lineNumber < b.lineNumber) {
            return true;
        }
        if (b.lineNumber < a.lineNumber) {
            return false;
        }
        return a.column < b.column;
    }
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be true.
     */
    isBeforeOrEqual(other) {
        return Position.isBeforeOrEqual(this, other);
    }
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be true.
     */
    static isBeforeOrEqual(a, b) {
        if (a.lineNumber < b.lineNumber) {
            return true;
        }
        if (b.lineNumber < a.lineNumber) {
            return false;
        }
        return a.column <= b.column;
    }
    /**
     * A function that compares positions, useful for sorting
     */
    static compare(a, b) {
        let aLineNumber = a.lineNumber | 0;
        let bLineNumber = b.lineNumber | 0;
        if (aLineNumber === bLineNumber) {
            let aColumn = a.column | 0;
            let bColumn = b.column | 0;
            return aColumn - bColumn;
        }
        return aLineNumber - bLineNumber;
    }
    /**
     * Clone this position.
     */
    clone() {
        return new Position(this.lineNumber, this.column);
    }
    /**
     * Convert to a human-readable representation.
     */
    toString() {
        return '(' + this.lineNumber + ',' + this.column + ')';
    }
    // ---
    /**
     * Create a `Position` from an `IPosition`.
     */
    static lift(pos) {
        return new Position(pos.lineNumber, pos.column);
    }
    /**
     * Test if `obj` is an `IPosition`.
     */
    static isIPosition(obj) {
        return (obj
            && (typeof obj.lineNumber === 'number')
            && (typeof obj.column === 'number'));
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js":
/*!***********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/range.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Range": () => (/* binding */ Range)
/* harmony export */ });
/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)
 */
class Range {
    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {
            this.startLineNumber = endLineNumber;
            this.startColumn = endColumn;
            this.endLineNumber = startLineNumber;
            this.endColumn = startColumn;
        }
        else {
            this.startLineNumber = startLineNumber;
            this.startColumn = startColumn;
            this.endLineNumber = endLineNumber;
            this.endColumn = endColumn;
        }
    }
    /**
     * Test if this range is empty.
     */
    isEmpty() {
        return Range.isEmpty(this);
    }
    /**
     * Test if `range` is empty.
     */
    static isEmpty(range) {
        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);
    }
    /**
     * Test if position is in this range. If the position is at the edges, will return true.
     */
    containsPosition(position) {
        return Range.containsPosition(this, position);
    }
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return true.
     */
    static containsPosition(range, position) {
        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
            return false;
        }
        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
            return false;
        }
        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
            return false;
        }
        return true;
    }
    /**
     * Test if range is in this range. If the range is equal to this range, will return true.
     */
    containsRange(range) {
        return Range.containsRange(this, range);
    }
    /**
     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
     */
    static containsRange(range, otherRange) {
        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
            return false;
        }
        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
            return false;
        }
        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
            return false;
        }
        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
            return false;
        }
        return true;
    }
    /**
     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
     */
    strictContainsRange(range) {
        return Range.strictContainsRange(this, range);
    }
    /**
     * Test if `otherRange` is strinctly in `range` (must start after, and end before). If the ranges are equal, will return false.
     */
    static strictContainsRange(range, otherRange) {
        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
            return false;
        }
        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
            return false;
        }
        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {
            return false;
        }
        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {
            return false;
        }
        return true;
    }
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    plusRange(range) {
        return Range.plusRange(this, range);
    }
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    static plusRange(a, b) {
        let startLineNumber;
        let startColumn;
        let endLineNumber;
        let endColumn;
        if (b.startLineNumber < a.startLineNumber) {
            startLineNumber = b.startLineNumber;
            startColumn = b.startColumn;
        }
        else if (b.startLineNumber === a.startLineNumber) {
            startLineNumber = b.startLineNumber;
            startColumn = Math.min(b.startColumn, a.startColumn);
        }
        else {
            startLineNumber = a.startLineNumber;
            startColumn = a.startColumn;
        }
        if (b.endLineNumber > a.endLineNumber) {
            endLineNumber = b.endLineNumber;
            endColumn = b.endColumn;
        }
        else if (b.endLineNumber === a.endLineNumber) {
            endLineNumber = b.endLineNumber;
            endColumn = Math.max(b.endColumn, a.endColumn);
        }
        else {
            endLineNumber = a.endLineNumber;
            endColumn = a.endColumn;
        }
        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
    }
    /**
     * A intersection of the two ranges.
     */
    intersectRanges(range) {
        return Range.intersectRanges(this, range);
    }
    /**
     * A intersection of the two ranges.
     */
    static intersectRanges(a, b) {
        let resultStartLineNumber = a.startLineNumber;
        let resultStartColumn = a.startColumn;
        let resultEndLineNumber = a.endLineNumber;
        let resultEndColumn = a.endColumn;
        let otherStartLineNumber = b.startLineNumber;
        let otherStartColumn = b.startColumn;
        let otherEndLineNumber = b.endLineNumber;
        let otherEndColumn = b.endColumn;
        if (resultStartLineNumber < otherStartLineNumber) {
            resultStartLineNumber = otherStartLineNumber;
            resultStartColumn = otherStartColumn;
        }
        else if (resultStartLineNumber === otherStartLineNumber) {
            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
        }
        if (resultEndLineNumber > otherEndLineNumber) {
            resultEndLineNumber = otherEndLineNumber;
            resultEndColumn = otherEndColumn;
        }
        else if (resultEndLineNumber === otherEndLineNumber) {
            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
        }
        // Check if selection is now empty
        if (resultStartLineNumber > resultEndLineNumber) {
            return null;
        }
        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
            return null;
        }
        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
    }
    /**
     * Test if this range equals other.
     */
    equalsRange(other) {
        return Range.equalsRange(this, other);
    }
    /**
     * Test if range `a` equals `b`.
     */
    static equalsRange(a, b) {
        return (!!a &&
            !!b &&
            a.startLineNumber === b.startLineNumber &&
            a.startColumn === b.startColumn &&
            a.endLineNumber === b.endLineNumber &&
            a.endColumn === b.endColumn);
    }
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    getEndPosition() {
        return Range.getEndPosition(this);
    }
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    static getEndPosition(range) {
        return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(range.endLineNumber, range.endColumn);
    }
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    getStartPosition() {
        return Range.getStartPosition(this);
    }
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    static getStartPosition(range) {
        return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(range.startLineNumber, range.startColumn);
    }
    /**
     * Transform to a user presentable string representation.
     */
    toString() {
        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';
    }
    /**
     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
     */
    setEndPosition(endLineNumber, endColumn) {
        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
    }
    /**
     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
     */
    setStartPosition(startLineNumber, startColumn) {
        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
    }
    /**
     * Create a new empty range using this range's start position.
     */
    collapseToStart() {
        return Range.collapseToStart(this);
    }
    /**
     * Create a new empty range using this range's start position.
     */
    static collapseToStart(range) {
        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
    }
    // ---
    static fromPositions(start, end = start) {
        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);
    }
    static lift(range) {
        if (!range) {
            return null;
        }
        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
    }
    /**
     * Test if `obj` is an `IRange`.
     */
    static isIRange(obj) {
        return (obj
            && (typeof obj.startLineNumber === 'number')
            && (typeof obj.startColumn === 'number')
            && (typeof obj.endLineNumber === 'number')
            && (typeof obj.endColumn === 'number'));
    }
    /**
     * Test if the two ranges are touching in any way.
     */
    static areIntersectingOrTouching(a, b) {
        // Check if `a` is before `b`
        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {
            return false;
        }
        // Check if `b` is before `a`
        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {
            return false;
        }
        // These ranges must intersect
        return true;
    }
    /**
     * Test if the two ranges are intersecting. If the ranges are touching it returns true.
     */
    static areIntersecting(a, b) {
        // Check if `a` is before `b`
        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {
            return false;
        }
        // Check if `b` is before `a`
        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {
            return false;
        }
        // These ranges must intersect
        return true;
    }
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the startPosition and then on the endPosition
     */
    static compareRangesUsingStarts(a, b) {
        if (a && b) {
            const aStartLineNumber = a.startLineNumber | 0;
            const bStartLineNumber = b.startLineNumber | 0;
            if (aStartLineNumber === bStartLineNumber) {
                const aStartColumn = a.startColumn | 0;
                const bStartColumn = b.startColumn | 0;
                if (aStartColumn === bStartColumn) {
                    const aEndLineNumber = a.endLineNumber | 0;
                    const bEndLineNumber = b.endLineNumber | 0;
                    if (aEndLineNumber === bEndLineNumber) {
                        const aEndColumn = a.endColumn | 0;
                        const bEndColumn = b.endColumn | 0;
                        return aEndColumn - bEndColumn;
                    }
                    return aEndLineNumber - bEndLineNumber;
                }
                return aStartColumn - bStartColumn;
            }
            return aStartLineNumber - bStartLineNumber;
        }
        const aExists = (a ? 1 : 0);
        const bExists = (b ? 1 : 0);
        return aExists - bExists;
    }
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the endPosition and then on the startPosition
     */
    static compareRangesUsingEnds(a, b) {
        if (a.endLineNumber === b.endLineNumber) {
            if (a.endColumn === b.endColumn) {
                if (a.startLineNumber === b.startLineNumber) {
                    return a.startColumn - b.startColumn;
                }
                return a.startLineNumber - b.startLineNumber;
            }
            return a.endColumn - b.endColumn;
        }
        return a.endLineNumber - b.endLineNumber;
    }
    /**
     * Test if the range spans multiple lines.
     */
    static spansMultipleLines(range) {
        return range.endLineNumber > range.startLineNumber;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js":
/*!***************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Selection": () => (/* binding */ Selection)
/* harmony export */ });
/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _range_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


/**
 * A selection in the editor.
 * The selection is a range that has an orientation.
 */
class Selection extends _range_js__WEBPACK_IMPORTED_MODULE_1__.Range {
    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
        this.selectionStartLineNumber = selectionStartLineNumber;
        this.selectionStartColumn = selectionStartColumn;
        this.positionLineNumber = positionLineNumber;
        this.positionColumn = positionColumn;
    }
    /**
     * Transform to a human-readable representation.
     */
    toString() {
        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';
    }
    /**
     * Test if equals other selection.
     */
    equalsSelection(other) {
        return (Selection.selectionsEqual(this, other));
    }
    /**
     * Test if the two selections are equal.
     */
    static selectionsEqual(a, b) {
        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&
            a.selectionStartColumn === b.selectionStartColumn &&
            a.positionLineNumber === b.positionLineNumber &&
            a.positionColumn === b.positionColumn);
    }
    /**
     * Get directions (LTR or RTL).
     */
    getDirection() {
        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
            return 0 /* LTR */;
        }
        return 1 /* RTL */;
    }
    /**
     * Create a new selection with a different `positionLineNumber` and `positionColumn`.
     */
    setEndPosition(endLineNumber, endColumn) {
        if (this.getDirection() === 0 /* LTR */) {
            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
        }
        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
    }
    /**
     * Get the position at `positionLineNumber` and `positionColumn`.
     */
    getPosition() {
        return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(this.positionLineNumber, this.positionColumn);
    }
    /**
     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
     */
    setStartPosition(startLineNumber, startColumn) {
        if (this.getDirection() === 0 /* LTR */) {
            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
        }
        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
    }
    // ----
    /**
     * Create a `Selection` from one or two positions
     */
    static fromPositions(start, end = start) {
        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);
    }
    /**
     * Create a `Selection` from an `ISelection`.
     */
    static liftSelection(sel) {
        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
    }
    /**
     * `a` equals `b`.
     */
    static selectionsArrEqual(a, b) {
        if (a && !b || !a && b) {
            return false;
        }
        if (!a && !b) {
            return true;
        }
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0, len = a.length; i < len; i++) {
            if (!this.selectionsEqual(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Test if `obj` is an `ISelection`.
     */
    static isISelection(obj) {
        return (obj
            && (typeof obj.selectionStartLineNumber === 'number')
            && (typeof obj.selectionStartColumn === 'number')
            && (typeof obj.positionLineNumber === 'number')
            && (typeof obj.positionColumn === 'number'));
    }
    /**
     * Create with a direction.
     */
    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {
        if (direction === 0 /* LTR */) {
            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);
        }
        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/token.js":
/*!***********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/token.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Token": () => (/* binding */ Token),
/* harmony export */   "TokenizationResult": () => (/* binding */ TokenizationResult),
/* harmony export */   "TokenizationResult2": () => (/* binding */ TokenizationResult2)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class Token {
    constructor(offset, type, language) {
        this.offset = offset | 0; // @perf
        this.type = type;
        this.language = language;
    }
    toString() {
        return '(' + this.offset + ', ' + this.type + ')';
    }
}
class TokenizationResult {
    constructor(tokens, endState) {
        this.tokens = tokens;
        this.endState = endState;
    }
}
class TokenizationResult2 {
    constructor(tokens, endState) {
        this.tokens = tokens;
        this.endState = endState;
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DiffComputer": () => (/* binding */ DiffComputer)
/* harmony export */ });
/* harmony import */ var _base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/diff/diff.js */ "./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js");
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/strings.js */ "./node_modules/monaco-editor/esm/vs/base/common/strings.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


const MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
    const diffAlgo = new _base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_0__.LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
    return diffAlgo.ComputeDiff(pretty);
}
class LineSequence {
    constructor(lines) {
        const startColumns = [];
        const endColumns = [];
        for (let i = 0, length = lines.length; i < length; i++) {
            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);
            endColumns[i] = getLastNonBlankColumn(lines[i], 1);
        }
        this.lines = lines;
        this._startColumns = startColumns;
        this._endColumns = endColumns;
    }
    getElements() {
        const elements = [];
        for (let i = 0, len = this.lines.length; i < len; i++) {
            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);
        }
        return elements;
    }
    getStartLineNumber(i) {
        return i + 1;
    }
    getEndLineNumber(i) {
        return i + 1;
    }
    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
        const charCodes = [];
        const lineNumbers = [];
        const columns = [];
        let len = 0;
        for (let index = startIndex; index <= endIndex; index++) {
            const lineContent = this.lines[index];
            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);
            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);
            for (let col = startColumn; col < endColumn; col++) {
                charCodes[len] = lineContent.charCodeAt(col - 1);
                lineNumbers[len] = index + 1;
                columns[len] = col;
                len++;
            }
        }
        return new CharSequence(charCodes, lineNumbers, columns);
    }
}
class CharSequence {
    constructor(charCodes, lineNumbers, columns) {
        this._charCodes = charCodes;
        this._lineNumbers = lineNumbers;
        this._columns = columns;
    }
    getElements() {
        return this._charCodes;
    }
    getStartLineNumber(i) {
        return this._lineNumbers[i];
    }
    getStartColumn(i) {
        return this._columns[i];
    }
    getEndLineNumber(i) {
        return this._lineNumbers[i];
    }
    getEndColumn(i) {
        return this._columns[i] + 1;
    }
}
class CharChange {
    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
        this.originalStartLineNumber = originalStartLineNumber;
        this.originalStartColumn = originalStartColumn;
        this.originalEndLineNumber = originalEndLineNumber;
        this.originalEndColumn = originalEndColumn;
        this.modifiedStartLineNumber = modifiedStartLineNumber;
        this.modifiedStartColumn = modifiedStartColumn;
        this.modifiedEndLineNumber = modifiedEndLineNumber;
        this.modifiedEndColumn = modifiedEndColumn;
    }
    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
        let originalStartLineNumber;
        let originalStartColumn;
        let originalEndLineNumber;
        let originalEndColumn;
        let modifiedStartLineNumber;
        let modifiedStartColumn;
        let modifiedEndLineNumber;
        let modifiedEndColumn;
        if (diffChange.originalLength === 0) {
            originalStartLineNumber = 0;
            originalStartColumn = 0;
            originalEndLineNumber = 0;
            originalEndColumn = 0;
        }
        else {
            originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
            originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
            originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
            originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
        }
        if (diffChange.modifiedLength === 0) {
            modifiedStartLineNumber = 0;
            modifiedStartColumn = 0;
            modifiedEndLineNumber = 0;
            modifiedEndColumn = 0;
        }
        else {
            modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
            modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
            modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
            modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
        }
        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
    }
}
function postProcessCharChanges(rawChanges) {
    if (rawChanges.length <= 1) {
        return rawChanges;
    }
    const result = [rawChanges[0]];
    let prevChange = result[0];
    for (let i = 1, len = rawChanges.length; i < len; i++) {
        const currChange = rawChanges[i];
        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true
        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
            // Merge the current change into the previous one
            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;
            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;
        }
        else {
            // Add the current change
            result.push(currChange);
            prevChange = currChange;
        }
    }
    return result;
}
class LineChange {
    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
        this.originalStartLineNumber = originalStartLineNumber;
        this.originalEndLineNumber = originalEndLineNumber;
        this.modifiedStartLineNumber = modifiedStartLineNumber;
        this.modifiedEndLineNumber = modifiedEndLineNumber;
        this.charChanges = charChanges;
    }
    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
        let originalStartLineNumber;
        let originalEndLineNumber;
        let modifiedStartLineNumber;
        let modifiedEndLineNumber;
        let charChanges = undefined;
        if (diffChange.originalLength === 0) {
            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
            originalEndLineNumber = 0;
        }
        else {
            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
        }
        if (diffChange.modifiedLength === 0) {
            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
            modifiedEndLineNumber = 0;
        }
        else {
            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
        }
        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
            // Compute character changes for diff chunks of at most 20 lines...
            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
            let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
            if (shouldPostProcessCharChanges) {
                rawChanges = postProcessCharChanges(rawChanges);
            }
            charChanges = [];
            for (let i = 0, length = rawChanges.length; i < length; i++) {
                charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));
            }
        }
        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
    }
}
class DiffComputer {
    constructor(originalLines, modifiedLines, opts) {
        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
        this.originalLines = originalLines;
        this.modifiedLines = modifiedLines;
        this.original = new LineSequence(originalLines);
        this.modified = new LineSequence(modifiedLines);
        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...
    }
    computeDiff() {
        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
            // empty original => fast path
            return {
                quitEarly: false,
                changes: [{
                        originalStartLineNumber: 1,
                        originalEndLineNumber: 1,
                        modifiedStartLineNumber: 1,
                        modifiedEndLineNumber: this.modified.lines.length,
                        charChanges: [{
                                modifiedEndColumn: 0,
                                modifiedEndLineNumber: 0,
                                modifiedStartColumn: 0,
                                modifiedStartLineNumber: 0,
                                originalEndColumn: 0,
                                originalEndLineNumber: 0,
                                originalStartColumn: 0,
                                originalStartLineNumber: 0
                            }]
                    }]
            };
        }
        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
            // empty modified => fast path
            return {
                quitEarly: false,
                changes: [{
                        originalStartLineNumber: 1,
                        originalEndLineNumber: this.original.lines.length,
                        modifiedStartLineNumber: 1,
                        modifiedEndLineNumber: 1,
                        charChanges: [{
                                modifiedEndColumn: 0,
                                modifiedEndLineNumber: 0,
                                modifiedStartColumn: 0,
                                modifiedStartLineNumber: 0,
                                originalEndColumn: 0,
                                originalEndLineNumber: 0,
                                originalStartColumn: 0,
                                originalStartLineNumber: 0
                            }]
                    }]
            };
        }
        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
        const rawChanges = diffResult.changes;
        const quitEarly = diffResult.quitEarly;
        // The diff is always computed with ignoring trim whitespace
        // This ensures we get the prettiest diff
        if (this.shouldIgnoreTrimWhitespace) {
            const lineChanges = [];
            for (let i = 0, length = rawChanges.length; i < length; i++) {
                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
            }
            return {
                quitEarly: quitEarly,
                changes: lineChanges
            };
        }
        // Need to post-process and introduce changes where the trim whitespace is different
        // Note that we are looping starting at -1 to also cover the lines before the first change
        const result = [];
        let originalLineIndex = 0;
        let modifiedLineIndex = 0;
        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {
            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);
            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);
            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);
            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
                const originalLine = this.originalLines[originalLineIndex];
                const modifiedLine = this.modifiedLines[modifiedLineIndex];
                if (originalLine !== modifiedLine) {
                    // These lines differ only in trim whitespace
                    // Check the leading whitespace
                    {
                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {
                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);
                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
                            if (originalChar !== modifiedChar) {
                                break;
                            }
                            originalStartColumn--;
                            modifiedStartColumn--;
                        }
                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {
                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
                        }
                    }
                    // Check the trailing whitespace
                    {
                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);
                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
                        const originalMaxColumn = originalLine.length + 1;
                        const modifiedMaxColumn = modifiedLine.length + 1;
                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);
                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
                            if (originalChar !== modifiedChar) {
                                break;
                            }
                            originalEndColumn++;
                            modifiedEndColumn++;
                        }
                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
                        }
                    }
                }
                originalLineIndex++;
                modifiedLineIndex++;
            }
            if (nextChange) {
                // Emit the actual change
                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
                originalLineIndex += nextChange.originalLength;
                modifiedLineIndex += nextChange.modifiedLength;
            }
        }
        return {
            quitEarly: quitEarly,
            changes: result
        };
    }
    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
            // Merged into previous
            return;
        }
        let charChanges = undefined;
        if (this.shouldComputeCharChanges) {
            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
        }
        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
    }
    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
        const len = result.length;
        if (len === 0) {
            return false;
        }
        const prevChange = result[len - 1];
        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
            // Don't merge with inserts/deletes
            return false;
        }
        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
            prevChange.originalEndLineNumber = originalLineNumber;
            prevChange.modifiedEndLineNumber = modifiedLineNumber;
            if (this.shouldComputeCharChanges && prevChange.charChanges) {
                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
            }
            return true;
        }
        return false;
    }
}
function getFirstNonBlankColumn(txt, defaultValue) {
    const r = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__.firstNonWhitespaceIndex(txt);
    if (r === -1) {
        return defaultValue;
    }
    return r + 1;
}
function getLastNonBlankColumn(txt, defaultValue) {
    const r = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__.lastNonWhitespaceIndex(txt);
    if (r === -1) {
        return defaultValue;
    }
    return r + 2;
}
function createContinueProcessingPredicate(maximumRuntime) {
    if (maximumRuntime === 0) {
        return () => true;
    }
    const startTime = Date.now();
    return () => {
        return Date.now() - startTime < maximumRuntime;
    };
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MirrorTextModel": () => (/* binding */ MirrorTextModel)
/* harmony export */ });
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _viewModel_prefixSumComputer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../viewModel/prefixSumComputer.js */ "./node_modules/monaco-editor/esm/vs/editor/common/viewModel/prefixSumComputer.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


class MirrorTextModel {
    constructor(uri, lines, eol, versionId) {
        this._uri = uri;
        this._lines = lines;
        this._eol = eol;
        this._versionId = versionId;
        this._lineStarts = null;
        this._cachedTextValue = null;
    }
    dispose() {
        this._lines.length = 0;
    }
    getText() {
        if (this._cachedTextValue === null) {
            this._cachedTextValue = this._lines.join(this._eol);
        }
        return this._cachedTextValue;
    }
    onEvents(e) {
        if (e.eol && e.eol !== this._eol) {
            this._eol = e.eol;
            this._lineStarts = null;
        }
        // Update my lines
        const changes = e.changes;
        for (const change of changes) {
            this._acceptDeleteRange(change.range);
            this._acceptInsertText(new _core_position_js__WEBPACK_IMPORTED_MODULE_0__.Position(change.range.startLineNumber, change.range.startColumn), change.text);
        }
        this._versionId = e.versionId;
        this._cachedTextValue = null;
    }
    _ensureLineStarts() {
        if (!this._lineStarts) {
            const eolLength = this._eol.length;
            const linesLength = this._lines.length;
            const lineStartValues = new Uint32Array(linesLength);
            for (let i = 0; i < linesLength; i++) {
                lineStartValues[i] = this._lines[i].length + eolLength;
            }
            this._lineStarts = new _viewModel_prefixSumComputer_js__WEBPACK_IMPORTED_MODULE_1__.PrefixSumComputer(lineStartValues);
        }
    }
    /**
     * All changes to a line's text go through this method
     */
    _setLineText(lineIndex, newValue) {
        this._lines[lineIndex] = newValue;
        if (this._lineStarts) {
            // update prefix sum
            this._lineStarts.changeValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
        }
    }
    _acceptDeleteRange(range) {
        if (range.startLineNumber === range.endLineNumber) {
            if (range.startColumn === range.endColumn) {
                // Nothing to delete
                return;
            }
            // Delete text on the affected line
            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
                + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
            return;
        }
        // Take remaining text on last line and append it to remaining text on first line
        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
            + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
        // Delete middle lines
        this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
        if (this._lineStarts) {
            // update prefix sum
            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
        }
    }
    _acceptInsertText(position, insertText) {
        if (insertText.length === 0) {
            // Nothing to insert
            return;
        }
        let insertLines = insertText.split(/\r\n|\r|\n/);
        if (insertLines.length === 1) {
            // Inserting text on one line
            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
                + insertLines[0]
                + this._lines[position.lineNumber - 1].substring(position.column - 1));
            return;
        }
        // Append overflowing text from first line to the end of text to insert
        insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
        // Delete overflowing text from first line and insert text on first line
        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
            + insertLines[0]);
        // Insert new lines & store lengths
        let newLengths = new Uint32Array(insertLines.length - 1);
        for (let i = 1; i < insertLines.length; i++) {
            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
            newLengths[i - 1] = insertLines[i].length + this._eol.length;
        }
        if (this._lineStarts) {
            // update prefix sum
            this._lineStarts.insertValues(position.lineNumber, newLengths);
        }
    }
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/wordHelper.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/wordHelper.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_WORD_REGEXP": () => (/* binding */ DEFAULT_WORD_REGEXP),
/* harmony export */   "USUAL_WORD_SEPARATORS": () => (/* binding */ USUAL_WORD_SEPARATORS),
/* harmony export */   "ensureValidWordDefinition": () => (/* binding */ ensureValidWordDefinition),
/* harmony export */   "getWordAtText": () => (/* binding */ getWordAtText)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\|;:\'",.<>/?';
/**
 * Create a word definition regular expression based on default word separators.
 * Optionally provide allowed separators that should be included in words.
 *
 * The default would look like this:
 * /(-?\d*\.\d\w*)|([^\`\~\!\@\#\$\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g
 */
function createWordRegExp(allowInWords = '') {
    let source = '(-?\\d*\\.\\d\\w*)|([^';
    for (const sep of USUAL_WORD_SEPARATORS) {
        if (allowInWords.indexOf(sep) >= 0) {
            continue;
        }
        source += '\\' + sep;
    }
    source += '\\s]+)';
    return new RegExp(source, 'g');
}
// catches numbers (including floating numbers) in the first group, and alphanum in the second
const DEFAULT_WORD_REGEXP = createWordRegExp();
function ensureValidWordDefinition(wordDefinition) {
    let result = DEFAULT_WORD_REGEXP;
    if (wordDefinition && (wordDefinition instanceof RegExp)) {
        if (!wordDefinition.global) {
            let flags = 'g';
            if (wordDefinition.ignoreCase) {
                flags += 'i';
            }
            if (wordDefinition.multiline) {
                flags += 'm';
            }
            if (wordDefinition.unicode) {
                flags += 'u';
            }
            result = new RegExp(wordDefinition.source, flags);
        }
        else {
            result = wordDefinition;
        }
    }
    result.lastIndex = 0;
    return result;
}
const _defaultConfig = {
    maxLen: 1000,
    windowSize: 15,
    timeBudget: 150
};
function getWordAtText(column, wordDefinition, text, textOffset, config = _defaultConfig) {
    if (text.length > config.maxLen) {
        // don't throw strings that long at the regexp
        // but use a sub-string in which a word must occur
        let start = column - config.maxLen / 2;
        if (start < 0) {
            textOffset += column;
            start = 0;
        }
        else {
            textOffset += start;
        }
        text = text.substring(start, column + config.maxLen / 2);
        return getWordAtText(column, wordDefinition, text, textOffset, config);
    }
    const t1 = Date.now();
    const pos = column - 1 - textOffset;
    let prevRegexIndex = -1;
    let match = null;
    for (let i = 1;; i++) {
        // check time budget
        if (Date.now() - t1 >= config.timeBudget) {
            // break;
        }
        // reset the index at which the regexp should start matching, also know where it
        // should stop so that subsequent search don't repeat previous searches
        const regexIndex = pos - config.windowSize * i;
        wordDefinition.lastIndex = Math.max(0, regexIndex);
        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);
        if (!thisMatch && match) {
            // stop: we have something
            break;
        }
        match = thisMatch;
        // stop: searched at start
        if (regexIndex <= 0) {
            break;
        }
        prevRegexIndex = regexIndex;
    }
    if (match) {
        let result = {
            word: match[0],
            startColumn: textOffset + 1 + match.index,
            endColumn: textOffset + 1 + match.index + match[0].length
        };
        wordDefinition.lastIndex = 0;
        return result;
    }
    return null;
}
function _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {
    let match;
    while (match = wordDefinition.exec(text)) {
        const matchIndex = match.index || 0;
        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
            return match;
        }
        else if (stopPos > 0 && matchIndex > stopPos) {
            return null;
        }
    }
    return null;
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/modes/linkComputer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/modes/linkComputer.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkComputer": () => (/* binding */ LinkComputer),
/* harmony export */   "StateMachine": () => (/* binding */ StateMachine),
/* harmony export */   "Uint8Matrix": () => (/* binding */ Uint8Matrix),
/* harmony export */   "computeLinks": () => (/* binding */ computeLinks)
/* harmony export */ });
/* harmony import */ var _core_characterClassifier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/characterClassifier.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

class Uint8Matrix {
    constructor(rows, cols, defaultValue) {
        const data = new Uint8Array(rows * cols);
        for (let i = 0, len = rows * cols; i < len; i++) {
            data[i] = defaultValue;
        }
        this._data = data;
        this.rows = rows;
        this.cols = cols;
    }
    get(row, col) {
        return this._data[row * this.cols + col];
    }
    set(row, col, value) {
        this._data[row * this.cols + col] = value;
    }
}
class StateMachine {
    constructor(edges) {
        let maxCharCode = 0;
        let maxState = 0 /* Invalid */;
        for (let i = 0, len = edges.length; i < len; i++) {
            let [from, chCode, to] = edges[i];
            if (chCode > maxCharCode) {
                maxCharCode = chCode;
            }
            if (from > maxState) {
                maxState = from;
            }
            if (to > maxState) {
                maxState = to;
            }
        }
        maxCharCode++;
        maxState++;
        let states = new Uint8Matrix(maxState, maxCharCode, 0 /* Invalid */);
        for (let i = 0, len = edges.length; i < len; i++) {
            let [from, chCode, to] = edges[i];
            states.set(from, chCode, to);
        }
        this._states = states;
        this._maxCharCode = maxCharCode;
    }
    nextState(currentState, chCode) {
        if (chCode < 0 || chCode >= this._maxCharCode) {
            return 0 /* Invalid */;
        }
        return this._states.get(currentState, chCode);
    }
}
// State machine for http:// or https:// or file://
let _stateMachine = null;
function getStateMachine() {
    if (_stateMachine === null) {
        _stateMachine = new StateMachine([
            [1 /* Start */, 104 /* h */, 2 /* H */],
            [1 /* Start */, 72 /* H */, 2 /* H */],
            [1 /* Start */, 102 /* f */, 6 /* F */],
            [1 /* Start */, 70 /* F */, 6 /* F */],
            [2 /* H */, 116 /* t */, 3 /* HT */],
            [2 /* H */, 84 /* T */, 3 /* HT */],
            [3 /* HT */, 116 /* t */, 4 /* HTT */],
            [3 /* HT */, 84 /* T */, 4 /* HTT */],
            [4 /* HTT */, 112 /* p */, 5 /* HTTP */],
            [4 /* HTT */, 80 /* P */, 5 /* HTTP */],
            [5 /* HTTP */, 115 /* s */, 9 /* BeforeColon */],
            [5 /* HTTP */, 83 /* S */, 9 /* BeforeColon */],
            [5 /* HTTP */, 58 /* Colon */, 10 /* AfterColon */],
            [6 /* F */, 105 /* i */, 7 /* FI */],
            [6 /* F */, 73 /* I */, 7 /* FI */],
            [7 /* FI */, 108 /* l */, 8 /* FIL */],
            [7 /* FI */, 76 /* L */, 8 /* FIL */],
            [8 /* FIL */, 101 /* e */, 9 /* BeforeColon */],
            [8 /* FIL */, 69 /* E */, 9 /* BeforeColon */],
            [9 /* BeforeColon */, 58 /* Colon */, 10 /* AfterColon */],
            [10 /* AfterColon */, 47 /* Slash */, 11 /* AlmostThere */],
            [11 /* AlmostThere */, 47 /* Slash */, 12 /* End */],
        ]);
    }
    return _stateMachine;
}
let _classifier = null;
function getClassifier() {
    if (_classifier === null) {
        _classifier = new _core_characterClassifier_js__WEBPACK_IMPORTED_MODULE_0__.CharacterClassifier(0 /* None */);
        const FORCE_TERMINATION_CHARACTERS = ' \t<>\'\"、。｡､，．：；‘“〈《「『【〔（［｛｢｣｝］）〕】』」》〉”’｀～…';
        for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
            _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* ForceTermination */);
        }
        const CANNOT_END_WITH_CHARACTERS = '.,;';
        for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
            _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CannotEndIn */);
        }
    }
    return _classifier;
}
class LinkComputer {
    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
        // Do not allow to end link in certain characters...
        let lastIncludedCharIndex = linkEndIndex - 1;
        do {
            const chCode = line.charCodeAt(lastIncludedCharIndex);
            const chClass = classifier.get(chCode);
            if (chClass !== 2 /* CannotEndIn */) {
                break;
            }
            lastIncludedCharIndex--;
        } while (lastIncludedCharIndex > linkBeginIndex);
        // Handle links enclosed in parens, square brackets and curlys.
        if (linkBeginIndex > 0) {
            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
            if ((charCodeBeforeLink === 40 /* OpenParen */ && lastCharCodeInLink === 41 /* CloseParen */)
                || (charCodeBeforeLink === 91 /* OpenSquareBracket */ && lastCharCodeInLink === 93 /* CloseSquareBracket */)
                || (charCodeBeforeLink === 123 /* OpenCurlyBrace */ && lastCharCodeInLink === 125 /* CloseCurlyBrace */)) {
                // Do not end in ) if ( is before the link start
                // Do not end in ] if [ is before the link start
                // Do not end in } if { is before the link start
                lastIncludedCharIndex--;
            }
        }
        return {
            range: {
                startLineNumber: lineNumber,
                startColumn: linkBeginIndex + 1,
                endLineNumber: lineNumber,
                endColumn: lastIncludedCharIndex + 2
            },
            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
        };
    }
    static computeLinks(model, stateMachine = getStateMachine()) {
        const classifier = getClassifier();
        let result = [];
        for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
            const line = model.getLineContent(i);
            const len = line.length;
            let j = 0;
            let linkBeginIndex = 0;
            let linkBeginChCode = 0;
            let state = 1 /* Start */;
            let hasOpenParens = false;
            let hasOpenSquareBracket = false;
            let inSquareBrackets = false;
            let hasOpenCurlyBracket = false;
            while (j < len) {
                let resetStateMachine = false;
                const chCode = line.charCodeAt(j);
                if (state === 13 /* Accept */) {
                    let chClass;
                    switch (chCode) {
                        case 40 /* OpenParen */:
                            hasOpenParens = true;
                            chClass = 0 /* None */;
                            break;
                        case 41 /* CloseParen */:
                            chClass = (hasOpenParens ? 0 /* None */ : 1 /* ForceTermination */);
                            break;
                        case 91 /* OpenSquareBracket */:
                            inSquareBrackets = true;
                            hasOpenSquareBracket = true;
                            chClass = 0 /* None */;
                            break;
                        case 93 /* CloseSquareBracket */:
                            inSquareBrackets = false;
                            chClass = (hasOpenSquareBracket ? 0 /* None */ : 1 /* ForceTermination */);
                            break;
                        case 123 /* OpenCurlyBrace */:
                            hasOpenCurlyBracket = true;
                            chClass = 0 /* None */;
                            break;
                        case 125 /* CloseCurlyBrace */:
                            chClass = (hasOpenCurlyBracket ? 0 /* None */ : 1 /* ForceTermination */);
                            break;
                        /* The following three rules make it that ' or " or ` are allowed inside links if the link began with a different one */
                        case 39 /* SingleQuote */:
                            chClass = (linkBeginChCode === 34 /* DoubleQuote */ || linkBeginChCode === 96 /* BackTick */) ? 0 /* None */ : 1 /* ForceTermination */;
                            break;
                        case 34 /* DoubleQuote */:
                            chClass = (linkBeginChCode === 39 /* SingleQuote */ || linkBeginChCode === 96 /* BackTick */) ? 0 /* None */ : 1 /* ForceTermination */;
                            break;
                        case 96 /* BackTick */:
                            chClass = (linkBeginChCode === 39 /* SingleQuote */ || linkBeginChCode === 34 /* DoubleQuote */) ? 0 /* None */ : 1 /* ForceTermination */;
                            break;
                        case 42 /* Asterisk */:
                            // `*` terminates a link if the link began with `*`
                            chClass = (linkBeginChCode === 42 /* Asterisk */) ? 1 /* ForceTermination */ : 0 /* None */;
                            break;
                        case 124 /* Pipe */:
                            // `|` terminates a link if the link began with `|`
                            chClass = (linkBeginChCode === 124 /* Pipe */) ? 1 /* ForceTermination */ : 0 /* None */;
                            break;
                        case 32 /* Space */:
                            // ` ` allow space in between [ and ]
                            chClass = (inSquareBrackets ? 0 /* None */ : 1 /* ForceTermination */);
                            break;
                        default:
                            chClass = classifier.get(chCode);
                    }
                    // Check if character terminates link
                    if (chClass === 1 /* ForceTermination */) {
                        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));
                        resetStateMachine = true;
                    }
                }
                else if (state === 12 /* End */) {
                    let chClass;
                    if (chCode === 91 /* OpenSquareBracket */) {
                        // Allow for the authority part to contain ipv6 addresses which contain [ and ]
                        hasOpenSquareBracket = true;
                        chClass = 0 /* None */;
                    }
                    else {
                        chClass = classifier.get(chCode);
                    }
                    // Check if character terminates link
                    if (chClass === 1 /* ForceTermination */) {
                        resetStateMachine = true;
                    }
                    else {
                        state = 13 /* Accept */;
                    }
                }
                else {
                    state = stateMachine.nextState(state, chCode);
                    if (state === 0 /* Invalid */) {
                        resetStateMachine = true;
                    }
                }
                if (resetStateMachine) {
                    state = 1 /* Start */;
                    hasOpenParens = false;
                    hasOpenSquareBracket = false;
                    hasOpenCurlyBracket = false;
                    // Record where the link started
                    linkBeginIndex = j + 1;
                    linkBeginChCode = chCode;
                }
                j++;
            }
            if (state === 13 /* Accept */) {
                result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));
            }
        }
        return result;
    }
}
/**
 * Returns an array of all links contains in the provided
 * document. *Note* that this operation is computational
 * expensive and should not run in the UI thread.
 */
function computeLinks(model) {
    if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {
        // Unknown caller!
        return [];
    }
    return LinkComputer.computeLinks(model);
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/modes/supports/inplaceReplaceSupport.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/modes/supports/inplaceReplaceSupport.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BasicInplaceReplace": () => (/* binding */ BasicInplaceReplace)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class BasicInplaceReplace {
    constructor() {
        this._defaultValueSet = [
            ['true', 'false'],
            ['True', 'False'],
            ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],
            ['public', 'protected', 'private'],
        ];
    }
    navigateValueSet(range1, text1, range2, text2, up) {
        if (range1 && text1) {
            let result = this.doNavigateValueSet(text1, up);
            if (result) {
                return {
                    range: range1,
                    value: result
                };
            }
        }
        if (range2 && text2) {
            let result = this.doNavigateValueSet(text2, up);
            if (result) {
                return {
                    range: range2,
                    value: result
                };
            }
        }
        return null;
    }
    doNavigateValueSet(text, up) {
        let numberResult = this.numberReplace(text, up);
        if (numberResult !== null) {
            return numberResult;
        }
        return this.textReplace(text, up);
    }
    numberReplace(value, up) {
        let precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));
        let n1 = Number(value);
        let n2 = parseFloat(value);
        if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
            if (n1 === 0 && !up) {
                return null; // don't do negative
                //			} else if(n1 === 9 && up) {
                //				return null; // don't insert 10 into a number
            }
            else {
                n1 = Math.floor(n1 * precision);
                n1 += up ? precision : -precision;
                return String(n1 / precision);
            }
        }
        return null;
    }
    textReplace(value, up) {
        return this.valueSetsReplace(this._defaultValueSet, value, up);
    }
    valueSetsReplace(valueSets, value, up) {
        let result = null;
        for (let i = 0, len = valueSets.length; result === null && i < len; i++) {
            result = this.valueSetReplace(valueSets[i], value, up);
        }
        return result;
    }
    valueSetReplace(valueSet, value, up) {
        let idx = valueSet.indexOf(value);
        if (idx >= 0) {
            idx += up ? +1 : -1;
            if (idx < 0) {
                idx = valueSet.length - 1;
            }
            else {
                idx %= valueSet.length;
            }
            return valueSet[idx];
        }
        return null;
    }
}
BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EditorSimpleWorker": () => (/* binding */ EditorSimpleWorker),
/* harmony export */   "create": () => (/* binding */ create)
/* harmony export */ });
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/arrays.js */ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js");
/* harmony import */ var _base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/diff/diff.js */ "./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js");
/* harmony import */ var _base_common_platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/platform.js */ "./node_modules/monaco-editor/esm/vs/base/common/platform.js");
/* harmony import */ var _base_common_uri_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/uri.js */ "./node_modules/monaco-editor/esm/vs/base/common/uri.js");
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _diff_diffComputer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../diff/diffComputer.js */ "./node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js");
/* harmony import */ var _model_mirrorTextModel_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../model/mirrorTextModel.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js");
/* harmony import */ var _model_wordHelper_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../model/wordHelper.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/wordHelper.js");
/* harmony import */ var _modes_linkComputer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../modes/linkComputer.js */ "./node_modules/monaco-editor/esm/vs/editor/common/modes/linkComputer.js");
/* harmony import */ var _modes_supports_inplaceReplaceSupport_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../modes/supports/inplaceReplaceSupport.js */ "./node_modules/monaco-editor/esm/vs/editor/common/modes/supports/inplaceReplaceSupport.js");
/* harmony import */ var _standalone_standaloneBase_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../standalone/standaloneBase.js */ "./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneBase.js");
/* harmony import */ var _base_common_types_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../base/common/types.js */ "./node_modules/monaco-editor/esm/vs/base/common/types.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};













/**
 * @internal
 */
class MirrorModel extends _model_mirrorTextModel_js__WEBPACK_IMPORTED_MODULE_7__.MirrorTextModel {
    get uri() {
        return this._uri;
    }
    get version() {
        return this._versionId;
    }
    get eol() {
        return this._eol;
    }
    getValue() {
        return this.getText();
    }
    getLinesContent() {
        return this._lines.slice(0);
    }
    getLineCount() {
        return this._lines.length;
    }
    getLineContent(lineNumber) {
        return this._lines[lineNumber - 1];
    }
    getWordAtPosition(position, wordDefinition) {
        let wordAtText = (0,_model_wordHelper_js__WEBPACK_IMPORTED_MODULE_8__.getWordAtText)(position.column, (0,_model_wordHelper_js__WEBPACK_IMPORTED_MODULE_8__.ensureValidWordDefinition)(wordDefinition), this._lines[position.lineNumber - 1], 0);
        if (wordAtText) {
            return new _core_range_js__WEBPACK_IMPORTED_MODULE_5__.Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);
        }
        return null;
    }
    words(wordDefinition) {
        const lines = this._lines;
        const wordenize = this._wordenize.bind(this);
        let lineNumber = 0;
        let lineText = '';
        let wordRangesIdx = 0;
        let wordRanges = [];
        return {
            *[Symbol.iterator]() {
                while (true) {
                    if (wordRangesIdx < wordRanges.length) {
                        const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);
                        wordRangesIdx += 1;
                        yield value;
                    }
                    else {
                        if (lineNumber < lines.length) {
                            lineText = lines[lineNumber];
                            wordRanges = wordenize(lineText, wordDefinition);
                            wordRangesIdx = 0;
                            lineNumber += 1;
                        }
                        else {
                            break;
                        }
                    }
                }
            }
        };
    }
    getLineWords(lineNumber, wordDefinition) {
        let content = this._lines[lineNumber - 1];
        let ranges = this._wordenize(content, wordDefinition);
        let words = [];
        for (const range of ranges) {
            words.push({
                word: content.substring(range.start, range.end),
                startColumn: range.start + 1,
                endColumn: range.end + 1
            });
        }
        return words;
    }
    _wordenize(content, wordDefinition) {
        const result = [];
        let match;
        wordDefinition.lastIndex = 0; // reset lastIndex just to be sure
        while (match = wordDefinition.exec(content)) {
            if (match[0].length === 0) {
                // it did match the empty string
                break;
            }
            result.push({ start: match.index, end: match.index + match[0].length });
        }
        return result;
    }
    getValueInRange(range) {
        range = this._validateRange(range);
        if (range.startLineNumber === range.endLineNumber) {
            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);
        }
        let lineEnding = this._eol;
        let startLineIndex = range.startLineNumber - 1;
        let endLineIndex = range.endLineNumber - 1;
        let resultLines = [];
        resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));
        for (let i = startLineIndex + 1; i < endLineIndex; i++) {
            resultLines.push(this._lines[i]);
        }
        resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));
        return resultLines.join(lineEnding);
    }
    offsetAt(position) {
        position = this._validatePosition(position);
        this._ensureLineStarts();
        return this._lineStarts.getAccumulatedValue(position.lineNumber - 2) + (position.column - 1);
    }
    positionAt(offset) {
        offset = Math.floor(offset);
        offset = Math.max(0, offset);
        this._ensureLineStarts();
        let out = this._lineStarts.getIndexOf(offset);
        let lineLength = this._lines[out.index].length;
        // Ensure we return a valid position
        return {
            lineNumber: 1 + out.index,
            column: 1 + Math.min(out.remainder, lineLength)
        };
    }
    _validateRange(range) {
        const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });
        const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });
        if (start.lineNumber !== range.startLineNumber
            || start.column !== range.startColumn
            || end.lineNumber !== range.endLineNumber
            || end.column !== range.endColumn) {
            return {
                startLineNumber: start.lineNumber,
                startColumn: start.column,
                endLineNumber: end.lineNumber,
                endColumn: end.column
            };
        }
        return range;
    }
    _validatePosition(position) {
        if (!_core_position_js__WEBPACK_IMPORTED_MODULE_4__.Position.isIPosition(position)) {
            throw new Error('bad position');
        }
        let { lineNumber, column } = position;
        let hasChanged = false;
        if (lineNumber < 1) {
            lineNumber = 1;
            column = 1;
            hasChanged = true;
        }
        else if (lineNumber > this._lines.length) {
            lineNumber = this._lines.length;
            column = this._lines[lineNumber - 1].length + 1;
            hasChanged = true;
        }
        else {
            let maxCharacter = this._lines[lineNumber - 1].length + 1;
            if (column < 1) {
                column = 1;
                hasChanged = true;
            }
            else if (column > maxCharacter) {
                column = maxCharacter;
                hasChanged = true;
            }
        }
        if (!hasChanged) {
            return position;
        }
        else {
            return { lineNumber, column };
        }
    }
}
/**
 * @internal
 */
class EditorSimpleWorker {
    constructor(host, foreignModuleFactory) {
        this._host = host;
        this._models = Object.create(null);
        this._foreignModuleFactory = foreignModuleFactory;
        this._foreignModule = null;
    }
    dispose() {
        this._models = Object.create(null);
    }
    _getModel(uri) {
        return this._models[uri];
    }
    _getModels() {
        let all = [];
        Object.keys(this._models).forEach((key) => all.push(this._models[key]));
        return all;
    }
    acceptNewModel(data) {
        this._models[data.url] = new MirrorModel(_base_common_uri_js__WEBPACK_IMPORTED_MODULE_3__.URI.parse(data.url), data.lines, data.EOL, data.versionId);
    }
    acceptModelChanged(strURL, e) {
        if (!this._models[strURL]) {
            return;
        }
        let model = this._models[strURL];
        model.onEvents(e);
    }
    acceptRemovedModel(strURL) {
        if (!this._models[strURL]) {
            return;
        }
        delete this._models[strURL];
    }
    // ---- BEGIN diff --------------------------------------------------------------------------
    computeDiff(originalUrl, modifiedUrl, ignoreTrimWhitespace, maxComputationTime) {
        return __awaiter(this, void 0, void 0, function* () {
            const original = this._getModel(originalUrl);
            const modified = this._getModel(modifiedUrl);
            if (!original || !modified) {
                return null;
            }
            const originalLines = original.getLinesContent();
            const modifiedLines = modified.getLinesContent();
            const diffComputer = new _diff_diffComputer_js__WEBPACK_IMPORTED_MODULE_6__.DiffComputer(originalLines, modifiedLines, {
                shouldComputeCharChanges: true,
                shouldPostProcessCharChanges: true,
                shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,
                shouldMakePrettyDiff: true,
                maxComputationTime: maxComputationTime
            });
            const diffResult = diffComputer.computeDiff();
            const identical = (diffResult.changes.length > 0 ? false : this._modelsAreIdentical(original, modified));
            return {
                quitEarly: diffResult.quitEarly,
                identical: identical,
                changes: diffResult.changes
            };
        });
    }
    _modelsAreIdentical(original, modified) {
        const originalLineCount = original.getLineCount();
        const modifiedLineCount = modified.getLineCount();
        if (originalLineCount !== modifiedLineCount) {
            return false;
        }
        for (let line = 1; line <= originalLineCount; line++) {
            const originalLine = original.getLineContent(line);
            const modifiedLine = modified.getLineContent(line);
            if (originalLine !== modifiedLine) {
                return false;
            }
        }
        return true;
    }
    computeMoreMinimalEdits(modelUrl, edits) {
        return __awaiter(this, void 0, void 0, function* () {
            const model = this._getModel(modelUrl);
            if (!model) {
                return edits;
            }
            const result = [];
            let lastEol = undefined;
            edits = (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.mergeSort)(edits, (a, b) => {
                if (a.range && b.range) {
                    return _core_range_js__WEBPACK_IMPORTED_MODULE_5__.Range.compareRangesUsingStarts(a.range, b.range);
                }
                // eol only changes should go to the end
                let aRng = a.range ? 0 : 1;
                let bRng = b.range ? 0 : 1;
                return aRng - bRng;
            });
            for (let { range, text, eol } of edits) {
                if (typeof eol === 'number') {
                    lastEol = eol;
                }
                if (_core_range_js__WEBPACK_IMPORTED_MODULE_5__.Range.isEmpty(range) && !text) {
                    // empty change
                    continue;
                }
                const original = model.getValueInRange(range);
                text = text.replace(/\r\n|\n|\r/g, model.eol);
                if (original === text) {
                    // noop
                    continue;
                }
                // make sure diff won't take too long
                if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {
                    result.push({ range, text });
                    continue;
                }
                // compute diff between original and edit.text
                const changes = (0,_base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_1__.stringDiff)(original, text, false);
                const editOffset = model.offsetAt(_core_range_js__WEBPACK_IMPORTED_MODULE_5__.Range.lift(range).getStartPosition());
                for (const change of changes) {
                    const start = model.positionAt(editOffset + change.originalStart);
                    const end = model.positionAt(editOffset + change.originalStart + change.originalLength);
                    const newEdit = {
                        text: text.substr(change.modifiedStart, change.modifiedLength),
                        range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
                    };
                    if (model.getValueInRange(newEdit.range) !== newEdit.text) {
                        result.push(newEdit);
                    }
                }
            }
            if (typeof lastEol === 'number') {
                result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
            }
            return result;
        });
    }
    // ---- END minimal edits ---------------------------------------------------------------
    computeLinks(modelUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            let model = this._getModel(modelUrl);
            if (!model) {
                return null;
            }
            return (0,_modes_linkComputer_js__WEBPACK_IMPORTED_MODULE_9__.computeLinks)(model);
        });
    }
    textualSuggest(modelUrl, position, wordDef, wordDefFlags) {
        return __awaiter(this, void 0, void 0, function* () {
            const model = this._getModel(modelUrl);
            if (!model) {
                return null;
            }
            const words = [];
            const seen = new Set();
            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
            const wordAt = model.getWordAtPosition(position, wordDefRegExp);
            if (wordAt) {
                seen.add(model.getValueInRange(wordAt));
            }
            for (let word of model.words(wordDefRegExp)) {
                if (seen.has(word)) {
                    continue;
                }
                seen.add(word);
                if (!isNaN(Number(word))) {
                    continue;
                }
                words.push(word);
                if (seen.size > EditorSimpleWorker._suggestionsLimit) {
                    break;
                }
            }
            return words;
        });
    }
    // ---- END suggest --------------------------------------------------------------------------
    //#region -- word ranges --
    computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {
        return __awaiter(this, void 0, void 0, function* () {
            let model = this._getModel(modelUrl);
            if (!model) {
                return Object.create(null);
            }
            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
            const result = Object.create(null);
            for (let line = range.startLineNumber; line < range.endLineNumber; line++) {
                let words = model.getLineWords(line, wordDefRegExp);
                for (const word of words) {
                    if (!isNaN(Number(word.word))) {
                        continue;
                    }
                    let array = result[word.word];
                    if (!array) {
                        array = [];
                        result[word.word] = array;
                    }
                    array.push({
                        startLineNumber: line,
                        startColumn: word.startColumn,
                        endLineNumber: line,
                        endColumn: word.endColumn
                    });
                }
            }
            return result;
        });
    }
    //#endregion
    navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {
        return __awaiter(this, void 0, void 0, function* () {
            let model = this._getModel(modelUrl);
            if (!model) {
                return null;
            }
            let wordDefRegExp = new RegExp(wordDef, wordDefFlags);
            if (range.startColumn === range.endColumn) {
                range = {
                    startLineNumber: range.startLineNumber,
                    startColumn: range.startColumn,
                    endLineNumber: range.endLineNumber,
                    endColumn: range.endColumn + 1
                };
            }
            let selectionText = model.getValueInRange(range);
            let wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);
            if (!wordRange) {
                return null;
            }
            let word = model.getValueInRange(wordRange);
            let result = _modes_supports_inplaceReplaceSupport_js__WEBPACK_IMPORTED_MODULE_10__.BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);
            return result;
        });
    }
    // ---- BEGIN foreign module support --------------------------------------------------------------------------
    loadForeignModule(moduleId, createData, foreignHostMethods) {
        const proxyMethodRequest = (method, args) => {
            return this._host.fhr(method, args);
        };
        const foreignHost = _base_common_types_js__WEBPACK_IMPORTED_MODULE_12__.createProxyObject(foreignHostMethods, proxyMethodRequest);
        let ctx = {
            host: foreignHost,
            getMirrorModels: () => {
                return this._getModels();
            }
        };
        if (this._foreignModuleFactory) {
            this._foreignModule = this._foreignModuleFactory(ctx, createData);
            // static foreing module
            return Promise.resolve(_base_common_types_js__WEBPACK_IMPORTED_MODULE_12__.getAllMethodNames(this._foreignModule));
        }
        // ESM-comment-begin
        // 		return new Promise<any>((resolve, reject) => {
        // 			require([moduleId], (foreignModule: { create: IForeignModuleFactory }) => {
        // 				this._foreignModule = foreignModule.create(ctx, createData);
        // 
        // 				resolve(types.getAllMethodNames(this._foreignModule));
        // 
        // 			}, reject);
        // 		});
        // ESM-comment-end
        // ESM-uncomment-begin
        return Promise.reject(new Error(`Unexpected usage`));
        // ESM-uncomment-end
    }
    // foreign method request
    fmr(method, args) {
        if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {
            return Promise.reject(new Error('Missing requestHandler or method: ' + method));
        }
        try {
            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
}
// ---- END diff --------------------------------------------------------------------------
// ---- BEGIN minimal edits ---------------------------------------------------------------
EditorSimpleWorker._diffLimit = 100000;
// ---- BEGIN suggest --------------------------------------------------------------------------
EditorSimpleWorker._suggestionsLimit = 10000;
/**
 * Called on the worker side
 * @internal
 */
function create(host) {
    return new EditorSimpleWorker(host, null);
}
if (typeof importScripts === 'function') {
    // Running in a web worker
    _base_common_platform_js__WEBPACK_IMPORTED_MODULE_2__.globals.monaco = (0,_standalone_standaloneBase_js__WEBPACK_IMPORTED_MODULE_11__.createMonacoBaseAPI)();
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneBase.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneBase.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KeyMod": () => (/* binding */ KeyMod),
/* harmony export */   "createMonacoBaseAPI": () => (/* binding */ createMonacoBaseAPI)
/* harmony export */ });
/* harmony import */ var _base_common_cancellation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/cancellation.js */ "./node_modules/monaco-editor/esm/vs/base/common/cancellation.js");
/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/event.js */ "./node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _base_common_keyCodes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/keyCodes.js */ "./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js");
/* harmony import */ var _base_common_uri_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/uri.js */ "./node_modules/monaco-editor/esm/vs/base/common/uri.js");
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/position.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _core_selection_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/selection.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js");
/* harmony import */ var _core_token_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/token.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/token.js");
/* harmony import */ var _standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./standaloneEnums.js */ "./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









class KeyMod {
    static chord(firstPart, secondPart) {
        return (0,_base_common_keyCodes_js__WEBPACK_IMPORTED_MODULE_2__.KeyChord)(firstPart, secondPart);
    }
}
KeyMod.CtrlCmd = 2048 /* CtrlCmd */;
KeyMod.Shift = 1024 /* Shift */;
KeyMod.Alt = 512 /* Alt */;
KeyMod.WinCtrl = 256 /* WinCtrl */;
function createMonacoBaseAPI() {
    return {
        editor: undefined,
        languages: undefined,
        CancellationTokenSource: _base_common_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationTokenSource,
        Emitter: _base_common_event_js__WEBPACK_IMPORTED_MODULE_1__.Emitter,
        KeyCode: _standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__.KeyCode,
        KeyMod: KeyMod,
        Position: _core_position_js__WEBPACK_IMPORTED_MODULE_4__.Position,
        Range: _core_range_js__WEBPACK_IMPORTED_MODULE_5__.Range,
        Selection: _core_selection_js__WEBPACK_IMPORTED_MODULE_6__.Selection,
        SelectionDirection: _standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__.SelectionDirection,
        MarkerSeverity: _standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__.MarkerSeverity,
        MarkerTag: _standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__.MarkerTag,
        Uri: _base_common_uri_js__WEBPACK_IMPORTED_MODULE_3__.URI,
        Token: _core_token_js__WEBPACK_IMPORTED_MODULE_7__.Token
    };
}


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AccessibilitySupport": () => (/* binding */ AccessibilitySupport),
/* harmony export */   "CompletionItemInsertTextRule": () => (/* binding */ CompletionItemInsertTextRule),
/* harmony export */   "CompletionItemKind": () => (/* binding */ CompletionItemKind),
/* harmony export */   "CompletionItemTag": () => (/* binding */ CompletionItemTag),
/* harmony export */   "CompletionTriggerKind": () => (/* binding */ CompletionTriggerKind),
/* harmony export */   "ContentWidgetPositionPreference": () => (/* binding */ ContentWidgetPositionPreference),
/* harmony export */   "CursorChangeReason": () => (/* binding */ CursorChangeReason),
/* harmony export */   "DefaultEndOfLine": () => (/* binding */ DefaultEndOfLine),
/* harmony export */   "DocumentHighlightKind": () => (/* binding */ DocumentHighlightKind),
/* harmony export */   "EditorAutoIndentStrategy": () => (/* binding */ EditorAutoIndentStrategy),
/* harmony export */   "EditorOption": () => (/* binding */ EditorOption),
/* harmony export */   "EndOfLinePreference": () => (/* binding */ EndOfLinePreference),
/* harmony export */   "EndOfLineSequence": () => (/* binding */ EndOfLineSequence),
/* harmony export */   "IndentAction": () => (/* binding */ IndentAction),
/* harmony export */   "KeyCode": () => (/* binding */ KeyCode),
/* harmony export */   "MarkerSeverity": () => (/* binding */ MarkerSeverity),
/* harmony export */   "MarkerTag": () => (/* binding */ MarkerTag),
/* harmony export */   "MinimapPosition": () => (/* binding */ MinimapPosition),
/* harmony export */   "MouseTargetType": () => (/* binding */ MouseTargetType),
/* harmony export */   "OverlayWidgetPositionPreference": () => (/* binding */ OverlayWidgetPositionPreference),
/* harmony export */   "OverviewRulerLane": () => (/* binding */ OverviewRulerLane),
/* harmony export */   "RenderLineNumbersType": () => (/* binding */ RenderLineNumbersType),
/* harmony export */   "RenderMinimap": () => (/* binding */ RenderMinimap),
/* harmony export */   "ScrollType": () => (/* binding */ ScrollType),
/* harmony export */   "ScrollbarVisibility": () => (/* binding */ ScrollbarVisibility),
/* harmony export */   "SelectionDirection": () => (/* binding */ SelectionDirection),
/* harmony export */   "SignatureHelpTriggerKind": () => (/* binding */ SignatureHelpTriggerKind),
/* harmony export */   "SymbolKind": () => (/* binding */ SymbolKind),
/* harmony export */   "SymbolTag": () => (/* binding */ SymbolTag),
/* harmony export */   "TextEditorCursorBlinkingStyle": () => (/* binding */ TextEditorCursorBlinkingStyle),
/* harmony export */   "TextEditorCursorStyle": () => (/* binding */ TextEditorCursorStyle),
/* harmony export */   "TrackedRangeStickiness": () => (/* binding */ TrackedRangeStickiness),
/* harmony export */   "WrappingIndent": () => (/* binding */ WrappingIndent)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// THIS IS A GENERATED FILE. DO NOT EDIT DIRECTLY.
var AccessibilitySupport;
(function (AccessibilitySupport) {
    /**
     * This should be the browser case where it is not known if a screen reader is attached or no.
     */
    AccessibilitySupport[AccessibilitySupport["Unknown"] = 0] = "Unknown";
    AccessibilitySupport[AccessibilitySupport["Disabled"] = 1] = "Disabled";
    AccessibilitySupport[AccessibilitySupport["Enabled"] = 2] = "Enabled";
})(AccessibilitySupport || (AccessibilitySupport = {}));
var CompletionItemInsertTextRule;
(function (CompletionItemInsertTextRule) {
    /**
     * Adjust whitespace/indentation of multiline insert texts to
     * match the current line indentation.
     */
    CompletionItemInsertTextRule[CompletionItemInsertTextRule["KeepWhitespace"] = 1] = "KeepWhitespace";
    /**
     * `insertText` is a snippet.
     */
    CompletionItemInsertTextRule[CompletionItemInsertTextRule["InsertAsSnippet"] = 4] = "InsertAsSnippet";
})(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind[CompletionItemKind["Method"] = 0] = "Method";
    CompletionItemKind[CompletionItemKind["Function"] = 1] = "Function";
    CompletionItemKind[CompletionItemKind["Constructor"] = 2] = "Constructor";
    CompletionItemKind[CompletionItemKind["Field"] = 3] = "Field";
    CompletionItemKind[CompletionItemKind["Variable"] = 4] = "Variable";
    CompletionItemKind[CompletionItemKind["Class"] = 5] = "Class";
    CompletionItemKind[CompletionItemKind["Struct"] = 6] = "Struct";
    CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
    CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
    CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
    CompletionItemKind[CompletionItemKind["Event"] = 10] = "Event";
    CompletionItemKind[CompletionItemKind["Operator"] = 11] = "Operator";
    CompletionItemKind[CompletionItemKind["Unit"] = 12] = "Unit";
    CompletionItemKind[CompletionItemKind["Value"] = 13] = "Value";
    CompletionItemKind[CompletionItemKind["Constant"] = 14] = "Constant";
    CompletionItemKind[CompletionItemKind["Enum"] = 15] = "Enum";
    CompletionItemKind[CompletionItemKind["EnumMember"] = 16] = "EnumMember";
    CompletionItemKind[CompletionItemKind["Keyword"] = 17] = "Keyword";
    CompletionItemKind[CompletionItemKind["Text"] = 18] = "Text";
    CompletionItemKind[CompletionItemKind["Color"] = 19] = "Color";
    CompletionItemKind[CompletionItemKind["File"] = 20] = "File";
    CompletionItemKind[CompletionItemKind["Reference"] = 21] = "Reference";
    CompletionItemKind[CompletionItemKind["Customcolor"] = 22] = "Customcolor";
    CompletionItemKind[CompletionItemKind["Folder"] = 23] = "Folder";
    CompletionItemKind[CompletionItemKind["TypeParameter"] = 24] = "TypeParameter";
    CompletionItemKind[CompletionItemKind["User"] = 25] = "User";
    CompletionItemKind[CompletionItemKind["Issue"] = 26] = "Issue";
    CompletionItemKind[CompletionItemKind["Snippet"] = 27] = "Snippet";
})(CompletionItemKind || (CompletionItemKind = {}));
var CompletionItemTag;
(function (CompletionItemTag) {
    CompletionItemTag[CompletionItemTag["Deprecated"] = 1] = "Deprecated";
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * How a suggest provider was triggered.
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    CompletionTriggerKind[CompletionTriggerKind["Invoke"] = 0] = "Invoke";
    CompletionTriggerKind[CompletionTriggerKind["TriggerCharacter"] = 1] = "TriggerCharacter";
    CompletionTriggerKind[CompletionTriggerKind["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
})(CompletionTriggerKind || (CompletionTriggerKind = {}));
/**
 * A positioning preference for rendering content widgets.
 */
var ContentWidgetPositionPreference;
(function (ContentWidgetPositionPreference) {
    /**
     * Place the content widget exactly at a position
     */
    ContentWidgetPositionPreference[ContentWidgetPositionPreference["EXACT"] = 0] = "EXACT";
    /**
     * Place the content widget above a position
     */
    ContentWidgetPositionPreference[ContentWidgetPositionPreference["ABOVE"] = 1] = "ABOVE";
    /**
     * Place the content widget below a position
     */
    ContentWidgetPositionPreference[ContentWidgetPositionPreference["BELOW"] = 2] = "BELOW";
})(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));
/**
 * Describes the reason the cursor has changed its position.
 */
var CursorChangeReason;
(function (CursorChangeReason) {
    /**
     * Unknown or not set.
     */
    CursorChangeReason[CursorChangeReason["NotSet"] = 0] = "NotSet";
    /**
     * A `model.setValue()` was called.
     */
    CursorChangeReason[CursorChangeReason["ContentFlush"] = 1] = "ContentFlush";
    /**
     * The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.
     */
    CursorChangeReason[CursorChangeReason["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
    /**
     * There was an explicit user gesture.
     */
    CursorChangeReason[CursorChangeReason["Explicit"] = 3] = "Explicit";
    /**
     * There was a Paste.
     */
    CursorChangeReason[CursorChangeReason["Paste"] = 4] = "Paste";
    /**
     * There was an Undo.
     */
    CursorChangeReason[CursorChangeReason["Undo"] = 5] = "Undo";
    /**
     * There was a Redo.
     */
    CursorChangeReason[CursorChangeReason["Redo"] = 6] = "Redo";
})(CursorChangeReason || (CursorChangeReason = {}));
/**
 * The default end of line to use when instantiating models.
 */
var DefaultEndOfLine;
(function (DefaultEndOfLine) {
    /**
     * Use line feed (\n) as the end of line character.
     */
    DefaultEndOfLine[DefaultEndOfLine["LF"] = 1] = "LF";
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    DefaultEndOfLine[DefaultEndOfLine["CRLF"] = 2] = "CRLF";
})(DefaultEndOfLine || (DefaultEndOfLine = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * Configuration options for auto indentation in the editor
 */
var EditorAutoIndentStrategy;
(function (EditorAutoIndentStrategy) {
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["None"] = 0] = "None";
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["Keep"] = 1] = "Keep";
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["Brackets"] = 2] = "Brackets";
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["Advanced"] = 3] = "Advanced";
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["Full"] = 4] = "Full";
})(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));
var EditorOption;
(function (EditorOption) {
    EditorOption[EditorOption["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
    EditorOption[EditorOption["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
    EditorOption[EditorOption["accessibilitySupport"] = 2] = "accessibilitySupport";
    EditorOption[EditorOption["accessibilityPageSize"] = 3] = "accessibilityPageSize";
    EditorOption[EditorOption["ariaLabel"] = 4] = "ariaLabel";
    EditorOption[EditorOption["autoClosingBrackets"] = 5] = "autoClosingBrackets";
    EditorOption[EditorOption["autoClosingOvertype"] = 6] = "autoClosingOvertype";
    EditorOption[EditorOption["autoClosingQuotes"] = 7] = "autoClosingQuotes";
    EditorOption[EditorOption["autoIndent"] = 8] = "autoIndent";
    EditorOption[EditorOption["automaticLayout"] = 9] = "automaticLayout";
    EditorOption[EditorOption["autoSurround"] = 10] = "autoSurround";
    EditorOption[EditorOption["codeLens"] = 11] = "codeLens";
    EditorOption[EditorOption["colorDecorators"] = 12] = "colorDecorators";
    EditorOption[EditorOption["columnSelection"] = 13] = "columnSelection";
    EditorOption[EditorOption["comments"] = 14] = "comments";
    EditorOption[EditorOption["contextmenu"] = 15] = "contextmenu";
    EditorOption[EditorOption["copyWithSyntaxHighlighting"] = 16] = "copyWithSyntaxHighlighting";
    EditorOption[EditorOption["cursorBlinking"] = 17] = "cursorBlinking";
    EditorOption[EditorOption["cursorSmoothCaretAnimation"] = 18] = "cursorSmoothCaretAnimation";
    EditorOption[EditorOption["cursorStyle"] = 19] = "cursorStyle";
    EditorOption[EditorOption["cursorSurroundingLines"] = 20] = "cursorSurroundingLines";
    EditorOption[EditorOption["cursorSurroundingLinesStyle"] = 21] = "cursorSurroundingLinesStyle";
    EditorOption[EditorOption["cursorWidth"] = 22] = "cursorWidth";
    EditorOption[EditorOption["disableLayerHinting"] = 23] = "disableLayerHinting";
    EditorOption[EditorOption["disableMonospaceOptimizations"] = 24] = "disableMonospaceOptimizations";
    EditorOption[EditorOption["dragAndDrop"] = 25] = "dragAndDrop";
    EditorOption[EditorOption["emptySelectionClipboard"] = 26] = "emptySelectionClipboard";
    EditorOption[EditorOption["extraEditorClassName"] = 27] = "extraEditorClassName";
    EditorOption[EditorOption["fastScrollSensitivity"] = 28] = "fastScrollSensitivity";
    EditorOption[EditorOption["find"] = 29] = "find";
    EditorOption[EditorOption["fixedOverflowWidgets"] = 30] = "fixedOverflowWidgets";
    EditorOption[EditorOption["folding"] = 31] = "folding";
    EditorOption[EditorOption["foldingStrategy"] = 32] = "foldingStrategy";
    EditorOption[EditorOption["foldingHighlight"] = 33] = "foldingHighlight";
    EditorOption[EditorOption["unfoldOnClickAfterEndOfLine"] = 34] = "unfoldOnClickAfterEndOfLine";
    EditorOption[EditorOption["fontFamily"] = 35] = "fontFamily";
    EditorOption[EditorOption["fontInfo"] = 36] = "fontInfo";
    EditorOption[EditorOption["fontLigatures"] = 37] = "fontLigatures";
    EditorOption[EditorOption["fontSize"] = 38] = "fontSize";
    EditorOption[EditorOption["fontWeight"] = 39] = "fontWeight";
    EditorOption[EditorOption["formatOnPaste"] = 40] = "formatOnPaste";
    EditorOption[EditorOption["formatOnType"] = 41] = "formatOnType";
    EditorOption[EditorOption["glyphMargin"] = 42] = "glyphMargin";
    EditorOption[EditorOption["gotoLocation"] = 43] = "gotoLocation";
    EditorOption[EditorOption["hideCursorInOverviewRuler"] = 44] = "hideCursorInOverviewRuler";
    EditorOption[EditorOption["highlightActiveIndentGuide"] = 45] = "highlightActiveIndentGuide";
    EditorOption[EditorOption["hover"] = 46] = "hover";
    EditorOption[EditorOption["inDiffEditor"] = 47] = "inDiffEditor";
    EditorOption[EditorOption["letterSpacing"] = 48] = "letterSpacing";
    EditorOption[EditorOption["lightbulb"] = 49] = "lightbulb";
    EditorOption[EditorOption["lineDecorationsWidth"] = 50] = "lineDecorationsWidth";
    EditorOption[EditorOption["lineHeight"] = 51] = "lineHeight";
    EditorOption[EditorOption["lineNumbers"] = 52] = "lineNumbers";
    EditorOption[EditorOption["lineNumbersMinChars"] = 53] = "lineNumbersMinChars";
    EditorOption[EditorOption["links"] = 54] = "links";
    EditorOption[EditorOption["matchBrackets"] = 55] = "matchBrackets";
    EditorOption[EditorOption["minimap"] = 56] = "minimap";
    EditorOption[EditorOption["mouseStyle"] = 57] = "mouseStyle";
    EditorOption[EditorOption["mouseWheelScrollSensitivity"] = 58] = "mouseWheelScrollSensitivity";
    EditorOption[EditorOption["mouseWheelZoom"] = 59] = "mouseWheelZoom";
    EditorOption[EditorOption["multiCursorMergeOverlapping"] = 60] = "multiCursorMergeOverlapping";
    EditorOption[EditorOption["multiCursorModifier"] = 61] = "multiCursorModifier";
    EditorOption[EditorOption["multiCursorPaste"] = 62] = "multiCursorPaste";
    EditorOption[EditorOption["occurrencesHighlight"] = 63] = "occurrencesHighlight";
    EditorOption[EditorOption["overviewRulerBorder"] = 64] = "overviewRulerBorder";
    EditorOption[EditorOption["overviewRulerLanes"] = 65] = "overviewRulerLanes";
    EditorOption[EditorOption["padding"] = 66] = "padding";
    EditorOption[EditorOption["parameterHints"] = 67] = "parameterHints";
    EditorOption[EditorOption["peekWidgetDefaultFocus"] = 68] = "peekWidgetDefaultFocus";
    EditorOption[EditorOption["definitionLinkOpensInPeek"] = 69] = "definitionLinkOpensInPeek";
    EditorOption[EditorOption["quickSuggestions"] = 70] = "quickSuggestions";
    EditorOption[EditorOption["quickSuggestionsDelay"] = 71] = "quickSuggestionsDelay";
    EditorOption[EditorOption["readOnly"] = 72] = "readOnly";
    EditorOption[EditorOption["renameOnType"] = 73] = "renameOnType";
    EditorOption[EditorOption["renderControlCharacters"] = 74] = "renderControlCharacters";
    EditorOption[EditorOption["renderIndentGuides"] = 75] = "renderIndentGuides";
    EditorOption[EditorOption["renderFinalNewline"] = 76] = "renderFinalNewline";
    EditorOption[EditorOption["renderLineHighlight"] = 77] = "renderLineHighlight";
    EditorOption[EditorOption["renderLineHighlightOnlyWhenFocus"] = 78] = "renderLineHighlightOnlyWhenFocus";
    EditorOption[EditorOption["renderValidationDecorations"] = 79] = "renderValidationDecorations";
    EditorOption[EditorOption["renderWhitespace"] = 80] = "renderWhitespace";
    EditorOption[EditorOption["revealHorizontalRightPadding"] = 81] = "revealHorizontalRightPadding";
    EditorOption[EditorOption["roundedSelection"] = 82] = "roundedSelection";
    EditorOption[EditorOption["rulers"] = 83] = "rulers";
    EditorOption[EditorOption["scrollbar"] = 84] = "scrollbar";
    EditorOption[EditorOption["scrollBeyondLastColumn"] = 85] = "scrollBeyondLastColumn";
    EditorOption[EditorOption["scrollBeyondLastLine"] = 86] = "scrollBeyondLastLine";
    EditorOption[EditorOption["scrollPredominantAxis"] = 87] = "scrollPredominantAxis";
    EditorOption[EditorOption["selectionClipboard"] = 88] = "selectionClipboard";
    EditorOption[EditorOption["selectionHighlight"] = 89] = "selectionHighlight";
    EditorOption[EditorOption["selectOnLineNumbers"] = 90] = "selectOnLineNumbers";
    EditorOption[EditorOption["showFoldingControls"] = 91] = "showFoldingControls";
    EditorOption[EditorOption["showUnused"] = 92] = "showUnused";
    EditorOption[EditorOption["snippetSuggestions"] = 93] = "snippetSuggestions";
    EditorOption[EditorOption["smoothScrolling"] = 94] = "smoothScrolling";
    EditorOption[EditorOption["stopRenderingLineAfter"] = 95] = "stopRenderingLineAfter";
    EditorOption[EditorOption["suggest"] = 96] = "suggest";
    EditorOption[EditorOption["suggestFontSize"] = 97] = "suggestFontSize";
    EditorOption[EditorOption["suggestLineHeight"] = 98] = "suggestLineHeight";
    EditorOption[EditorOption["suggestOnTriggerCharacters"] = 99] = "suggestOnTriggerCharacters";
    EditorOption[EditorOption["suggestSelection"] = 100] = "suggestSelection";
    EditorOption[EditorOption["tabCompletion"] = 101] = "tabCompletion";
    EditorOption[EditorOption["tabIndex"] = 102] = "tabIndex";
    EditorOption[EditorOption["unusualLineTerminators"] = 103] = "unusualLineTerminators";
    EditorOption[EditorOption["useTabStops"] = 104] = "useTabStops";
    EditorOption[EditorOption["wordSeparators"] = 105] = "wordSeparators";
    EditorOption[EditorOption["wordWrap"] = 106] = "wordWrap";
    EditorOption[EditorOption["wordWrapBreakAfterCharacters"] = 107] = "wordWrapBreakAfterCharacters";
    EditorOption[EditorOption["wordWrapBreakBeforeCharacters"] = 108] = "wordWrapBreakBeforeCharacters";
    EditorOption[EditorOption["wordWrapColumn"] = 109] = "wordWrapColumn";
    EditorOption[EditorOption["wordWrapMinified"] = 110] = "wordWrapMinified";
    EditorOption[EditorOption["wrappingIndent"] = 111] = "wrappingIndent";
    EditorOption[EditorOption["wrappingStrategy"] = 112] = "wrappingStrategy";
    EditorOption[EditorOption["showDeprecated"] = 113] = "showDeprecated";
    EditorOption[EditorOption["editorClassName"] = 114] = "editorClassName";
    EditorOption[EditorOption["pixelRatio"] = 115] = "pixelRatio";
    EditorOption[EditorOption["tabFocusMode"] = 116] = "tabFocusMode";
    EditorOption[EditorOption["layoutInfo"] = 117] = "layoutInfo";
    EditorOption[EditorOption["wrappingInfo"] = 118] = "wrappingInfo";
})(EditorOption || (EditorOption = {}));
/**
 * End of line character preference.
 */
var EndOfLinePreference;
(function (EndOfLinePreference) {
    /**
     * Use the end of line character identified in the text buffer.
     */
    EndOfLinePreference[EndOfLinePreference["TextDefined"] = 0] = "TextDefined";
    /**
     * Use line feed (\n) as the end of line character.
     */
    EndOfLinePreference[EndOfLinePreference["LF"] = 1] = "LF";
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    EndOfLinePreference[EndOfLinePreference["CRLF"] = 2] = "CRLF";
})(EndOfLinePreference || (EndOfLinePreference = {}));
/**
 * End of line character preference.
 */
var EndOfLineSequence;
(function (EndOfLineSequence) {
    /**
     * Use line feed (\n) as the end of line character.
     */
    EndOfLineSequence[EndOfLineSequence["LF"] = 0] = "LF";
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    EndOfLineSequence[EndOfLineSequence["CRLF"] = 1] = "CRLF";
})(EndOfLineSequence || (EndOfLineSequence = {}));
/**
 * Describes what to do with the indentation when pressing Enter.
 */
var IndentAction;
(function (IndentAction) {
    /**
     * Insert new line and copy the previous line's indentation.
     */
    IndentAction[IndentAction["None"] = 0] = "None";
    /**
     * Insert new line and indent once (relative to the previous line's indentation).
     */
    IndentAction[IndentAction["Indent"] = 1] = "Indent";
    /**
     * Insert two new lines:
     *  - the first one indented which will hold the cursor
     *  - the second one at the same indentation level
     */
    IndentAction[IndentAction["IndentOutdent"] = 2] = "IndentOutdent";
    /**
     * Insert new line and outdent once (relative to the previous line's indentation).
     */
    IndentAction[IndentAction["Outdent"] = 3] = "Outdent";
})(IndentAction || (IndentAction = {}));
/**
 * Virtual Key Codes, the value does not hold any inherent meaning.
 * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
 * But these are "more general", as they should work across browsers & OS`s.
 */
var KeyCode;
(function (KeyCode) {
    /**
     * Placed first to cover the 0 value of the enum.
     */
    KeyCode[KeyCode["Unknown"] = 0] = "Unknown";
    KeyCode[KeyCode["Backspace"] = 1] = "Backspace";
    KeyCode[KeyCode["Tab"] = 2] = "Tab";
    KeyCode[KeyCode["Enter"] = 3] = "Enter";
    KeyCode[KeyCode["Shift"] = 4] = "Shift";
    KeyCode[KeyCode["Ctrl"] = 5] = "Ctrl";
    KeyCode[KeyCode["Alt"] = 6] = "Alt";
    KeyCode[KeyCode["PauseBreak"] = 7] = "PauseBreak";
    KeyCode[KeyCode["CapsLock"] = 8] = "CapsLock";
    KeyCode[KeyCode["Escape"] = 9] = "Escape";
    KeyCode[KeyCode["Space"] = 10] = "Space";
    KeyCode[KeyCode["PageUp"] = 11] = "PageUp";
    KeyCode[KeyCode["PageDown"] = 12] = "PageDown";
    KeyCode[KeyCode["End"] = 13] = "End";
    KeyCode[KeyCode["Home"] = 14] = "Home";
    KeyCode[KeyCode["LeftArrow"] = 15] = "LeftArrow";
    KeyCode[KeyCode["UpArrow"] = 16] = "UpArrow";
    KeyCode[KeyCode["RightArrow"] = 17] = "RightArrow";
    KeyCode[KeyCode["DownArrow"] = 18] = "DownArrow";
    KeyCode[KeyCode["Insert"] = 19] = "Insert";
    KeyCode[KeyCode["Delete"] = 20] = "Delete";
    KeyCode[KeyCode["KEY_0"] = 21] = "KEY_0";
    KeyCode[KeyCode["KEY_1"] = 22] = "KEY_1";
    KeyCode[KeyCode["KEY_2"] = 23] = "KEY_2";
    KeyCode[KeyCode["KEY_3"] = 24] = "KEY_3";
    KeyCode[KeyCode["KEY_4"] = 25] = "KEY_4";
    KeyCode[KeyCode["KEY_5"] = 26] = "KEY_5";
    KeyCode[KeyCode["KEY_6"] = 27] = "KEY_6";
    KeyCode[KeyCode["KEY_7"] = 28] = "KEY_7";
    KeyCode[KeyCode["KEY_8"] = 29] = "KEY_8";
    KeyCode[KeyCode["KEY_9"] = 30] = "KEY_9";
    KeyCode[KeyCode["KEY_A"] = 31] = "KEY_A";
    KeyCode[KeyCode["KEY_B"] = 32] = "KEY_B";
    KeyCode[KeyCode["KEY_C"] = 33] = "KEY_C";
    KeyCode[KeyCode["KEY_D"] = 34] = "KEY_D";
    KeyCode[KeyCode["KEY_E"] = 35] = "KEY_E";
    KeyCode[KeyCode["KEY_F"] = 36] = "KEY_F";
    KeyCode[KeyCode["KEY_G"] = 37] = "KEY_G";
    KeyCode[KeyCode["KEY_H"] = 38] = "KEY_H";
    KeyCode[KeyCode["KEY_I"] = 39] = "KEY_I";
    KeyCode[KeyCode["KEY_J"] = 40] = "KEY_J";
    KeyCode[KeyCode["KEY_K"] = 41] = "KEY_K";
    KeyCode[KeyCode["KEY_L"] = 42] = "KEY_L";
    KeyCode[KeyCode["KEY_M"] = 43] = "KEY_M";
    KeyCode[KeyCode["KEY_N"] = 44] = "KEY_N";
    KeyCode[KeyCode["KEY_O"] = 45] = "KEY_O";
    KeyCode[KeyCode["KEY_P"] = 46] = "KEY_P";
    KeyCode[KeyCode["KEY_Q"] = 47] = "KEY_Q";
    KeyCode[KeyCode["KEY_R"] = 48] = "KEY_R";
    KeyCode[KeyCode["KEY_S"] = 49] = "KEY_S";
    KeyCode[KeyCode["KEY_T"] = 50] = "KEY_T";
    KeyCode[KeyCode["KEY_U"] = 51] = "KEY_U";
    KeyCode[KeyCode["KEY_V"] = 52] = "KEY_V";
    KeyCode[KeyCode["KEY_W"] = 53] = "KEY_W";
    KeyCode[KeyCode["KEY_X"] = 54] = "KEY_X";
    KeyCode[KeyCode["KEY_Y"] = 55] = "KEY_Y";
    KeyCode[KeyCode["KEY_Z"] = 56] = "KEY_Z";
    KeyCode[KeyCode["Meta"] = 57] = "Meta";
    KeyCode[KeyCode["ContextMenu"] = 58] = "ContextMenu";
    KeyCode[KeyCode["F1"] = 59] = "F1";
    KeyCode[KeyCode["F2"] = 60] = "F2";
    KeyCode[KeyCode["F3"] = 61] = "F3";
    KeyCode[KeyCode["F4"] = 62] = "F4";
    KeyCode[KeyCode["F5"] = 63] = "F5";
    KeyCode[KeyCode["F6"] = 64] = "F6";
    KeyCode[KeyCode["F7"] = 65] = "F7";
    KeyCode[KeyCode["F8"] = 66] = "F8";
    KeyCode[KeyCode["F9"] = 67] = "F9";
    KeyCode[KeyCode["F10"] = 68] = "F10";
    KeyCode[KeyCode["F11"] = 69] = "F11";
    KeyCode[KeyCode["F12"] = 70] = "F12";
    KeyCode[KeyCode["F13"] = 71] = "F13";
    KeyCode[KeyCode["F14"] = 72] = "F14";
    KeyCode[KeyCode["F15"] = 73] = "F15";
    KeyCode[KeyCode["F16"] = 74] = "F16";
    KeyCode[KeyCode["F17"] = 75] = "F17";
    KeyCode[KeyCode["F18"] = 76] = "F18";
    KeyCode[KeyCode["F19"] = 77] = "F19";
    KeyCode[KeyCode["NumLock"] = 78] = "NumLock";
    KeyCode[KeyCode["ScrollLock"] = 79] = "ScrollLock";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the ';:' key
     */
    KeyCode[KeyCode["US_SEMICOLON"] = 80] = "US_SEMICOLON";
    /**
     * For any country/region, the '+' key
     * For the US standard keyboard, the '=+' key
     */
    KeyCode[KeyCode["US_EQUAL"] = 81] = "US_EQUAL";
    /**
     * For any country/region, the ',' key
     * For the US standard keyboard, the ',<' key
     */
    KeyCode[KeyCode["US_COMMA"] = 82] = "US_COMMA";
    /**
     * For any country/region, the '-' key
     * For the US standard keyboard, the '-_' key
     */
    KeyCode[KeyCode["US_MINUS"] = 83] = "US_MINUS";
    /**
     * For any country/region, the '.' key
     * For the US standard keyboard, the '.>' key
     */
    KeyCode[KeyCode["US_DOT"] = 84] = "US_DOT";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '/?' key
     */
    KeyCode[KeyCode["US_SLASH"] = 85] = "US_SLASH";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '`~' key
     */
    KeyCode[KeyCode["US_BACKTICK"] = 86] = "US_BACKTICK";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '[{' key
     */
    KeyCode[KeyCode["US_OPEN_SQUARE_BRACKET"] = 87] = "US_OPEN_SQUARE_BRACKET";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '\|' key
     */
    KeyCode[KeyCode["US_BACKSLASH"] = 88] = "US_BACKSLASH";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the ']}' key
     */
    KeyCode[KeyCode["US_CLOSE_SQUARE_BRACKET"] = 89] = "US_CLOSE_SQUARE_BRACKET";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the ''"' key
     */
    KeyCode[KeyCode["US_QUOTE"] = 90] = "US_QUOTE";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     */
    KeyCode[KeyCode["OEM_8"] = 91] = "OEM_8";
    /**
     * Either the angle bracket key or the backslash key on the RT 102-key keyboard.
     */
    KeyCode[KeyCode["OEM_102"] = 92] = "OEM_102";
    KeyCode[KeyCode["NUMPAD_0"] = 93] = "NUMPAD_0";
    KeyCode[KeyCode["NUMPAD_1"] = 94] = "NUMPAD_1";
    KeyCode[KeyCode["NUMPAD_2"] = 95] = "NUMPAD_2";
    KeyCode[KeyCode["NUMPAD_3"] = 96] = "NUMPAD_3";
    KeyCode[KeyCode["NUMPAD_4"] = 97] = "NUMPAD_4";
    KeyCode[KeyCode["NUMPAD_5"] = 98] = "NUMPAD_5";
    KeyCode[KeyCode["NUMPAD_6"] = 99] = "NUMPAD_6";
    KeyCode[KeyCode["NUMPAD_7"] = 100] = "NUMPAD_7";
    KeyCode[KeyCode["NUMPAD_8"] = 101] = "NUMPAD_8";
    KeyCode[KeyCode["NUMPAD_9"] = 102] = "NUMPAD_9";
    KeyCode[KeyCode["NUMPAD_MULTIPLY"] = 103] = "NUMPAD_MULTIPLY";
    KeyCode[KeyCode["NUMPAD_ADD"] = 104] = "NUMPAD_ADD";
    KeyCode[KeyCode["NUMPAD_SEPARATOR"] = 105] = "NUMPAD_SEPARATOR";
    KeyCode[KeyCode["NUMPAD_SUBTRACT"] = 106] = "NUMPAD_SUBTRACT";
    KeyCode[KeyCode["NUMPAD_DECIMAL"] = 107] = "NUMPAD_DECIMAL";
    KeyCode[KeyCode["NUMPAD_DIVIDE"] = 108] = "NUMPAD_DIVIDE";
    /**
     * Cover all key codes when IME is processing input.
     */
    KeyCode[KeyCode["KEY_IN_COMPOSITION"] = 109] = "KEY_IN_COMPOSITION";
    KeyCode[KeyCode["ABNT_C1"] = 110] = "ABNT_C1";
    KeyCode[KeyCode["ABNT_C2"] = 111] = "ABNT_C2";
    /**
     * Placed last to cover the length of the enum.
     * Please do not depend on this value!
     */
    KeyCode[KeyCode["MAX_VALUE"] = 112] = "MAX_VALUE";
})(KeyCode || (KeyCode = {}));
var MarkerSeverity;
(function (MarkerSeverity) {
    MarkerSeverity[MarkerSeverity["Hint"] = 1] = "Hint";
    MarkerSeverity[MarkerSeverity["Info"] = 2] = "Info";
    MarkerSeverity[MarkerSeverity["Warning"] = 4] = "Warning";
    MarkerSeverity[MarkerSeverity["Error"] = 8] = "Error";
})(MarkerSeverity || (MarkerSeverity = {}));
var MarkerTag;
(function (MarkerTag) {
    MarkerTag[MarkerTag["Unnecessary"] = 1] = "Unnecessary";
    MarkerTag[MarkerTag["Deprecated"] = 2] = "Deprecated";
})(MarkerTag || (MarkerTag = {}));
/**
 * Position in the minimap to render the decoration.
 */
var MinimapPosition;
(function (MinimapPosition) {
    MinimapPosition[MinimapPosition["Inline"] = 1] = "Inline";
    MinimapPosition[MinimapPosition["Gutter"] = 2] = "Gutter";
})(MinimapPosition || (MinimapPosition = {}));
/**
 * Type of hit element with the mouse in the editor.
 */
var MouseTargetType;
(function (MouseTargetType) {
    /**
     * Mouse is on top of an unknown element.
     */
    MouseTargetType[MouseTargetType["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * Mouse is on top of the textarea used for input.
     */
    MouseTargetType[MouseTargetType["TEXTAREA"] = 1] = "TEXTAREA";
    /**
     * Mouse is on top of the glyph margin
     */
    MouseTargetType[MouseTargetType["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
    /**
     * Mouse is on top of the line numbers
     */
    MouseTargetType[MouseTargetType["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
    /**
     * Mouse is on top of the line decorations
     */
    MouseTargetType[MouseTargetType["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
    /**
     * Mouse is on top of the whitespace left in the gutter by a view zone.
     */
    MouseTargetType[MouseTargetType["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
    /**
     * Mouse is on top of text in the content.
     */
    MouseTargetType[MouseTargetType["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
    /**
     * Mouse is on top of empty space in the content (e.g. after line text or below last line)
     */
    MouseTargetType[MouseTargetType["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
    /**
     * Mouse is on top of a view zone in the content.
     */
    MouseTargetType[MouseTargetType["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
    /**
     * Mouse is on top of a content widget.
     */
    MouseTargetType[MouseTargetType["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
    /**
     * Mouse is on top of the decorations overview ruler.
     */
    MouseTargetType[MouseTargetType["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
    /**
     * Mouse is on top of a scrollbar.
     */
    MouseTargetType[MouseTargetType["SCROLLBAR"] = 11] = "SCROLLBAR";
    /**
     * Mouse is on top of an overlay widget.
     */
    MouseTargetType[MouseTargetType["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
    /**
     * Mouse is outside of the editor.
     */
    MouseTargetType[MouseTargetType["OUTSIDE_EDITOR"] = 13] = "OUTSIDE_EDITOR";
})(MouseTargetType || (MouseTargetType = {}));
/**
 * A positioning preference for rendering overlay widgets.
 */
var OverlayWidgetPositionPreference;
(function (OverlayWidgetPositionPreference) {
    /**
     * Position the overlay widget in the top right corner
     */
    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
    /**
     * Position the overlay widget in the bottom right corner
     */
    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
    /**
     * Position the overlay widget in the top center
     */
    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["TOP_CENTER"] = 2] = "TOP_CENTER";
})(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));
/**
 * Vertical Lane in the overview ruler of the editor.
 */
var OverviewRulerLane;
(function (OverviewRulerLane) {
    OverviewRulerLane[OverviewRulerLane["Left"] = 1] = "Left";
    OverviewRulerLane[OverviewRulerLane["Center"] = 2] = "Center";
    OverviewRulerLane[OverviewRulerLane["Right"] = 4] = "Right";
    OverviewRulerLane[OverviewRulerLane["Full"] = 7] = "Full";
})(OverviewRulerLane || (OverviewRulerLane = {}));
var RenderLineNumbersType;
(function (RenderLineNumbersType) {
    RenderLineNumbersType[RenderLineNumbersType["Off"] = 0] = "Off";
    RenderLineNumbersType[RenderLineNumbersType["On"] = 1] = "On";
    RenderLineNumbersType[RenderLineNumbersType["Relative"] = 2] = "Relative";
    RenderLineNumbersType[RenderLineNumbersType["Interval"] = 3] = "Interval";
    RenderLineNumbersType[RenderLineNumbersType["Custom"] = 4] = "Custom";
})(RenderLineNumbersType || (RenderLineNumbersType = {}));
var RenderMinimap;
(function (RenderMinimap) {
    RenderMinimap[RenderMinimap["None"] = 0] = "None";
    RenderMinimap[RenderMinimap["Text"] = 1] = "Text";
    RenderMinimap[RenderMinimap["Blocks"] = 2] = "Blocks";
})(RenderMinimap || (RenderMinimap = {}));
var ScrollType;
(function (ScrollType) {
    ScrollType[ScrollType["Smooth"] = 0] = "Smooth";
    ScrollType[ScrollType["Immediate"] = 1] = "Immediate";
})(ScrollType || (ScrollType = {}));
var ScrollbarVisibility;
(function (ScrollbarVisibility) {
    ScrollbarVisibility[ScrollbarVisibility["Auto"] = 1] = "Auto";
    ScrollbarVisibility[ScrollbarVisibility["Hidden"] = 2] = "Hidden";
    ScrollbarVisibility[ScrollbarVisibility["Visible"] = 3] = "Visible";
})(ScrollbarVisibility || (ScrollbarVisibility = {}));
/**
 * The direction of a selection.
 */
var SelectionDirection;
(function (SelectionDirection) {
    /**
     * The selection starts above where it ends.
     */
    SelectionDirection[SelectionDirection["LTR"] = 0] = "LTR";
    /**
     * The selection starts below where it ends.
     */
    SelectionDirection[SelectionDirection["RTL"] = 1] = "RTL";
})(SelectionDirection || (SelectionDirection = {}));
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind[SymbolKind["File"] = 0] = "File";
    SymbolKind[SymbolKind["Module"] = 1] = "Module";
    SymbolKind[SymbolKind["Namespace"] = 2] = "Namespace";
    SymbolKind[SymbolKind["Package"] = 3] = "Package";
    SymbolKind[SymbolKind["Class"] = 4] = "Class";
    SymbolKind[SymbolKind["Method"] = 5] = "Method";
    SymbolKind[SymbolKind["Property"] = 6] = "Property";
    SymbolKind[SymbolKind["Field"] = 7] = "Field";
    SymbolKind[SymbolKind["Constructor"] = 8] = "Constructor";
    SymbolKind[SymbolKind["Enum"] = 9] = "Enum";
    SymbolKind[SymbolKind["Interface"] = 10] = "Interface";
    SymbolKind[SymbolKind["Function"] = 11] = "Function";
    SymbolKind[SymbolKind["Variable"] = 12] = "Variable";
    SymbolKind[SymbolKind["Constant"] = 13] = "Constant";
    SymbolKind[SymbolKind["String"] = 14] = "String";
    SymbolKind[SymbolKind["Number"] = 15] = "Number";
    SymbolKind[SymbolKind["Boolean"] = 16] = "Boolean";
    SymbolKind[SymbolKind["Array"] = 17] = "Array";
    SymbolKind[SymbolKind["Object"] = 18] = "Object";
    SymbolKind[SymbolKind["Key"] = 19] = "Key";
    SymbolKind[SymbolKind["Null"] = 20] = "Null";
    SymbolKind[SymbolKind["EnumMember"] = 21] = "EnumMember";
    SymbolKind[SymbolKind["Struct"] = 22] = "Struct";
    SymbolKind[SymbolKind["Event"] = 23] = "Event";
    SymbolKind[SymbolKind["Operator"] = 24] = "Operator";
    SymbolKind[SymbolKind["TypeParameter"] = 25] = "TypeParameter";
})(SymbolKind || (SymbolKind = {}));
var SymbolTag;
(function (SymbolTag) {
    SymbolTag[SymbolTag["Deprecated"] = 1] = "Deprecated";
})(SymbolTag || (SymbolTag = {}));
/**
 * The kind of animation in which the editor's cursor should be rendered.
 */
var TextEditorCursorBlinkingStyle;
(function (TextEditorCursorBlinkingStyle) {
    /**
     * Hidden
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Hidden"] = 0] = "Hidden";
    /**
     * Blinking
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Blink"] = 1] = "Blink";
    /**
     * Blinking with smooth fading
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Smooth"] = 2] = "Smooth";
    /**
     * Blinking with prolonged filled state and smooth fading
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Phase"] = 3] = "Phase";
    /**
     * Expand collapse animation on the y axis
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Expand"] = 4] = "Expand";
    /**
     * No-Blinking
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Solid"] = 5] = "Solid";
})(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
/**
 * The style in which the editor's cursor should be rendered.
 */
var TextEditorCursorStyle;
(function (TextEditorCursorStyle) {
    /**
     * As a vertical line (sitting between two characters).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["Line"] = 1] = "Line";
    /**
     * As a block (sitting on top of a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["Block"] = 2] = "Block";
    /**
     * As a horizontal line (sitting under a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["Underline"] = 3] = "Underline";
    /**
     * As a thin vertical line (sitting between two characters).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["LineThin"] = 4] = "LineThin";
    /**
     * As an outlined block (sitting on top of a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["BlockOutline"] = 5] = "BlockOutline";
    /**
     * As a thin horizontal line (sitting under a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["UnderlineThin"] = 6] = "UnderlineThin";
})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
/**
 * Describes the behavior of decorations when typing/editing near their edges.
 * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`
 */
var TrackedRangeStickiness;
(function (TrackedRangeStickiness) {
    TrackedRangeStickiness[TrackedRangeStickiness["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
    TrackedRangeStickiness[TrackedRangeStickiness["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
    TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
    TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
})(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
/**
 * Describes how to indent wrapped lines.
 */
var WrappingIndent;
(function (WrappingIndent) {
    /**
     * No indentation => wrapped lines begin at column 1.
     */
    WrappingIndent[WrappingIndent["None"] = 0] = "None";
    /**
     * Same => wrapped lines get the same indentation as the parent.
     */
    WrappingIndent[WrappingIndent["Same"] = 1] = "Same";
    /**
     * Indent => wrapped lines get +1 indentation toward the parent.
     */
    WrappingIndent[WrappingIndent["Indent"] = 2] = "Indent";
    /**
     * DeepIndent => wrapped lines get +2 indentation toward the parent.
     */
    WrappingIndent[WrappingIndent["DeepIndent"] = 3] = "DeepIndent";
})(WrappingIndent || (WrappingIndent = {}));


/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/viewModel/prefixSumComputer.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/viewModel/prefixSumComputer.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrefixSumComputer": () => (/* binding */ PrefixSumComputer),
/* harmony export */   "PrefixSumIndexOfResult": () => (/* binding */ PrefixSumIndexOfResult)
/* harmony export */ });
/* harmony import */ var _base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/uint.js */ "./node_modules/monaco-editor/esm/vs/base/common/uint.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

class PrefixSumIndexOfResult {
    constructor(index, remainder) {
        this.index = index;
        this.remainder = remainder;
    }
}
class PrefixSumComputer {
    constructor(values) {
        this.values = values;
        this.prefixSum = new Uint32Array(values.length);
        this.prefixSumValidIndex = new Int32Array(1);
        this.prefixSumValidIndex[0] = -1;
    }
    insertValues(insertIndex, insertValues) {
        insertIndex = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__.toUint32)(insertIndex);
        const oldValues = this.values;
        const oldPrefixSum = this.prefixSum;
        const insertValuesLen = insertValues.length;
        if (insertValuesLen === 0) {
            return false;
        }
        this.values = new Uint32Array(oldValues.length + insertValuesLen);
        this.values.set(oldValues.subarray(0, insertIndex), 0);
        this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
        this.values.set(insertValues, insertIndex);
        if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = insertIndex - 1;
        }
        this.prefixSum = new Uint32Array(this.values.length);
        if (this.prefixSumValidIndex[0] >= 0) {
            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
        }
        return true;
    }
    changeValue(index, value) {
        index = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__.toUint32)(index);
        value = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__.toUint32)(value);
        if (this.values[index] === value) {
            return false;
        }
        this.values[index] = value;
        if (index - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = index - 1;
        }
        return true;
    }
    removeValues(startIndex, cnt) {
        startIndex = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__.toUint32)(startIndex);
        cnt = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__.toUint32)(cnt);
        const oldValues = this.values;
        const oldPrefixSum = this.prefixSum;
        if (startIndex >= oldValues.length) {
            return false;
        }
        let maxCnt = oldValues.length - startIndex;
        if (cnt >= maxCnt) {
            cnt = maxCnt;
        }
        if (cnt === 0) {
            return false;
        }
        this.values = new Uint32Array(oldValues.length - cnt);
        this.values.set(oldValues.subarray(0, startIndex), 0);
        this.values.set(oldValues.subarray(startIndex + cnt), startIndex);
        this.prefixSum = new Uint32Array(this.values.length);
        if (startIndex - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = startIndex - 1;
        }
        if (this.prefixSumValidIndex[0] >= 0) {
            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
        }
        return true;
    }
    getTotalValue() {
        if (this.values.length === 0) {
            return 0;
        }
        return this._getAccumulatedValue(this.values.length - 1);
    }
    getAccumulatedValue(index) {
        if (index < 0) {
            return 0;
        }
        index = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__.toUint32)(index);
        return this._getAccumulatedValue(index);
    }
    _getAccumulatedValue(index) {
        if (index <= this.prefixSumValidIndex[0]) {
            return this.prefixSum[index];
        }
        let startIndex = this.prefixSumValidIndex[0] + 1;
        if (startIndex === 0) {
            this.prefixSum[0] = this.values[0];
            startIndex++;
        }
        if (index >= this.values.length) {
            index = this.values.length - 1;
        }
        for (let i = startIndex; i <= index; i++) {
            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
        }
        this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
        return this.prefixSum[index];
    }
    getIndexOf(accumulatedValue) {
        accumulatedValue = Math.floor(accumulatedValue); //@perf
        // Compute all sums (to get a fully valid prefixSum)
        this.getTotalValue();
        let low = 0;
        let high = this.values.length - 1;
        let mid = 0;
        let midStop = 0;
        let midStart = 0;
        while (low <= high) {
            mid = low + ((high - low) / 2) | 0;
            midStop = this.prefixSum[mid];
            midStart = midStop - this.values[mid];
            if (accumulatedValue < midStart) {
                high = mid - 1;
            }
            else if (accumulatedValue >= midStop) {
                low = mid + 1;
            }
            else {
                break;
            }
        }
        return new PrefixSumIndexOfResult(mid, accumulatedValue - midStart);
    }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/editor.worker.js ***!
  \*******************************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initialize": () => (/* binding */ initialize)
/* harmony export */ });
/* harmony import */ var _base_common_worker_simpleWorker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/common/worker/simpleWorker.js */ "./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js");
/* harmony import */ var _common_services_editorSimpleWorker_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common/services/editorSimpleWorker.js */ "./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


let initialized = false;
function initialize(foreignModule) {
    if (initialized) {
        return;
    }
    initialized = true;
    const simpleWorker = new _base_common_worker_simpleWorker_js__WEBPACK_IMPORTED_MODULE_0__.SimpleWorkerServer((msg) => {
        self.postMessage(msg);
    }, (host) => new _common_services_editorSimpleWorker_js__WEBPACK_IMPORTED_MODULE_1__.EditorSimpleWorker(host, foreignModule));
    self.onmessage = (e) => {
        simpleWorker.onmessage(e.data);
    };
}
self.onmessage = (e) => {
    // Ignore first message in this case and initialize if not yet initialized
    if (!initialized) {
        initialize(null);
    }
};

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWRpdG9yLndvcmtlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMVBBO0FBQ0E7QUFDQTtBQUNBO0FBQzRDO0FBQzVDO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpREFBVTtBQUMzQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDhDQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUM2QztBQUNMO0FBQ2pDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNEQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQsNEJBQTRCLG9EQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0Q0FBNEM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQ0FBZ0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNEQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQ0FBZ0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzREFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3R5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQ0FBMkMsS0FBSztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dEO0FBQ2lDO0FBQ3BDO0FBQ3RDO0FBQ1A7QUFDQSx1QkFBdUIsMERBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixTQUFTLDZCQUE2QjtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGlFQUFrQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMENBQTBDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBDQUEwQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVUsNkNBQTZDLGVBQWUsNkNBQTZDLFNBQVM7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNEQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMERBQWU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzREFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkRBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNEQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwREFBZTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN2tCQTtBQUNBO0FBQ0E7QUFDQTtBQUN3QztBQUN4QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHVDQUF1QyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3REFBdUI7QUFDdkM7QUFDQTtBQUNBLHdCQUF3Qix1REFBc0I7QUFDOUM7QUFDQSxvQ0FBb0MseURBQXdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1REFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEOzs7Ozs7Ozs7Ozs7Ozs7QUM5UDdEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCLG9CQUFvQjtBQUN0RTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUM5QjtBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxrQkFBa0IsMkRBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFQeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQSxxRUFBcUUsa0JBQWtCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1AsUUFBUSxxREFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDZCQUE2QixxQ0FBcUM7QUFDbEU7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNsTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMseUJBQXlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN3QztBQUN4Qyw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUIscUJBQXFCO0FBQ3JCLCtCQUErQjtBQUMvQixnQ0FBZ0M7QUFDaEMsdUJBQXVCO0FBQ3ZCLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsS0FBSyxJQUFJLE1BQU0sRUFBRSxZQUFZLFVBQVUsU0FBUztBQUMxRSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVSxFQUFFLDZCQUE2QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQixFQUFFLHFCQUFxQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSSxFQUFFLEtBQUssT0FBTyxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUs7QUFDM0U7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBVyxLQUFLLGVBQWUsTUFBTSw0Q0FBVztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVUsSUFBSSxvQkFBb0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0IsSUFBSSxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZSxJQUFJLGFBQWE7QUFDL0MsZUFBZSxlQUFlLEVBQUUsYUFBYTtBQUM3QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVUsSUFBSSxpQkFBaUI7QUFDekU7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFVBQVUsSUFBSSxvQkFBb0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQSwrQkFBK0IsT0FBTyxJQUFJLEtBQUssT0FBTyxPQUFPLEVBQUUsS0FBSztBQUNwRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUksRUFBRSw2QkFBNkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWE7QUFDMUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw4QkFBOEI7QUFDNUUsb0RBQW9ELDRDQUFXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSyxHQUFHLGFBQWE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxLQUFLO0FBQ3JDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJLEVBQUUsa0NBQWtDO0FBQzFELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1CQUFtQixpREFBZ0I7QUFDbkMsaUJBQWlCLGlEQUFnQjtBQUNqQyxrQkFBa0IsaURBQWdCO0FBQ2xDLGlCQUFpQixpREFBZ0I7QUFDakMsa0JBQWtCLGlEQUFnQjtBQUNsQyxpQkFBaUIsaURBQWdCO0FBQ2pDLGFBQWEsaURBQWdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsMkNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNQLDJEQUEyRCxxQkFBTSxnQkFBZ0IscUJBQU0sS0FBSztBQUNyRjtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixrQ0FBa0MsNEJBQTRCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNxRTtBQUNyRTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBLHFCQUFxQixPQUFPLG1EQUFTLGFBQWEscURBQVcsd0JBQXdCO0FBQ3JGLHlCQUF5QixPQUFPLDBEQUFZO0FBQzVDLEVBQUU7QUFDSztBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2JQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0EsOEJBQThCLEdBQUc7QUFDakM7QUFDQSxpQ0FBaUMsRUFBRTtBQUNuQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsK0JBQStCLEVBQUU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG1DQUFtQyxFQUFFO0FBQ3JDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlEQUF5RDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsZ0NBQWdDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUCxXQUFXLGdDQUFnQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ08sbURBQW1EO0FBQzFEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1Asc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QixpQkFBaUI7QUFDMUQ7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1dUJBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBLDZEQUE2RCxLQUFLO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMEVBQTBFLFdBQVc7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDMEM7QUFDUDtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsMEJBQTBCLGNBQWMsWUFBWSxTQUFTLGFBQWEsVUFBVSxnQkFBZ0IsYUFBYSxFQUFFO0FBQzVLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsWUFBWTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQVM7QUFDckIsK0JBQStCLGdEQUFnQjtBQUMvQztBQUNBO0FBQ0Esc0JBQXNCLGdEQUFnQjtBQUN0QztBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWMsRUFBRSxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJDQUEyQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0JBQStCLEdBQUcsZUFBZSxHQUFHO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0JBQStCLEdBQUcsZUFBZSxHQUFHO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDOEQ7QUFDakI7QUFDTjtBQUNGO0FBQ3JDO0FBQ0E7QUFDTztBQUNQLFNBQVMsK0NBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCLDBFQUE4QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBFQUE4QjtBQUNuRCxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUMscURBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0RBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQXVCO0FBQy9DLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdEQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0RBQXVCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQXVCO0FBQy9DLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsUkE7QUFDQTtBQUNBO0FBQ0E7QUFDdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQiw2REFBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZEQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDeUM7QUFDekM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZXQTtBQUNBO0FBQ0E7QUFDQTtBQUN5QztBQUNOO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0JBQXdCLDRDQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUM0RDtBQUNEO0FBQzNEO0FBQ0E7QUFDQSx5QkFBeUIsOERBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSkFBZ0o7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFNBQVM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0RUFBK0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyRUFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwWUE7QUFDQTtBQUNBO0FBQ0E7QUFDK0M7QUFDdUI7QUFDL0Q7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVEQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBLG1DQUFtQyw4RUFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnREFBZ0QsRUFBRSxJQUFJO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsSUFBSSxNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDcUU7QUFDOUQ7QUFDUDtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZFQUFtQjtBQUM3QztBQUNBLHdCQUF3Qix5Q0FBeUM7QUFDakU7QUFDQTtBQUNBLCtDQUErQztBQUMvQyx3QkFBd0IsdUNBQXVDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsZ0JBQWdCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN2UUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix1QkFBdUI7QUFDdkIsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsNEJBQTRCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQzJEO0FBQ0k7QUFDSjtBQUNUO0FBQ0g7QUFDTjtBQUNjO0FBQzBCO0FBQ0M7QUFDMUI7QUFDeUI7QUFDWDtBQUNmO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzRUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtRUFBYSxrQkFBa0IsK0VBQXlCO0FBQ2pGO0FBQ0EsdUJBQXVCLGlEQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3REFBd0Q7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsOERBQThEO0FBQzdHLDZDQUE2QywwREFBMEQ7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUVBQW9CO0FBQ2pDO0FBQ0E7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDBEQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywrREFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpRUFBUztBQUM3QjtBQUNBLDJCQUEyQiwwRUFBOEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5REFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFFQUFVO0FBQzFDLGtEQUFrRCxzREFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlDQUFpQyxzRUFBc0U7QUFDckk7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9FQUFZO0FBQy9CLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDRCQUE0QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw4REFBOEQ7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0hBQTZDO0FBQ3RFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxRUFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFFQUF1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsK0JBQStCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvRUFBYyxHQUFHLG1GQUFtQjtBQUN4Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3plQTtBQUNBO0FBQ0E7QUFDQTtBQUMrRTtBQUN2QjtBQUNJO0FBQ1Y7QUFDSDtBQUNOO0FBQ1E7QUFDUjtBQUNlO0FBQ2pEO0FBQ1A7QUFDQSxlQUFlLGtFQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlGQUF1QjtBQUN4RCxpQkFBaUIsMERBQU87QUFDeEIsaUJBQWlCLHdEQUF1QjtBQUN4QztBQUNBLGtCQUFrQix1REFBUTtBQUMxQixlQUFlLGlEQUFLO0FBQ3BCLG1CQUFtQix5REFBUztBQUM1Qiw0QkFBNEIsbUVBQWtDO0FBQzlELHdCQUF3QiwrREFBOEI7QUFDdEQsbUJBQW1CLDBEQUF5QjtBQUM1QyxhQUFhLG9EQUFHO0FBQ2hCLGVBQWUsaURBQUs7QUFDcEI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9EQUFvRDtBQUM5QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvRUFBb0U7QUFDOUQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDMUM7QUFDUDtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBFQUEwRTtBQUMzRTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNERBQTREO0FBQ3REO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtEO0FBQ25EO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUNwQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUNsQztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwRUFBMEU7QUFDM0U7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDeEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUNoRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDaEM7QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUMxQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Q7QUFDbkQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUMxQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0REFBNEQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUMxQjtBQUNQO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzRUFBc0U7QUFDdkU7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3REFBd0Q7QUFDekQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdnlCekM7QUFDQTtBQUNBO0FBQ0E7QUFDd0Q7QUFDakQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4REFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhEQUFRO0FBQ3hCLGdCQUFnQiw4REFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4REFBUTtBQUM3QixjQUFjLDhEQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhEQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O1VDdElBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTtXQUNBLENBQUM7Ozs7O1dDUEQ7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7Ozs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDMkU7QUFDRTtBQUM3RTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUZBQWtCO0FBQy9DO0FBQ0EsS0FBSyxnQkFBZ0Isc0ZBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbi1sYW5nLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9hcnJheXMuanMiLCJ3ZWJwYWNrOi8vbi1sYW5nLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9jYW5jZWxsYXRpb24uanMiLCJ3ZWJwYWNrOi8vbi1sYW5nLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9kaWZmL2RpZmYuanMiLCJ3ZWJwYWNrOi8vbi1sYW5nLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9kaWZmL2RpZmZDaGFuZ2UuanMiLCJ3ZWJwYWNrOi8vbi1sYW5nLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vbi1sYW5nLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9ldmVudC5qcyIsIndlYnBhY2s6Ly9uLWxhbmctZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2hhc2guanMiLCJ3ZWJwYWNrOi8vbi1sYW5nLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9uLWxhbmctZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2tleUNvZGVzLmpzIiwid2VicGFjazovL24tbGFuZy1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vbGlmZWN5Y2xlLmpzIiwid2VicGFjazovL24tbGFuZy1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vbGlua2VkTGlzdC5qcyIsIndlYnBhY2s6Ly9uLWxhbmctZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3BhdGguanMiLCJ3ZWJwYWNrOi8vbi1sYW5nLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9wbGF0Zm9ybS5qcyIsIndlYnBhY2s6Ly9uLWxhbmctZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3Byb2Nlc3MuanMiLCJ3ZWJwYWNrOi8vbi1sYW5nLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9zdHJpbmdzLmpzIiwid2VicGFjazovL24tbGFuZy1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vdHlwZXMuanMiLCJ3ZWJwYWNrOi8vbi1sYW5nLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi91aW50LmpzIiwid2VicGFjazovL24tbGFuZy1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vdXJpLmpzIiwid2VicGFjazovL24tbGFuZy1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vd29ya2VyL3NpbXBsZVdvcmtlci5qcyIsIndlYnBhY2s6Ly9uLWxhbmctZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS9jaGFyYWN0ZXJDbGFzc2lmaWVyLmpzIiwid2VicGFjazovL24tbGFuZy1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3Bvc2l0aW9uLmpzIiwid2VicGFjazovL24tbGFuZy1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3JhbmdlLmpzIiwid2VicGFjazovL24tbGFuZy1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3NlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9uLWxhbmctZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS90b2tlbi5qcyIsIndlYnBhY2s6Ly9uLWxhbmctZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vZGlmZi9kaWZmQ29tcHV0ZXIuanMiLCJ3ZWJwYWNrOi8vbi1sYW5nLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL21vZGVsL21pcnJvclRleHRNb2RlbC5qcyIsIndlYnBhY2s6Ly9uLWxhbmctZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvd29yZEhlbHBlci5qcyIsIndlYnBhY2s6Ly9uLWxhbmctZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZXMvbGlua0NvbXB1dGVyLmpzIiwid2VicGFjazovL24tbGFuZy1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2Rlcy9zdXBwb3J0cy9pbnBsYWNlUmVwbGFjZVN1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vbi1sYW5nLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2VkaXRvclNpbXBsZVdvcmtlci5qcyIsIndlYnBhY2s6Ly9uLWxhbmctZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc3RhbmRhbG9uZS9zdGFuZGFsb25lQmFzZS5qcyIsIndlYnBhY2s6Ly9uLWxhbmctZWRpdG9yLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc3RhbmRhbG9uZS9zdGFuZGFsb25lRW51bXMuanMiLCJ3ZWJwYWNrOi8vbi1sYW5nLWVkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3ZpZXdNb2RlbC9wcmVmaXhTdW1Db21wdXRlci5qcyIsIndlYnBhY2s6Ly9uLWxhbmctZWRpdG9yL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL24tbGFuZy1lZGl0b3Ivd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL24tbGFuZy1lZGl0b3Ivd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9uLWxhbmctZWRpdG9yL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vbi1sYW5nLWVkaXRvci93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL24tbGFuZy1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2VkaXRvci53b3JrZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS5cclxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheS5cclxuICogQHBhcmFtIG4gV2hpY2ggZWxlbWVudCBmcm9tIHRoZSBlbmQgKGRlZmF1bHQgaXMgemVybykuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdGFpbChhcnJheSwgbiA9IDApIHtcclxuICAgIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAoMSArIG4pXTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdGFpbDIoYXJyKSB7XHJcbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YWlsIGNhbGwnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBbYXJyLnNsaWNlKDAsIGFyci5sZW5ndGggLSAxKSwgYXJyW2Fyci5sZW5ndGggLSAxXV07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhvbmUsIG90aGVyLCBpdGVtRXF1YWxzID0gKGEsIGIpID0+IGEgPT09IGIpIHtcclxuICAgIGlmIChvbmUgPT09IG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoIW9uZSB8fCAhb3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAob25lLmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG9uZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmICghaXRlbUVxdWFscyhvbmVbaV0sIG90aGVyW2ldKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaChhcnJheSwga2V5LCBjb21wYXJhdG9yKSB7XHJcbiAgICBsZXQgbG93ID0gMCwgaGlnaCA9IGFycmF5Lmxlbmd0aCAtIDE7XHJcbiAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcclxuICAgICAgICBjb25zdCBtaWQgPSAoKGxvdyArIGhpZ2gpIC8gMikgfCAwO1xyXG4gICAgICAgIGNvbnN0IGNvbXAgPSBjb21wYXJhdG9yKGFycmF5W21pZF0sIGtleSk7XHJcbiAgICAgICAgaWYgKGNvbXAgPCAwKSB7XHJcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbXAgPiAwKSB7XHJcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQgLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1pZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLShsb3cgKyAxKTtcclxufVxyXG4vKipcclxuICogVGFrZXMgYSBzb3J0ZWQgYXJyYXkgYW5kIGEgZnVuY3Rpb24gcC4gVGhlIGFycmF5IGlzIHNvcnRlZCBpbiBzdWNoIGEgd2F5IHRoYXQgYWxsIGVsZW1lbnRzIHdoZXJlIHAoeCkgaXMgZmFsc2VcclxuICogYXJlIGxvY2F0ZWQgYmVmb3JlIGFsbCBlbGVtZW50cyB3aGVyZSBwKHgpIGlzIHRydWUuXHJcbiAqIEByZXR1cm5zIHRoZSBsZWFzdCB4IGZvciB3aGljaCBwKHgpIGlzIHRydWUgb3IgYXJyYXkubGVuZ3RoIGlmIG5vIGVsZW1lbnQgZnVsbGZpbGxzIHRoZSBnaXZlbiBmdW5jdGlvbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kRmlyc3RJblNvcnRlZChhcnJheSwgcCkge1xyXG4gICAgbGV0IGxvdyA9IDAsIGhpZ2ggPSBhcnJheS5sZW5ndGg7XHJcbiAgICBpZiAoaGlnaCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiAwOyAvLyBubyBjaGlsZHJlblxyXG4gICAgfVxyXG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcclxuICAgICAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xyXG4gICAgICAgIGlmIChwKGFycmF5W21pZF0pKSB7XHJcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBsb3c7XHJcbn1cclxuLyoqXHJcbiAqIExpa2UgYEFycmF5I3NvcnRgIGJ1dCBhbHdheXMgc3RhYmxlLiBVc3VhbGx5IHJ1bnMgYSBsaXR0bGUgc2xvd2VyIGB0aGFuIEFycmF5I3NvcnRgXHJcbiAqIHNvIG9ubHkgdXNlIHRoaXMgd2hlbiBhY3R1YWxseSBuZWVkaW5nIHN0YWJsZSBzb3J0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU29ydChkYXRhLCBjb21wYXJlKSB7XHJcbiAgICBfc29ydChkYXRhLCBjb21wYXJlLCAwLCBkYXRhLmxlbmd0aCAtIDEsIFtdKTtcclxuICAgIHJldHVybiBkYXRhO1xyXG59XHJcbmZ1bmN0aW9uIF9tZXJnZShhLCBjb21wYXJlLCBsbywgbWlkLCBoaSwgYXV4KSB7XHJcbiAgICBsZXQgbGVmdElkeCA9IGxvLCByaWdodElkeCA9IG1pZCArIDE7XHJcbiAgICBmb3IgKGxldCBpID0gbG87IGkgPD0gaGk7IGkrKykge1xyXG4gICAgICAgIGF1eFtpXSA9IGFbaV07XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gbG87IGkgPD0gaGk7IGkrKykge1xyXG4gICAgICAgIGlmIChsZWZ0SWR4ID4gbWlkKSB7XHJcbiAgICAgICAgICAgIC8vIGxlZnQgc2lkZSBjb25zdW1lZFxyXG4gICAgICAgICAgICBhW2ldID0gYXV4W3JpZ2h0SWR4KytdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyaWdodElkeCA+IGhpKSB7XHJcbiAgICAgICAgICAgIC8vIHJpZ2h0IHNpZGUgY29uc3VtZWRcclxuICAgICAgICAgICAgYVtpXSA9IGF1eFtsZWZ0SWR4KytdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb21wYXJlKGF1eFtyaWdodElkeF0sIGF1eFtsZWZ0SWR4XSkgPCAwKSB7XHJcbiAgICAgICAgICAgIC8vIHJpZ2h0IGVsZW1lbnQgaXMgbGVzcyAtPiBjb21lcyBmaXJzdFxyXG4gICAgICAgICAgICBhW2ldID0gYXV4W3JpZ2h0SWR4KytdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbGVmdCBlbGVtZW50IGNvbWVzIGZpcnN0IChsZXNzIG9yIGVxdWFsKVxyXG4gICAgICAgICAgICBhW2ldID0gYXV4W2xlZnRJZHgrK107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIF9zb3J0KGEsIGNvbXBhcmUsIGxvLCBoaSwgYXV4KSB7XHJcbiAgICBpZiAoaGkgPD0gbG8pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBtaWQgPSBsbyArICgoaGkgLSBsbykgLyAyKSB8IDA7XHJcbiAgICBfc29ydChhLCBjb21wYXJlLCBsbywgbWlkLCBhdXgpO1xyXG4gICAgX3NvcnQoYSwgY29tcGFyZSwgbWlkICsgMSwgaGksIGF1eCk7XHJcbiAgICBpZiAoY29tcGFyZShhW21pZF0sIGFbbWlkICsgMV0pIDw9IDApIHtcclxuICAgICAgICAvLyBsZWZ0IGFuZCByaWdodCBhcmUgc29ydGVkIGFuZCBpZiB0aGUgbGFzdC1sZWZ0IGVsZW1lbnQgaXMgbGVzc1xyXG4gICAgICAgIC8vIG9yIGVxdWFscyB0aGFuIHRoZSBmaXJzdC1yaWdodCBlbGVtZW50IHRoZXJlIGlzIG5vdGhpbmcgZWxzZVxyXG4gICAgICAgIC8vIHRvIGRvXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgX21lcmdlKGEsIGNvbXBhcmUsIGxvLCBtaWQsIGhpLCBhdXgpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBncm91cEJ5KGRhdGEsIGNvbXBhcmUpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgbGV0IGN1cnJlbnRHcm91cCA9IHVuZGVmaW5lZDtcclxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBtZXJnZVNvcnQoZGF0YS5zbGljZSgwKSwgY29tcGFyZSkpIHtcclxuICAgICAgICBpZiAoIWN1cnJlbnRHcm91cCB8fCBjb21wYXJlKGN1cnJlbnRHcm91cFswXSwgZWxlbWVudCkgIT09IDApIHtcclxuICAgICAgICAgICAgY3VycmVudEdyb3VwID0gW2VsZW1lbnRdO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXJyZW50R3JvdXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudEdyb3VwLnB1c2goZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgTmV3IGFycmF5IHdpdGggYWxsIGZhbHN5IHZhbHVlcyByZW1vdmVkLiBUaGUgb3JpZ2luYWwgYXJyYXkgSVMgTk9UIG1vZGlmaWVkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvYWxlc2NlKGFycmF5KSB7XHJcbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGUgPT4gISFlKTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgZmFsc2UgaWYgdGhlIHByb3ZpZGVkIG9iamVjdCBpcyBhbiBhcnJheSBhbmQgbm90IGVtcHR5LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmFsc3lPckVtcHR5KG9iaikge1xyXG4gICAgcmV0dXJuICFBcnJheS5pc0FycmF5KG9iaikgfHwgb2JqLmxlbmd0aCA9PT0gMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaXNOb25FbXB0eUFycmF5KG9iaikge1xyXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID4gMDtcclxufVxyXG4vKipcclxuICogUmVtb3ZlcyBkdXBsaWNhdGVzIGZyb20gdGhlIGdpdmVuIGFycmF5LiBUaGUgb3B0aW9uYWwga2V5Rm4gYWxsb3dzIHRvIHNwZWNpZnlcclxuICogaG93IGVsZW1lbnRzIGFyZSBjaGVja2VkIGZvciBlcXVhbG5lc3MgYnkgcmV0dXJuaW5nIGEgdW5pcXVlIHN0cmluZyBmb3IgZWFjaC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXN0aW5jdChhcnJheSwga2V5Rm4pIHtcclxuICAgIGlmICgha2V5Rm4pIHtcclxuICAgICAgICByZXR1cm4gYXJyYXkuZmlsdGVyKChlbGVtZW50LCBwb3NpdGlvbikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihlbGVtZW50KSA9PT0gcG9zaXRpb247XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHJldHVybiBhcnJheS5maWx0ZXIoKGVsZW0pID0+IHtcclxuICAgICAgICBjb25zdCBrZXkgPSBrZXlGbihlbGVtKTtcclxuICAgICAgICBpZiAoc2VlbltrZXldKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2VlbltrZXldID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBkaXN0aW5jdEVTNihhcnJheSkge1xyXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcclxuICAgIHJldHVybiBhcnJheS5maWx0ZXIoZWxlbWVudCA9PiB7XHJcbiAgICAgICAgaWYgKHNlZW4uaGFzKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2Vlbi5hZGQoZWxlbWVudCk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogQGRlcHJlY2F0ZWQgRVM2OiB1c2UgYEFycmF5LmZpbmRJbmRleGBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaXJzdEluZGV4KGFycmF5LCBmbikge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpXTtcclxuICAgICAgICBpZiAoZm4oZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBmaXJzdChhcnJheSwgZm4sIG5vdEZvdW5kVmFsdWUgPSB1bmRlZmluZWQpIHtcclxuICAgIGNvbnN0IGluZGV4ID0gZmlyc3RJbmRleChhcnJheSwgZm4pO1xyXG4gICAgcmV0dXJuIGluZGV4IDwgMCA/IG5vdEZvdW5kVmFsdWUgOiBhcnJheVtpbmRleF07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0T3JEZWZhdWx0KGFycmF5LCBub3RGb3VuZFZhbHVlKSB7XHJcbiAgICByZXR1cm4gYXJyYXkubGVuZ3RoID4gMCA/IGFycmF5WzBdIDogbm90Rm91bmRWYWx1ZTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlbihhcnIpIHtcclxuICAgIHJldHVybiBbXS5jb25jYXQoLi4uYXJyKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2UoYXJnLCB0bykge1xyXG4gICAgbGV0IGZyb20gPSB0eXBlb2YgdG8gPT09ICdudW1iZXInID8gYXJnIDogMDtcclxuICAgIGlmICh0eXBlb2YgdG8gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgZnJvbSA9IGFyZztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZyb20gPSAwO1xyXG4gICAgICAgIHRvID0gYXJnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBpZiAoZnJvbSA8PSB0bykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA+IHRvOyBpLS0pIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogSW5zZXJ0IGBpbnNlcnRBcnJgIGluc2lkZSBgdGFyZ2V0YCBhdCBgaW5zZXJ0SW5kZXhgLlxyXG4gKiBQbGVhc2UgZG9uJ3QgdG91Y2ggdW5sZXNzIHlvdSB1bmRlcnN0YW5kIGh0dHBzOi8vanNwZXJmLmNvbS9pbnNlcnRpbmctYW4tYXJyYXktd2l0aGluLWFuLWFycmF5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlJbnNlcnQodGFyZ2V0LCBpbnNlcnRJbmRleCwgaW5zZXJ0QXJyKSB7XHJcbiAgICBjb25zdCBiZWZvcmUgPSB0YXJnZXQuc2xpY2UoMCwgaW5zZXJ0SW5kZXgpO1xyXG4gICAgY29uc3QgYWZ0ZXIgPSB0YXJnZXQuc2xpY2UoaW5zZXJ0SW5kZXgpO1xyXG4gICAgcmV0dXJuIGJlZm9yZS5jb25jYXQoaW5zZXJ0QXJyLCBhZnRlcik7XHJcbn1cclxuLyoqXHJcbiAqIFB1c2hlcyBhbiBlbGVtZW50IHRvIHRoZSBzdGFydCBvZiB0aGUgYXJyYXksIGlmIGZvdW5kLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHB1c2hUb1N0YXJ0KGFyciwgdmFsdWUpIHtcclxuICAgIGNvbnN0IGluZGV4ID0gYXJyLmluZGV4T2YodmFsdWUpO1xyXG4gICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICBhcnIudW5zaGlmdCh2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFB1c2hlcyBhbiBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LCBpZiBmb3VuZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwdXNoVG9FbmQoYXJyLCB2YWx1ZSkge1xyXG4gICAgY29uc3QgaW5kZXggPSBhcnIuaW5kZXhPZih2YWx1ZSk7XHJcbiAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIGFyci5wdXNoKHZhbHVlKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gYXNBcnJheSh4KSB7XHJcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh4KSA/IHggOiBbeF07XHJcbn1cclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IEVtaXR0ZXIsIEV2ZW50IH0gZnJvbSAnLi9ldmVudC5qcyc7XHJcbmNvbnN0IHNob3J0Y3V0RXZlbnQgPSBPYmplY3QuZnJlZXplKGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChjYWxsYmFjay5iaW5kKGNvbnRleHQpLCAwKTtcclxuICAgIHJldHVybiB7IGRpc3Bvc2UoKSB7IGNsZWFyVGltZW91dChoYW5kbGUpOyB9IH07XHJcbn0pO1xyXG5leHBvcnQgdmFyIENhbmNlbGxhdGlvblRva2VuO1xyXG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblRva2VuKSB7XHJcbiAgICBmdW5jdGlvbiBpc0NhbmNlbGxhdGlvblRva2VuKHRoaW5nKSB7XHJcbiAgICAgICAgaWYgKHRoaW5nID09PSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lIHx8IHRoaW5nID09PSBDYW5jZWxsYXRpb25Ub2tlbi5DYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGluZyBpbnN0YW5jZW9mIE11dGFibGVUb2tlbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGluZyB8fCB0eXBlb2YgdGhpbmcgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGluZy5pc0NhbmNlbGxhdGlvblJlcXVlc3RlZCA9PT0gJ2Jvb2xlYW4nXHJcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGluZy5vbkNhbmNlbGxhdGlvblJlcXVlc3RlZCA9PT0gJ2Z1bmN0aW9uJztcclxuICAgIH1cclxuICAgIENhbmNlbGxhdGlvblRva2VuLmlzQ2FuY2VsbGF0aW9uVG9rZW4gPSBpc0NhbmNlbGxhdGlvblRva2VuO1xyXG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSA9IE9iamVjdC5mcmVlemUoe1xyXG4gICAgICAgIGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBmYWxzZSxcclxuICAgICAgICBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZDogRXZlbnQuTm9uZVxyXG4gICAgfSk7XHJcbiAgICBDYW5jZWxsYXRpb25Ub2tlbi5DYW5jZWxsZWQgPSBPYmplY3QuZnJlZXplKHtcclxuICAgICAgICBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZDogdHJ1ZSxcclxuICAgICAgICBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZDogc2hvcnRjdXRFdmVudFxyXG4gICAgfSk7XHJcbn0pKENhbmNlbGxhdGlvblRva2VuIHx8IChDYW5jZWxsYXRpb25Ub2tlbiA9IHt9KSk7XHJcbmNsYXNzIE11dGFibGVUb2tlbiB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2VtaXR0ZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgY2FuY2VsKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5faXNDYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5faXNDYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNDYW5jZWxsZWQ7XHJcbiAgICB9XHJcbiAgICBnZXQgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzQ2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaG9ydGN1dEV2ZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2VtaXR0ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmV2ZW50O1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZW1pdHRlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcclxuICAgICAgICB0aGlzLl90b2tlbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9wYXJlbnRMaXN0ZW5lciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9wYXJlbnRMaXN0ZW5lciA9IHBhcmVudCAmJiBwYXJlbnQub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQodGhpcy5jYW5jZWwsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHRva2VuKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcclxuICAgICAgICAgICAgLy8gYmUgbGF6eSBhbmQgY3JlYXRlIHRoZSB0b2tlbiBvbmx5IHdoZW5cclxuICAgICAgICAgICAgLy8gYWN0dWFsbHkgbmVlZGVkXHJcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gbmV3IE11dGFibGVUb2tlbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW47XHJcbiAgICB9XHJcbiAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xyXG4gICAgICAgICAgICAvLyBzYXZlIGFuIG9iamVjdCBieSByZXR1cm5pbmcgdGhlIGRlZmF1bHRcclxuICAgICAgICAgICAgLy8gY2FuY2VsbGVkIHRva2VuIHdoZW4gY2FuY2VsbGF0aW9uIGhhcHBlbnNcclxuICAgICAgICAgICAgLy8gYmVmb3JlIHNvbWVvbmUgYXNrcyBmb3IgdGhlIHRva2VuXHJcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLl90b2tlbiBpbnN0YW5jZW9mIE11dGFibGVUb2tlbikge1xyXG4gICAgICAgICAgICAvLyBhY3R1YWxseSBjYW5jZWxcclxuICAgICAgICAgICAgdGhpcy5fdG9rZW4uY2FuY2VsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGlzcG9zZShjYW5jZWwgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmIChjYW5jZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudExpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudExpc3RlbmVyLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xyXG4gICAgICAgICAgICAvLyBlbnN1cmUgdG8gaW5pdGlhbGl6ZSB3aXRoIGFuIGVtcHR5IHRva2VuIGlmIHdlIGhhZCBub25lXHJcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fdG9rZW4gaW5zdGFuY2VvZiBNdXRhYmxlVG9rZW4pIHtcclxuICAgICAgICAgICAgLy8gYWN0dWFsbHkgZGlzcG9zZVxyXG4gICAgICAgICAgICB0aGlzLl90b2tlbi5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBEaWZmQ2hhbmdlIH0gZnJvbSAnLi9kaWZmQ2hhbmdlLmpzJztcclxuaW1wb3J0IHsgc3RyaW5nSGFzaCB9IGZyb20gJy4uL2hhc2guanMnO1xyXG5leHBvcnQgY2xhc3MgU3RyaW5nRGlmZlNlcXVlbmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgfVxyXG4gICAgZ2V0RWxlbWVudHMoKSB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2U7XHJcbiAgICAgICAgY29uc3QgY2hhcmFjdGVycyA9IG5ldyBJbnQzMkFycmF5KHNvdXJjZS5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgY2hhcmFjdGVyc1tpXSA9IHNvdXJjZS5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hhcmFjdGVycztcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nRGlmZihvcmlnaW5hbCwgbW9kaWZpZWQsIHByZXR0eSkge1xyXG4gICAgcmV0dXJuIG5ldyBMY3NEaWZmKG5ldyBTdHJpbmdEaWZmU2VxdWVuY2Uob3JpZ2luYWwpLCBuZXcgU3RyaW5nRGlmZlNlcXVlbmNlKG1vZGlmaWVkKSkuQ29tcHV0ZURpZmYocHJldHR5KS5jaGFuZ2VzO1xyXG59XHJcbi8vXHJcbi8vIFRoZSBjb2RlIGJlbG93IGhhcyBiZWVuIHBvcnRlZCBmcm9tIGEgQyMgaW1wbGVtZW50YXRpb24gaW4gVlNcclxuLy9cclxuZXhwb3J0IGNsYXNzIERlYnVnIHtcclxuICAgIHN0YXRpYyBBc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCFjb25kaXRpb24pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgTXlBcnJheSB7XHJcbiAgICAvKipcclxuICAgICAqIENvcGllcyBhIHJhbmdlIG9mIGVsZW1lbnRzIGZyb20gYW4gQXJyYXkgc3RhcnRpbmcgYXQgdGhlIHNwZWNpZmllZCBzb3VyY2UgaW5kZXggYW5kIHBhc3Rlc1xyXG4gICAgICogdGhlbSB0byBhbm90aGVyIEFycmF5IHN0YXJ0aW5nIGF0IHRoZSBzcGVjaWZpZWQgZGVzdGluYXRpb24gaW5kZXguIFRoZSBsZW5ndGggYW5kIHRoZSBpbmRleGVzXHJcbiAgICAgKiBhcmUgc3BlY2lmaWVkIGFzIDY0LWJpdCBpbnRlZ2Vycy5cclxuICAgICAqIHNvdXJjZUFycmF5OlxyXG4gICAgICpcdFx0VGhlIEFycmF5IHRoYXQgY29udGFpbnMgdGhlIGRhdGEgdG8gY29weS5cclxuICAgICAqIHNvdXJjZUluZGV4OlxyXG4gICAgICpcdFx0QSA2NC1iaXQgaW50ZWdlciB0aGF0IHJlcHJlc2VudHMgdGhlIGluZGV4IGluIHRoZSBzb3VyY2VBcnJheSBhdCB3aGljaCBjb3B5aW5nIGJlZ2lucy5cclxuICAgICAqIGRlc3RpbmF0aW9uQXJyYXk6XHJcbiAgICAgKlx0XHRUaGUgQXJyYXkgdGhhdCByZWNlaXZlcyB0aGUgZGF0YS5cclxuICAgICAqIGRlc3RpbmF0aW9uSW5kZXg6XHJcbiAgICAgKlx0XHRBIDY0LWJpdCBpbnRlZ2VyIHRoYXQgcmVwcmVzZW50cyB0aGUgaW5kZXggaW4gdGhlIGRlc3RpbmF0aW9uQXJyYXkgYXQgd2hpY2ggc3RvcmluZyBiZWdpbnMuXHJcbiAgICAgKiBsZW5ndGg6XHJcbiAgICAgKlx0XHRBIDY0LWJpdCBpbnRlZ2VyIHRoYXQgcmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGNvcHkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBDb3B5KHNvdXJjZUFycmF5LCBzb3VyY2VJbmRleCwgZGVzdGluYXRpb25BcnJheSwgZGVzdGluYXRpb25JbmRleCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkZXN0aW5hdGlvbkFycmF5W2Rlc3RpbmF0aW9uSW5kZXggKyBpXSA9IHNvdXJjZUFycmF5W3NvdXJjZUluZGV4ICsgaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIENvcHkyKHNvdXJjZUFycmF5LCBzb3VyY2VJbmRleCwgZGVzdGluYXRpb25BcnJheSwgZGVzdGluYXRpb25JbmRleCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkZXN0aW5hdGlvbkFycmF5W2Rlc3RpbmF0aW9uSW5kZXggKyBpXSA9IHNvdXJjZUFycmF5W3NvdXJjZUluZGV4ICsgaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIHV0aWxpdHkgY2xhc3Mgd2hpY2ggaGVscHMgdG8gY3JlYXRlIHRoZSBzZXQgb2YgRGlmZkNoYW5nZXMgZnJvbVxyXG4gKiBhIGRpZmZlcmVuY2Ugb3BlcmF0aW9uLiBUaGlzIGNsYXNzIGFjY2VwdHMgb3JpZ2luYWwgRGlmZkVsZW1lbnRzIGFuZFxyXG4gKiBtb2RpZmllZCBEaWZmRWxlbWVudHMgdGhhdCBhcmUgaW52b2x2ZWQgaW4gYSBwYXJ0aWN1bGFyIGNoYW5nZS4gVGhlXHJcbiAqIE1hcmt0TmV4dENoYW5nZSgpIG1ldGhvZCBjYW4gYmUgY2FsbGVkIHRvIG1hcmsgdGhlIHNlcGFyYXRpb24gYmV0d2VlblxyXG4gKiBkaXN0aW5jdCBjaGFuZ2VzLiBBdCB0aGUgZW5kLCB0aGUgQ2hhbmdlcyBwcm9wZXJ0eSBjYW4gYmUgY2FsbGVkIHRvIHJldHJpZXZlXHJcbiAqIHRoZSBjb25zdHJ1Y3RlZCBjaGFuZ2VzLlxyXG4gKi9cclxuY2xhc3MgRGlmZkNoYW5nZUhlbHBlciB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRGlmZkNoYW5nZUhlbHBlciBmb3IgdGhlIGdpdmVuIERpZmZTZXF1ZW5jZXMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMubV9jaGFuZ2VzID0gW107XHJcbiAgICAgICAgdGhpcy5tX29yaWdpbmFsU3RhcnQgPSAxMDczNzQxODI0IC8qIE1BWF9TQUZFX1NNQUxMX0lOVEVHRVIgKi87XHJcbiAgICAgICAgdGhpcy5tX21vZGlmaWVkU3RhcnQgPSAxMDczNzQxODI0IC8qIE1BWF9TQUZFX1NNQUxMX0lOVEVHRVIgKi87XHJcbiAgICAgICAgdGhpcy5tX29yaWdpbmFsQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMubV9tb2RpZmllZENvdW50ID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWFya3MgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV4dCBjaGFuZ2UgaW4gdGhlIHNldCBvZiBkaWZmZXJlbmNlcy5cclxuICAgICAqL1xyXG4gICAgTWFya05leHRDaGFuZ2UoKSB7XHJcbiAgICAgICAgLy8gT25seSBhZGQgdG8gdGhlIGxpc3QgaWYgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGFkZFxyXG4gICAgICAgIGlmICh0aGlzLm1fb3JpZ2luYWxDb3VudCA+IDAgfHwgdGhpcy5tX21vZGlmaWVkQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV3IGNoYW5nZSB0byBvdXIgbGlzdFxyXG4gICAgICAgICAgICB0aGlzLm1fY2hhbmdlcy5wdXNoKG5ldyBEaWZmQ2hhbmdlKHRoaXMubV9vcmlnaW5hbFN0YXJ0LCB0aGlzLm1fb3JpZ2luYWxDb3VudCwgdGhpcy5tX21vZGlmaWVkU3RhcnQsIHRoaXMubV9tb2RpZmllZENvdW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlc2V0IGZvciB0aGUgbmV4dCBjaGFuZ2VcclxuICAgICAgICB0aGlzLm1fb3JpZ2luYWxDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5tX21vZGlmaWVkQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMubV9vcmlnaW5hbFN0YXJ0ID0gMTA3Mzc0MTgyNCAvKiBNQVhfU0FGRV9TTUFMTF9JTlRFR0VSICovO1xyXG4gICAgICAgIHRoaXMubV9tb2RpZmllZFN0YXJ0ID0gMTA3Mzc0MTgyNCAvKiBNQVhfU0FGRV9TTUFMTF9JTlRFR0VSICovO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBvcmlnaW5hbCBlbGVtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiB0byB0aGUgZWxlbWVudHNcclxuICAgICAqIGFmZmVjdGVkIGJ5IHRoZSBjdXJyZW50IGNoYW5nZS4gVGhlIG1vZGlmaWVkIGluZGV4IGdpdmVzIGNvbnRleHRcclxuICAgICAqIHRvIHRoZSBjaGFuZ2UgcG9zaXRpb24gd2l0aCByZXNwZWN0IHRvIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZS5cclxuICAgICAqIEBwYXJhbSBvcmlnaW5hbEluZGV4IFRoZSBpbmRleCBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudCB0byBhZGQuXHJcbiAgICAgKiBAcGFyYW0gbW9kaWZpZWRJbmRleCBUaGUgaW5kZXggb2YgdGhlIG1vZGlmaWVkIGVsZW1lbnQgdGhhdCBwcm92aWRlcyBjb3JyZXNwb25kaW5nIHBvc2l0aW9uIGluIHRoZSBtb2RpZmllZCBzZXF1ZW5jZS5cclxuICAgICAqL1xyXG4gICAgQWRkT3JpZ2luYWxFbGVtZW50KG9yaWdpbmFsSW5kZXgsIG1vZGlmaWVkSW5kZXgpIHtcclxuICAgICAgICAvLyBUaGUgJ3RydWUnIHN0YXJ0IGluZGV4IGlzIHRoZSBzbWFsbGVzdCBvZiB0aGUgb25lcyB3ZSd2ZSBzZWVuXHJcbiAgICAgICAgdGhpcy5tX29yaWdpbmFsU3RhcnQgPSBNYXRoLm1pbih0aGlzLm1fb3JpZ2luYWxTdGFydCwgb3JpZ2luYWxJbmRleCk7XHJcbiAgICAgICAgdGhpcy5tX21vZGlmaWVkU3RhcnQgPSBNYXRoLm1pbih0aGlzLm1fbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRJbmRleCk7XHJcbiAgICAgICAgdGhpcy5tX29yaWdpbmFsQ291bnQrKztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgbW9kaWZpZWQgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gdG8gdGhlIGVsZW1lbnRzXHJcbiAgICAgKiBhZmZlY3RlZCBieSB0aGUgY3VycmVudCBjaGFuZ2UuIFRoZSBvcmlnaW5hbCBpbmRleCBnaXZlcyBjb250ZXh0XHJcbiAgICAgKiB0byB0aGUgY2hhbmdlIHBvc2l0aW9uIHdpdGggcmVzcGVjdCB0byB0aGUgbW9kaWZpZWQgc2VxdWVuY2UuXHJcbiAgICAgKiBAcGFyYW0gb3JpZ2luYWxJbmRleCBUaGUgaW5kZXggb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnQgdGhhdCBwcm92aWRlcyBjb3JyZXNwb25kaW5nIHBvc2l0aW9uIGluIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZS5cclxuICAgICAqIEBwYXJhbSBtb2RpZmllZEluZGV4IFRoZSBpbmRleCBvZiB0aGUgbW9kaWZpZWQgZWxlbWVudCB0byBhZGQuXHJcbiAgICAgKi9cclxuICAgIEFkZE1vZGlmaWVkRWxlbWVudChvcmlnaW5hbEluZGV4LCBtb2RpZmllZEluZGV4KSB7XHJcbiAgICAgICAgLy8gVGhlICd0cnVlJyBzdGFydCBpbmRleCBpcyB0aGUgc21hbGxlc3Qgb2YgdGhlIG9uZXMgd2UndmUgc2VlblxyXG4gICAgICAgIHRoaXMubV9vcmlnaW5hbFN0YXJ0ID0gTWF0aC5taW4odGhpcy5tX29yaWdpbmFsU3RhcnQsIG9yaWdpbmFsSW5kZXgpO1xyXG4gICAgICAgIHRoaXMubV9tb2RpZmllZFN0YXJ0ID0gTWF0aC5taW4odGhpcy5tX21vZGlmaWVkU3RhcnQsIG1vZGlmaWVkSW5kZXgpO1xyXG4gICAgICAgIHRoaXMubV9tb2RpZmllZENvdW50Kys7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhbGwgb2YgdGhlIGNoYW5nZXMgbWFya2VkIGJ5IHRoZSBjbGFzcy5cclxuICAgICAqL1xyXG4gICAgZ2V0Q2hhbmdlcygpIHtcclxuICAgICAgICBpZiAodGhpcy5tX29yaWdpbmFsQ291bnQgPiAwIHx8IHRoaXMubV9tb2RpZmllZENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAvLyBGaW5pc2ggdXAgb24gd2hhdGV2ZXIgaXMgbGVmdFxyXG4gICAgICAgICAgICB0aGlzLk1hcmtOZXh0Q2hhbmdlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm1fY2hhbmdlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGFsbCBvZiB0aGUgY2hhbmdlcyBtYXJrZWQgYnkgdGhlIGNsYXNzIGluIHRoZSByZXZlcnNlIG9yZGVyXHJcbiAgICAgKi9cclxuICAgIGdldFJldmVyc2VDaGFuZ2VzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1fb3JpZ2luYWxDb3VudCA+IDAgfHwgdGhpcy5tX21vZGlmaWVkQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIEZpbmlzaCB1cCBvbiB3aGF0ZXZlciBpcyBsZWZ0XHJcbiAgICAgICAgICAgIHRoaXMuTWFya05leHRDaGFuZ2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tX2NoYW5nZXMucmV2ZXJzZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1fY2hhbmdlcztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGRpZmZlcmVuY2UgYWxnb3JpdGhtIGRlc2NyaWJlZCBpblxyXG4gKiBcIkFuIE8oTkQpIERpZmZlcmVuY2UgQWxnb3JpdGhtIGFuZCBpdHMgdmFyaWF0aW9uc1wiIGJ5IEV1Z2VuZSBXLiBNeWVyc1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExjc0RpZmYge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIHRoZSBEaWZmRmluZGVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsU2VxdWVuY2UsIG1vZGlmaWVkU2VxdWVuY2UsIGNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZSA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLkNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZSA9IGNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZTtcclxuICAgICAgICBjb25zdCBbb3JpZ2luYWxTdHJpbmdFbGVtZW50cywgb3JpZ2luYWxFbGVtZW50c09ySGFzaCwgb3JpZ2luYWxIYXNTdHJpbmdzXSA9IExjc0RpZmYuX2dldEVsZW1lbnRzKG9yaWdpbmFsU2VxdWVuY2UpO1xyXG4gICAgICAgIGNvbnN0IFttb2RpZmllZFN0cmluZ0VsZW1lbnRzLCBtb2RpZmllZEVsZW1lbnRzT3JIYXNoLCBtb2RpZmllZEhhc1N0cmluZ3NdID0gTGNzRGlmZi5fZ2V0RWxlbWVudHMobW9kaWZpZWRTZXF1ZW5jZSk7XHJcbiAgICAgICAgdGhpcy5faGFzU3RyaW5ncyA9IChvcmlnaW5hbEhhc1N0cmluZ3MgJiYgbW9kaWZpZWRIYXNTdHJpbmdzKTtcclxuICAgICAgICB0aGlzLl9vcmlnaW5hbFN0cmluZ0VsZW1lbnRzID0gb3JpZ2luYWxTdHJpbmdFbGVtZW50cztcclxuICAgICAgICB0aGlzLl9vcmlnaW5hbEVsZW1lbnRzT3JIYXNoID0gb3JpZ2luYWxFbGVtZW50c09ySGFzaDtcclxuICAgICAgICB0aGlzLl9tb2RpZmllZFN0cmluZ0VsZW1lbnRzID0gbW9kaWZpZWRTdHJpbmdFbGVtZW50cztcclxuICAgICAgICB0aGlzLl9tb2RpZmllZEVsZW1lbnRzT3JIYXNoID0gbW9kaWZpZWRFbGVtZW50c09ySGFzaDtcclxuICAgICAgICB0aGlzLm1fZm9yd2FyZEhpc3RvcnkgPSBbXTtcclxuICAgICAgICB0aGlzLm1fcmV2ZXJzZUhpc3RvcnkgPSBbXTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfaXNTdHJpbmdBcnJheShhcnIpIHtcclxuICAgICAgICByZXR1cm4gKGFyci5sZW5ndGggPiAwICYmIHR5cGVvZiBhcnJbMF0gPT09ICdzdHJpbmcnKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfZ2V0RWxlbWVudHMoc2VxdWVuY2UpIHtcclxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHNlcXVlbmNlLmdldEVsZW1lbnRzKCk7XHJcbiAgICAgICAgaWYgKExjc0RpZmYuX2lzU3RyaW5nQXJyYXkoZWxlbWVudHMpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhc2hlcyA9IG5ldyBJbnQzMkFycmF5KGVsZW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaGFzaGVzW2ldID0gc3RyaW5nSGFzaChlbGVtZW50c1tpXSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFtlbGVtZW50cywgaGFzaGVzLCB0cnVlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVsZW1lbnRzIGluc3RhbmNlb2YgSW50MzJBcnJheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW1tdLCBlbGVtZW50cywgZmFsc2VdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1tdLCBuZXcgSW50MzJBcnJheShlbGVtZW50cyksIGZhbHNlXTtcclxuICAgIH1cclxuICAgIEVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxJbmRleCwgbmV3SW5kZXgpIHtcclxuICAgICAgICBpZiAodGhpcy5fb3JpZ2luYWxFbGVtZW50c09ySGFzaFtvcmlnaW5hbEluZGV4XSAhPT0gdGhpcy5fbW9kaWZpZWRFbGVtZW50c09ySGFzaFtuZXdJbmRleF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKHRoaXMuX2hhc1N0cmluZ3MgPyB0aGlzLl9vcmlnaW5hbFN0cmluZ0VsZW1lbnRzW29yaWdpbmFsSW5kZXhdID09PSB0aGlzLl9tb2RpZmllZFN0cmluZ0VsZW1lbnRzW25ld0luZGV4XSA6IHRydWUpO1xyXG4gICAgfVxyXG4gICAgT3JpZ2luYWxFbGVtZW50c0FyZUVxdWFsKGluZGV4MSwgaW5kZXgyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX29yaWdpbmFsRWxlbWVudHNPckhhc2hbaW5kZXgxXSAhPT0gdGhpcy5fb3JpZ2luYWxFbGVtZW50c09ySGFzaFtpbmRleDJdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9oYXNTdHJpbmdzID8gdGhpcy5fb3JpZ2luYWxTdHJpbmdFbGVtZW50c1tpbmRleDFdID09PSB0aGlzLl9vcmlnaW5hbFN0cmluZ0VsZW1lbnRzW2luZGV4Ml0gOiB0cnVlKTtcclxuICAgIH1cclxuICAgIE1vZGlmaWVkRWxlbWVudHNBcmVFcXVhbChpbmRleDEsIGluZGV4Mikge1xyXG4gICAgICAgIGlmICh0aGlzLl9tb2RpZmllZEVsZW1lbnRzT3JIYXNoW2luZGV4MV0gIT09IHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2hbaW5kZXgyXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAodGhpcy5faGFzU3RyaW5ncyA/IHRoaXMuX21vZGlmaWVkU3RyaW5nRWxlbWVudHNbaW5kZXgxXSA9PT0gdGhpcy5fbW9kaWZpZWRTdHJpbmdFbGVtZW50c1tpbmRleDJdIDogdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBDb21wdXRlRGlmZihwcmV0dHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fQ29tcHV0ZURpZmYoMCwgdGhpcy5fb3JpZ2luYWxFbGVtZW50c09ySGFzaC5sZW5ndGggLSAxLCAwLCB0aGlzLl9tb2RpZmllZEVsZW1lbnRzT3JIYXNoLmxlbmd0aCAtIDEsIHByZXR0eSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSBvcmlnaW5hbCBhbmQgbW9kaWZpZWQgaW5wdXRcclxuICAgICAqIHNlcXVlbmNlcyBvbiB0aGUgYm91bmRlZCByYW5nZS5cclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSB0d28gaW5wdXQgc2VxdWVuY2VzLlxyXG4gICAgICovXHJcbiAgICBfQ29tcHV0ZURpZmYob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kLCBwcmV0dHkpIHtcclxuICAgICAgICBjb25zdCBxdWl0RWFybHlBcnIgPSBbZmFsc2VdO1xyXG4gICAgICAgIGxldCBjaGFuZ2VzID0gdGhpcy5Db21wdXRlRGlmZlJlY3Vyc2l2ZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQsIHF1aXRFYXJseUFycik7XHJcbiAgICAgICAgaWYgKHByZXR0eSkge1xyXG4gICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGNsZWFuIHVwIHRoZSBjb21wdXRlZCBkaWZmIHRvIGJlIG1vcmUgaW50dWl0aXZlXHJcbiAgICAgICAgICAgIC8vIGJ1dCBpdCB0dXJucyBvdXQgdGhpcyBjYW5ub3QgYmUgZG9uZSBjb3JyZWN0bHkgdW50aWwgdGhlIGVudGlyZSBzZXRcclxuICAgICAgICAgICAgLy8gb2YgZGlmZnMgaGF2ZSBiZWVuIGNvbXB1dGVkXHJcbiAgICAgICAgICAgIGNoYW5nZXMgPSB0aGlzLlByZXR0aWZ5Q2hhbmdlcyhjaGFuZ2VzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcXVpdEVhcmx5OiBxdWl0RWFybHlBcnJbMF0sXHJcbiAgICAgICAgICAgIGNoYW5nZXM6IGNoYW5nZXNcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcml2YXRlIGhlbHBlciBtZXRob2Qgd2hpY2ggY29tcHV0ZXMgdGhlIGRpZmZlcmVuY2VzIG9uIHRoZSBib3VuZGVkIHJhbmdlXHJcbiAgICAgKiByZWN1cnNpdmVseS5cclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSB0d28gaW5wdXQgc2VxdWVuY2VzLlxyXG4gICAgICovXHJcbiAgICBDb21wdXRlRGlmZlJlY3Vyc2l2ZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQsIHF1aXRFYXJseUFycikge1xyXG4gICAgICAgIHF1aXRFYXJseUFyclswXSA9IGZhbHNlO1xyXG4gICAgICAgIC8vIEZpbmQgdGhlIHN0YXJ0IG9mIHRoZSBkaWZmZXJlbmNlc1xyXG4gICAgICAgIHdoaWxlIChvcmlnaW5hbFN0YXJ0IDw9IG9yaWdpbmFsRW5kICYmIG1vZGlmaWVkU3RhcnQgPD0gbW9kaWZpZWRFbmQgJiYgdGhpcy5FbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsU3RhcnQsIG1vZGlmaWVkU3RhcnQpKSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhcnQrKztcclxuICAgICAgICAgICAgbW9kaWZpZWRTdGFydCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGaW5kIHRoZSBlbmQgb2YgdGhlIGRpZmZlcmVuY2VzXHJcbiAgICAgICAgd2hpbGUgKG9yaWdpbmFsRW5kID49IG9yaWdpbmFsU3RhcnQgJiYgbW9kaWZpZWRFbmQgPj0gbW9kaWZpZWRTdGFydCAmJiB0aGlzLkVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxFbmQsIG1vZGlmaWVkRW5kKSkge1xyXG4gICAgICAgICAgICBvcmlnaW5hbEVuZC0tO1xyXG4gICAgICAgICAgICBtb2RpZmllZEVuZC0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJbiB0aGUgc3BlY2lhbCBjYXNlIHdoZXJlIHdlIGVpdGhlciBoYXZlIGFsbCBpbnNlcnRpb25zIG9yIGFsbCBkZWxldGlvbnMgb3IgdGhlIHNlcXVlbmNlcyBhcmUgaWRlbnRpY2FsXHJcbiAgICAgICAgaWYgKG9yaWdpbmFsU3RhcnQgPiBvcmlnaW5hbEVuZCB8fCBtb2RpZmllZFN0YXJ0ID4gbW9kaWZpZWRFbmQpIHtcclxuICAgICAgICAgICAgbGV0IGNoYW5nZXM7XHJcbiAgICAgICAgICAgIGlmIChtb2RpZmllZFN0YXJ0IDw9IG1vZGlmaWVkRW5kKSB7XHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQob3JpZ2luYWxTdGFydCA9PT0gb3JpZ2luYWxFbmQgKyAxLCAnb3JpZ2luYWxTdGFydCBzaG91bGQgb25seSBiZSBvbmUgbW9yZSB0aGFuIG9yaWdpbmFsRW5kJyk7XHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgaW5zZXJ0aW9uc1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgRGlmZkNoYW5nZShvcmlnaW5hbFN0YXJ0LCAwLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZEVuZCAtIG1vZGlmaWVkU3RhcnQgKyAxKVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcmlnaW5hbFN0YXJ0IDw9IG9yaWdpbmFsRW5kKSB7XHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQobW9kaWZpZWRTdGFydCA9PT0gbW9kaWZpZWRFbmQgKyAxLCAnbW9kaWZpZWRTdGFydCBzaG91bGQgb25seSBiZSBvbmUgbW9yZSB0aGFuIG1vZGlmaWVkRW5kJyk7XHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgZGVsZXRpb25zXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydCArIDEsIG1vZGlmaWVkU3RhcnQsIDApXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KG9yaWdpbmFsU3RhcnQgPT09IG9yaWdpbmFsRW5kICsgMSwgJ29yaWdpbmFsU3RhcnQgc2hvdWxkIG9ubHkgYmUgb25lIG1vcmUgdGhhbiBvcmlnaW5hbEVuZCcpO1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KG1vZGlmaWVkU3RhcnQgPT09IG1vZGlmaWVkRW5kICsgMSwgJ21vZGlmaWVkU3RhcnQgc2hvdWxkIG9ubHkgYmUgb25lIG1vcmUgdGhhbiBtb2RpZmllZEVuZCcpO1xyXG4gICAgICAgICAgICAgICAgLy8gSWRlbnRpY2FsIHNlcXVlbmNlcyAtIE5vIGRpZmZlcmVuY2VzXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoaXMgcHJvYmxlbSBjYW4gYmUgc29sdmVkIHVzaW5nIHRoZSBEaXZpZGUtQW5kLUNvbnF1ZXIgdGVjaG5pcXVlLlxyXG4gICAgICAgIGNvbnN0IG1pZE9yaWdpbmFsQXJyID0gWzBdO1xyXG4gICAgICAgIGNvbnN0IG1pZE1vZGlmaWVkQXJyID0gWzBdO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuQ29tcHV0ZVJlY3Vyc2lvblBvaW50KG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZEVuZCwgbWlkT3JpZ2luYWxBcnIsIG1pZE1vZGlmaWVkQXJyLCBxdWl0RWFybHlBcnIpO1xyXG4gICAgICAgIGNvbnN0IG1pZE9yaWdpbmFsID0gbWlkT3JpZ2luYWxBcnJbMF07XHJcbiAgICAgICAgY29uc3QgbWlkTW9kaWZpZWQgPSBtaWRNb2RpZmllZEFyclswXTtcclxuICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFJlc3VsdCBpcyBub3QtbnVsbCB3aGVuIHRoZXJlIHdhcyBlbm91Z2ggbWVtb3J5IHRvIGNvbXB1dGUgdGhlIGNoYW5nZXMgd2hpbGVcclxuICAgICAgICAgICAgLy8gc2VhcmNoaW5nIGZvciB0aGUgcmVjdXJzaW9uIHBvaW50XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFxdWl0RWFybHlBcnJbMF0pIHtcclxuICAgICAgICAgICAgLy8gV2UgY2FuIGJyZWFrIHRoZSBwcm9ibGVtIGRvd24gcmVjdXJzaXZlbHkgYnkgZmluZGluZyB0aGUgY2hhbmdlcyBpbiB0aGVcclxuICAgICAgICAgICAgLy8gRmlyc3QgSGFsZjogICAob3JpZ2luYWxTdGFydCwgbW9kaWZpZWRTdGFydCkgdG8gKG1pZE9yaWdpbmFsLCBtaWRNb2RpZmllZClcclxuICAgICAgICAgICAgLy8gU2Vjb25kIEhhbGY6ICAobWlkT3JpZ2luYWwgKyAxLCBtaW5Nb2RpZmllZCArIDEpIHRvIChvcmlnaW5hbEVuZCwgbW9kaWZpZWRFbmQpXHJcbiAgICAgICAgICAgIC8vIE5PVEU6IENvbXB1dGVEaWZmKCkgaXMgaW5jbHVzaXZlLCB0aGVyZWZvcmUgdGhlIHNlY29uZCByYW5nZSBzdGFydHMgb24gdGhlIG5leHQgcG9pbnRcclxuICAgICAgICAgICAgY29uc3QgbGVmdENoYW5nZXMgPSB0aGlzLkNvbXB1dGVEaWZmUmVjdXJzaXZlKG9yaWdpbmFsU3RhcnQsIG1pZE9yaWdpbmFsLCBtb2RpZmllZFN0YXJ0LCBtaWRNb2RpZmllZCwgcXVpdEVhcmx5QXJyKTtcclxuICAgICAgICAgICAgbGV0IHJpZ2h0Q2hhbmdlcyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoIXF1aXRFYXJseUFyclswXSkge1xyXG4gICAgICAgICAgICAgICAgcmlnaHRDaGFuZ2VzID0gdGhpcy5Db21wdXRlRGlmZlJlY3Vyc2l2ZShtaWRPcmlnaW5hbCArIDEsIG9yaWdpbmFsRW5kLCBtaWRNb2RpZmllZCArIDEsIG1vZGlmaWVkRW5kLCBxdWl0RWFybHlBcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgZGlkJ3QgaGF2ZSB0aW1lIHRvIGZpbmlzaCB0aGUgZmlyc3QgaGFsZiwgc28gd2UgZG9uJ3QgaGF2ZSB0aW1lIHRvIGNvbXB1dGUgdGhpcyBoYWxmLlxyXG4gICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgdGhlIGVudGlyZSByZXN0IG9mIHRoZSBzZXF1ZW5jZSBkaWZmZXJlbnQuXHJcbiAgICAgICAgICAgICAgICByaWdodENoYW5nZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IERpZmZDaGFuZ2UobWlkT3JpZ2luYWwgKyAxLCBvcmlnaW5hbEVuZCAtIChtaWRPcmlnaW5hbCArIDEpICsgMSwgbWlkTW9kaWZpZWQgKyAxLCBtb2RpZmllZEVuZCAtIChtaWRNb2RpZmllZCArIDEpICsgMSlcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ29uY2F0ZW5hdGVDaGFuZ2VzKGxlZnRDaGFuZ2VzLCByaWdodENoYW5nZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB3ZSBoaXQgaGVyZSwgd2UgcXVpdCBlYXJseSwgYW5kIHNvIGNhbid0IHJldHVybiBhbnl0aGluZyBtZWFuaW5nZnVsXHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgbmV3IERpZmZDaGFuZ2Uob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQgLSBvcmlnaW5hbFN0YXJ0ICsgMSwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQgLSBtb2RpZmllZFN0YXJ0ICsgMSlcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgV0FMS1RSQUNFKGRpYWdvbmFsRm9yd2FyZEJhc2UsIGRpYWdvbmFsRm9yd2FyZFN0YXJ0LCBkaWFnb25hbEZvcndhcmRFbmQsIGRpYWdvbmFsRm9yd2FyZE9mZnNldCwgZGlhZ29uYWxSZXZlcnNlQmFzZSwgZGlhZ29uYWxSZXZlcnNlU3RhcnQsIGRpYWdvbmFsUmV2ZXJzZUVuZCwgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0LCBmb3J3YXJkUG9pbnRzLCByZXZlcnNlUG9pbnRzLCBvcmlnaW5hbEluZGV4LCBvcmlnaW5hbEVuZCwgbWlkT3JpZ2luYWxBcnIsIG1vZGlmaWVkSW5kZXgsIG1vZGlmaWVkRW5kLCBtaWRNb2RpZmllZEFyciwgZGVsdGFJc0V2ZW4sIHF1aXRFYXJseUFycikge1xyXG4gICAgICAgIGxldCBmb3J3YXJkQ2hhbmdlcyA9IG51bGw7XHJcbiAgICAgICAgbGV0IHJldmVyc2VDaGFuZ2VzID0gbnVsbDtcclxuICAgICAgICAvLyBGaXJzdCwgd2FsayBiYWNrd2FyZCB0aHJvdWdoIHRoZSBmb3J3YXJkIGRpYWdvbmFscyBoaXN0b3J5XHJcbiAgICAgICAgbGV0IGNoYW5nZUhlbHBlciA9IG5ldyBEaWZmQ2hhbmdlSGVscGVyKCk7XHJcbiAgICAgICAgbGV0IGRpYWdvbmFsTWluID0gZGlhZ29uYWxGb3J3YXJkU3RhcnQ7XHJcbiAgICAgICAgbGV0IGRpYWdvbmFsTWF4ID0gZGlhZ29uYWxGb3J3YXJkRW5kO1xyXG4gICAgICAgIGxldCBkaWFnb25hbFJlbGF0aXZlID0gKG1pZE9yaWdpbmFsQXJyWzBdIC0gbWlkTW9kaWZpZWRBcnJbMF0pIC0gZGlhZ29uYWxGb3J3YXJkT2Zmc2V0O1xyXG4gICAgICAgIGxldCBsYXN0T3JpZ2luYWxJbmRleCA9IC0xMDczNzQxODI0IC8qIE1JTl9TQUZFX1NNQUxMX0lOVEVHRVIgKi87XHJcbiAgICAgICAgbGV0IGhpc3RvcnlJbmRleCA9IHRoaXMubV9mb3J3YXJkSGlzdG9yeS5sZW5ndGggLSAxO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBkaWFnb25hbCBpbmRleCBmcm9tIHRoZSByZWxhdGl2ZSBkaWFnb25hbCBudW1iZXJcclxuICAgICAgICAgICAgY29uc3QgZGlhZ29uYWwgPSBkaWFnb25hbFJlbGF0aXZlICsgZGlhZ29uYWxGb3J3YXJkQmFzZTtcclxuICAgICAgICAgICAgLy8gRmlndXJlIG91dCB3aGVyZSB3ZSBjYW1lIGZyb21cclxuICAgICAgICAgICAgaWYgKGRpYWdvbmFsID09PSBkaWFnb25hbE1pbiB8fCAoZGlhZ29uYWwgPCBkaWFnb25hbE1heCAmJiBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsIC0gMV0gPCBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsICsgMV0pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBWZXJ0aWNhbCBsaW5lICh0aGUgZWxlbWVudCBpcyBhbiBpbnNlcnQpXHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4ID0gZm9yd2FyZFBvaW50c1tkaWFnb25hbCArIDFdO1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbmRleCA9IG9yaWdpbmFsSW5kZXggLSBkaWFnb25hbFJlbGF0aXZlIC0gZGlhZ29uYWxGb3J3YXJkT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPCBsYXN0T3JpZ2luYWxJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5NYXJrTmV4dENoYW5nZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGFzdE9yaWdpbmFsSW5kZXggPSBvcmlnaW5hbEluZGV4O1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLkFkZE1vZGlmaWVkRWxlbWVudChvcmlnaW5hbEluZGV4ICsgMSwgbW9kaWZpZWRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBkaWFnb25hbFJlbGF0aXZlID0gKGRpYWdvbmFsICsgMSkgLSBkaWFnb25hbEZvcndhcmRCYXNlOyAvL1NldHVwIGZvciB0aGUgbmV4dCBpdGVyYXRpb25cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgbGluZSAodGhlIGVsZW1lbnQgaXMgYSBkZWxldGlvbilcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsIC0gMV0gKyAxO1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbmRleCA9IG9yaWdpbmFsSW5kZXggLSBkaWFnb25hbFJlbGF0aXZlIC0gZGlhZ29uYWxGb3J3YXJkT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPCBsYXN0T3JpZ2luYWxJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5NYXJrTmV4dENoYW5nZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGFzdE9yaWdpbmFsSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gMTtcclxuICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5BZGRPcmlnaW5hbEVsZW1lbnQob3JpZ2luYWxJbmRleCwgbW9kaWZpZWRJbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgZGlhZ29uYWxSZWxhdGl2ZSA9IChkaWFnb25hbCAtIDEpIC0gZGlhZ29uYWxGb3J3YXJkQmFzZTsgLy9TZXR1cCBmb3IgdGhlIG5leHQgaXRlcmF0aW9uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhpc3RvcnlJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3J3YXJkUG9pbnRzID0gdGhpcy5tX2ZvcndhcmRIaXN0b3J5W2hpc3RvcnlJbmRleF07XHJcbiAgICAgICAgICAgICAgICBkaWFnb25hbEZvcndhcmRCYXNlID0gZm9yd2FyZFBvaW50c1swXTsgLy9XZSBzdG9yZWQgdGhpcyBpbiB0aGUgZmlyc3Qgc3BvdFxyXG4gICAgICAgICAgICAgICAgZGlhZ29uYWxNaW4gPSAxO1xyXG4gICAgICAgICAgICAgICAgZGlhZ29uYWxNYXggPSBmb3J3YXJkUG9pbnRzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlICgtLWhpc3RvcnlJbmRleCA+PSAtMSk7XHJcbiAgICAgICAgLy8gSXJvbmljYWxseSwgd2UgZ2V0IHRoZSBmb3J3YXJkIGNoYW5nZXMgYXMgdGhlIHJldmVyc2Ugb2YgdGhlXHJcbiAgICAgICAgLy8gb3JkZXIgd2UgYWRkZWQgdGhlbSBzaW5jZSB3ZSB0ZWNobmljYWxseSBhZGRlZCB0aGVtIGJhY2t3YXJkc1xyXG4gICAgICAgIGZvcndhcmRDaGFuZ2VzID0gY2hhbmdlSGVscGVyLmdldFJldmVyc2VDaGFuZ2VzKCk7XHJcbiAgICAgICAgaWYgKHF1aXRFYXJseUFyclswXSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBDYWxjdWxhdGUgYSBwYXJ0aWFsIGZyb20gdGhlIHJldmVyc2UgZGlhZ29uYWxzLlxyXG4gICAgICAgICAgICAvLyAgICAgICBGb3Igbm93LCBqdXN0IGFzc3VtZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBtaWRPcmlnaW5hbC9taWRNb2RpZmllZCBwb2ludCBpcyBhIGRpZmZcclxuICAgICAgICAgICAgbGV0IG9yaWdpbmFsU3RhcnRQb2ludCA9IG1pZE9yaWdpbmFsQXJyWzBdICsgMTtcclxuICAgICAgICAgICAgbGV0IG1vZGlmaWVkU3RhcnRQb2ludCA9IG1pZE1vZGlmaWVkQXJyWzBdICsgMTtcclxuICAgICAgICAgICAgaWYgKGZvcndhcmRDaGFuZ2VzICE9PSBudWxsICYmIGZvcndhcmRDaGFuZ2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RGb3J3YXJkQ2hhbmdlID0gZm9yd2FyZENoYW5nZXNbZm9yd2FyZENoYW5nZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0UG9pbnQgPSBNYXRoLm1heChvcmlnaW5hbFN0YXJ0UG9pbnQsIGxhc3RGb3J3YXJkQ2hhbmdlLmdldE9yaWdpbmFsRW5kKCkpO1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydFBvaW50ID0gTWF0aC5tYXgobW9kaWZpZWRTdGFydFBvaW50LCBsYXN0Rm9yd2FyZENoYW5nZS5nZXRNb2RpZmllZEVuZCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXZlcnNlQ2hhbmdlcyA9IFtcclxuICAgICAgICAgICAgICAgIG5ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnRQb2ludCwgb3JpZ2luYWxFbmQgLSBvcmlnaW5hbFN0YXJ0UG9pbnQgKyAxLCBtb2RpZmllZFN0YXJ0UG9pbnQsIG1vZGlmaWVkRW5kIC0gbW9kaWZpZWRTdGFydFBvaW50ICsgMSlcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vdyB3YWxrIGJhY2t3YXJkIHRocm91Z2ggdGhlIHJldmVyc2UgZGlhZ29uYWxzIGhpc3RvcnlcclxuICAgICAgICAgICAgY2hhbmdlSGVscGVyID0gbmV3IERpZmZDaGFuZ2VIZWxwZXIoKTtcclxuICAgICAgICAgICAgZGlhZ29uYWxNaW4gPSBkaWFnb25hbFJldmVyc2VTdGFydDtcclxuICAgICAgICAgICAgZGlhZ29uYWxNYXggPSBkaWFnb25hbFJldmVyc2VFbmQ7XHJcbiAgICAgICAgICAgIGRpYWdvbmFsUmVsYXRpdmUgPSAobWlkT3JpZ2luYWxBcnJbMF0gLSBtaWRNb2RpZmllZEFyclswXSkgLSBkaWFnb25hbFJldmVyc2VPZmZzZXQ7XHJcbiAgICAgICAgICAgIGxhc3RPcmlnaW5hbEluZGV4ID0gMTA3Mzc0MTgyNCAvKiBNQVhfU0FGRV9TTUFMTF9JTlRFR0VSICovO1xyXG4gICAgICAgICAgICBoaXN0b3J5SW5kZXggPSAoZGVsdGFJc0V2ZW4pID8gdGhpcy5tX3JldmVyc2VIaXN0b3J5Lmxlbmd0aCAtIDEgOiB0aGlzLm1fcmV2ZXJzZUhpc3RvcnkubGVuZ3RoIC0gMjtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBkaWFnb25hbCBpbmRleCBmcm9tIHRoZSByZWxhdGl2ZSBkaWFnb25hbCBudW1iZXJcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpYWdvbmFsID0gZGlhZ29uYWxSZWxhdGl2ZSArIGRpYWdvbmFsUmV2ZXJzZUJhc2U7XHJcbiAgICAgICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoZXJlIHdlIGNhbWUgZnJvbVxyXG4gICAgICAgICAgICAgICAgaWYgKGRpYWdvbmFsID09PSBkaWFnb25hbE1pbiB8fCAoZGlhZ29uYWwgPCBkaWFnb25hbE1heCAmJiByZXZlcnNlUG9pbnRzW2RpYWdvbmFsIC0gMV0gPj0gcmV2ZXJzZVBvaW50c1tkaWFnb25hbCArIDFdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgbGluZSAodGhlIGVsZW1lbnQgaXMgYSBkZWxldGlvbikpXHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IHJldmVyc2VQb2ludHNbZGlhZ29uYWwgKyAxXSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRJbmRleCA9IG9yaWdpbmFsSW5kZXggLSBkaWFnb25hbFJlbGF0aXZlIC0gZGlhZ29uYWxSZXZlcnNlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4ID4gbGFzdE9yaWdpbmFsSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLk1hcmtOZXh0Q2hhbmdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLkFkZE9yaWdpbmFsRWxlbWVudChvcmlnaW5hbEluZGV4ICsgMSwgbW9kaWZpZWRJbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpYWdvbmFsUmVsYXRpdmUgPSAoZGlhZ29uYWwgKyAxKSAtIGRpYWdvbmFsUmV2ZXJzZUJhc2U7IC8vU2V0dXAgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVmVydGljYWwgbGluZSAodGhlIGVsZW1lbnQgaXMgYW4gaW5zZXJ0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRJbmRleCA9IG9yaWdpbmFsSW5kZXggLSBkaWFnb25hbFJlbGF0aXZlIC0gZGlhZ29uYWxSZXZlcnNlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4ID4gbGFzdE9yaWdpbmFsSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLk1hcmtOZXh0Q2hhbmdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIZWxwZXIuQWRkTW9kaWZpZWRFbGVtZW50KG9yaWdpbmFsSW5kZXggKyAxLCBtb2RpZmllZEluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhZ29uYWxSZWxhdGl2ZSA9IChkaWFnb25hbCAtIDEpIC0gZGlhZ29uYWxSZXZlcnNlQmFzZTsgLy9TZXR1cCBmb3IgdGhlIG5leHQgaXRlcmF0aW9uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaGlzdG9yeUluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXZlcnNlUG9pbnRzID0gdGhpcy5tX3JldmVyc2VIaXN0b3J5W2hpc3RvcnlJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhZ29uYWxSZXZlcnNlQmFzZSA9IHJldmVyc2VQb2ludHNbMF07IC8vV2Ugc3RvcmVkIHRoaXMgaW4gdGhlIGZpcnN0IHNwb3RcclxuICAgICAgICAgICAgICAgICAgICBkaWFnb25hbE1pbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhZ29uYWxNYXggPSByZXZlcnNlUG9pbnRzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKC0taGlzdG9yeUluZGV4ID49IC0xKTtcclxuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIGNhc2VzIHdoZXJlIHRoZSByZXZlcnNlIGhpc3Rvcnkgd2lsbCBmaW5kIGRpZmZzIHRoYXRcclxuICAgICAgICAgICAgLy8gYXJlIGNvcnJlY3QsIGJ1dCBub3QgaW50dWl0aXZlLCBzbyB3ZSBuZWVkIHNoaWZ0IHRoZW0uXHJcbiAgICAgICAgICAgIHJldmVyc2VDaGFuZ2VzID0gY2hhbmdlSGVscGVyLmdldENoYW5nZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuQ29uY2F0ZW5hdGVDaGFuZ2VzKGZvcndhcmRDaGFuZ2VzLCByZXZlcnNlQ2hhbmdlcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIHRoZSByYW5nZSB0byBjb21wdXRlIHRoZSBkaWZmIG9uLCB0aGlzIG1ldGhvZCBmaW5kcyB0aGUgcG9pbnQ6XHJcbiAgICAgKiAobWlkT3JpZ2luYWwsIG1pZE1vZGlmaWVkKVxyXG4gICAgICogdGhhdCBleGlzdHMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgTENTIG9mIHRoZSB0d28gc2VxdWVuY2VzIGFuZFxyXG4gICAgICogaXMgdGhlIHBvaW50IGF0IHdoaWNoIHRoZSBMQ1MgcHJvYmxlbSBtYXkgYmUgYnJva2VuIGRvd24gcmVjdXJzaXZlbHkuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHRyeSB0byBrZWVwIHRoZSBMQ1MgdHJhY2UgaW4gbWVtb3J5LiBJZiB0aGUgTENTIHJlY3Vyc2lvblxyXG4gICAgICogcG9pbnQgaXMgY2FsY3VsYXRlZCBhbmQgdGhlIGZ1bGwgdHJhY2UgaXMgYXZhaWxhYmxlIGluIG1lbW9yeSwgdGhlbiB0aGlzIG1ldGhvZFxyXG4gICAgICogd2lsbCByZXR1cm4gdGhlIGNoYW5nZSBsaXN0LlxyXG4gICAgICogQHBhcmFtIG9yaWdpbmFsU3RhcnQgVGhlIHN0YXJ0IGJvdW5kIG9mIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZSByYW5nZVxyXG4gICAgICogQHBhcmFtIG9yaWdpbmFsRW5kIFRoZSBlbmQgYm91bmQgb2YgdGhlIG9yaWdpbmFsIHNlcXVlbmNlIHJhbmdlXHJcbiAgICAgKiBAcGFyYW0gbW9kaWZpZWRTdGFydCBUaGUgc3RhcnQgYm91bmQgb2YgdGhlIG1vZGlmaWVkIHNlcXVlbmNlIHJhbmdlXHJcbiAgICAgKiBAcGFyYW0gbW9kaWZpZWRFbmQgVGhlIGVuZCBib3VuZCBvZiB0aGUgbW9kaWZpZWQgc2VxdWVuY2UgcmFuZ2VcclxuICAgICAqIEBwYXJhbSBtaWRPcmlnaW5hbCBUaGUgbWlkZGxlIHBvaW50IG9mIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZSByYW5nZVxyXG4gICAgICogQHBhcmFtIG1pZE1vZGlmaWVkIFRoZSBtaWRkbGUgcG9pbnQgb2YgdGhlIG1vZGlmaWVkIHNlcXVlbmNlIHJhbmdlXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGlmZiBjaGFuZ2VzLCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBudWxsXHJcbiAgICAgKi9cclxuICAgIENvbXB1dGVSZWN1cnNpb25Qb2ludChvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQsIG1pZE9yaWdpbmFsQXJyLCBtaWRNb2RpZmllZEFyciwgcXVpdEVhcmx5QXJyKSB7XHJcbiAgICAgICAgbGV0IG9yaWdpbmFsSW5kZXggPSAwLCBtb2RpZmllZEluZGV4ID0gMDtcclxuICAgICAgICBsZXQgZGlhZ29uYWxGb3J3YXJkU3RhcnQgPSAwLCBkaWFnb25hbEZvcndhcmRFbmQgPSAwO1xyXG4gICAgICAgIGxldCBkaWFnb25hbFJldmVyc2VTdGFydCA9IDAsIGRpYWdvbmFsUmV2ZXJzZUVuZCA9IDA7XHJcbiAgICAgICAgLy8gVG8gdHJhdmVyc2UgdGhlIGVkaXQgZ3JhcGggYW5kIHByb2R1Y2UgdGhlIHByb3BlciBMQ1MsIG91ciBhY3R1YWxcclxuICAgICAgICAvLyBzdGFydCBwb3NpdGlvbiBpcyBqdXN0IG91dHNpZGUgdGhlIGdpdmVuIGJvdW5kYXJ5XHJcbiAgICAgICAgb3JpZ2luYWxTdGFydC0tO1xyXG4gICAgICAgIG1vZGlmaWVkU3RhcnQtLTtcclxuICAgICAgICAvLyBXZSBzZXQgdGhlc2UgdXAgdG8gbWFrZSB0aGUgY29tcGlsZXIgaGFwcHksIGJ1dCB0aGV5IHdpbGxcclxuICAgICAgICAvLyBiZSByZXBsYWNlZCBiZWZvcmUgd2UgcmV0dXJuIHdpdGggdGhlIGFjdHVhbCByZWN1cnNpb24gcG9pbnRcclxuICAgICAgICBtaWRPcmlnaW5hbEFyclswXSA9IDA7XHJcbiAgICAgICAgbWlkTW9kaWZpZWRBcnJbMF0gPSAwO1xyXG4gICAgICAgIC8vIENsZWFyIG91dCB0aGUgaGlzdG9yeVxyXG4gICAgICAgIHRoaXMubV9mb3J3YXJkSGlzdG9yeSA9IFtdO1xyXG4gICAgICAgIHRoaXMubV9yZXZlcnNlSGlzdG9yeSA9IFtdO1xyXG4gICAgICAgIC8vIEVhY2ggY2VsbCBpbiB0aGUgdHdvIGFycmF5cyBjb3JyZXNwb25kcyB0byBhIGRpYWdvbmFsIGluIHRoZSBlZGl0IGdyYXBoLlxyXG4gICAgICAgIC8vIFRoZSBpbnRlZ2VyIHZhbHVlIGluIHRoZSBjZWxsIHJlcHJlc2VudHMgdGhlIG9yaWdpbmFsSW5kZXggb2YgdGhlIGZ1cnRoZXN0XHJcbiAgICAgICAgLy8gcmVhY2hpbmcgcG9pbnQgZm91bmQgc28gZmFyIHRoYXQgZW5kcyBpbiB0aGF0IGRpYWdvbmFsLlxyXG4gICAgICAgIC8vIFRoZSBtb2RpZmllZEluZGV4IGNhbiBiZSBjb21wdXRlZCBtYXRoZW1hdGljYWxseSBmcm9tIHRoZSBvcmlnaW5hbEluZGV4IGFuZCB0aGUgZGlhZ29uYWwgbnVtYmVyLlxyXG4gICAgICAgIGNvbnN0IG1heERpZmZlcmVuY2VzID0gKG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydCkgKyAobW9kaWZpZWRFbmQgLSBtb2RpZmllZFN0YXJ0KTtcclxuICAgICAgICBjb25zdCBudW1EaWFnb25hbHMgPSBtYXhEaWZmZXJlbmNlcyArIDE7XHJcbiAgICAgICAgY29uc3QgZm9yd2FyZFBvaW50cyA9IG5ldyBJbnQzMkFycmF5KG51bURpYWdvbmFscyk7XHJcbiAgICAgICAgY29uc3QgcmV2ZXJzZVBvaW50cyA9IG5ldyBJbnQzMkFycmF5KG51bURpYWdvbmFscyk7XHJcbiAgICAgICAgLy8gZGlhZ29uYWxGb3J3YXJkQmFzZTogSW5kZXggaW50byBmb3J3YXJkUG9pbnRzIG9mIHRoZSBkaWFnb25hbCB3aGljaCBwYXNzZXMgdGhyb3VnaCAob3JpZ2luYWxTdGFydCwgbW9kaWZpZWRTdGFydClcclxuICAgICAgICAvLyBkaWFnb25hbFJldmVyc2VCYXNlOiBJbmRleCBpbnRvIHJldmVyc2VQb2ludHMgb2YgdGhlIGRpYWdvbmFsIHdoaWNoIHBhc3NlcyB0aHJvdWdoIChvcmlnaW5hbEVuZCwgbW9kaWZpZWRFbmQpXHJcbiAgICAgICAgY29uc3QgZGlhZ29uYWxGb3J3YXJkQmFzZSA9IChtb2RpZmllZEVuZCAtIG1vZGlmaWVkU3RhcnQpO1xyXG4gICAgICAgIGNvbnN0IGRpYWdvbmFsUmV2ZXJzZUJhc2UgPSAob3JpZ2luYWxFbmQgLSBvcmlnaW5hbFN0YXJ0KTtcclxuICAgICAgICAvLyBkaWFnb25hbEZvcndhcmRPZmZzZXQ6IEdlb21ldHJpYyBvZmZzZXQgd2hpY2ggYWxsb3dzIG1vZGlmaWVkSW5kZXggdG8gYmUgY29tcHV0ZWQgZnJvbSBvcmlnaW5hbEluZGV4IGFuZCB0aGVcclxuICAgICAgICAvLyAgICBkaWFnb25hbCBudW1iZXIgKHJlbGF0aXZlIHRvIGRpYWdvbmFsRm9yd2FyZEJhc2UpXHJcbiAgICAgICAgLy8gZGlhZ29uYWxSZXZlcnNlT2Zmc2V0OiBHZW9tZXRyaWMgb2Zmc2V0IHdoaWNoIGFsbG93cyBtb2RpZmllZEluZGV4IHRvIGJlIGNvbXB1dGVkIGZyb20gb3JpZ2luYWxJbmRleCBhbmQgdGhlXHJcbiAgICAgICAgLy8gICAgZGlhZ29uYWwgbnVtYmVyIChyZWxhdGl2ZSB0byBkaWFnb25hbFJldmVyc2VCYXNlKVxyXG4gICAgICAgIGNvbnN0IGRpYWdvbmFsRm9yd2FyZE9mZnNldCA9IChvcmlnaW5hbFN0YXJ0IC0gbW9kaWZpZWRTdGFydCk7XHJcbiAgICAgICAgY29uc3QgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0ID0gKG9yaWdpbmFsRW5kIC0gbW9kaWZpZWRFbmQpO1xyXG4gICAgICAgIC8vIGRlbHRhOiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBlbmQgZGlhZ29uYWwgYW5kIHRoZSBzdGFydCBkaWFnb25hbC4gVGhpcyBpcyB1c2VkIHRvIHJlbGF0ZSBkaWFnb25hbCBudW1iZXJzXHJcbiAgICAgICAgLy8gICByZWxhdGl2ZSB0byB0aGUgc3RhcnQgZGlhZ29uYWwgd2l0aCBkaWFnb25hbCBudW1iZXJzIHJlbGF0aXZlIHRvIHRoZSBlbmQgZGlhZ29uYWwuXHJcbiAgICAgICAgLy8gVGhlIEV2ZW4vT2Rkbi1uZXNzIG9mIHRoaXMgZGVsdGEgaXMgaW1wb3J0YW50IGZvciBkZXRlcm1pbmluZyB3aGVuIHdlIHNob3VsZCBjaGVjayBmb3Igb3ZlcmxhcFxyXG4gICAgICAgIGNvbnN0IGRlbHRhID0gZGlhZ29uYWxSZXZlcnNlQmFzZSAtIGRpYWdvbmFsRm9yd2FyZEJhc2U7XHJcbiAgICAgICAgY29uc3QgZGVsdGFJc0V2ZW4gPSAoZGVsdGEgJSAyID09PSAwKTtcclxuICAgICAgICAvLyBIZXJlIHdlIHNldCB1cCB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgYXMgdGhlIGZ1cnRoZXN0IHBvaW50cyBmb3VuZCBzbyBmYXJcclxuICAgICAgICAvLyBpbiBib3RoIHRoZSBmb3J3YXJkIGFuZCByZXZlcnNlIGRpcmVjdGlvbnMsIHJlc3BlY3RpdmVseVxyXG4gICAgICAgIGZvcndhcmRQb2ludHNbZGlhZ29uYWxGb3J3YXJkQmFzZV0gPSBvcmlnaW5hbFN0YXJ0O1xyXG4gICAgICAgIHJldmVyc2VQb2ludHNbZGlhZ29uYWxSZXZlcnNlQmFzZV0gPSBvcmlnaW5hbEVuZDtcclxuICAgICAgICAvLyBSZW1lbWJlciBpZiB3ZSBxdWl0IGVhcmx5LCBhbmQgdGh1cyBuZWVkIHRvIGRvIGEgYmVzdC1lZmZvcnQgcmVzdWx0IGluc3RlYWQgb2YgYSByZWFsIHJlc3VsdC5cclxuICAgICAgICBxdWl0RWFybHlBcnJbMF0gPSBmYWxzZTtcclxuICAgICAgICAvLyBBIGNvdXBsZSBvZiBwb2ludHM6XHJcbiAgICAgICAgLy8gLS1XaXRoIHRoaXMgbWV0aG9kLCB3ZSBpdGVyYXRlIG9uIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUgdHdvIHNlcXVlbmNlcy5cclxuICAgICAgICAvLyAgIFRoZSBtb3JlIGRpZmZlcmVuY2VzIHRoZXJlIGFjdHVhbGx5IGFyZSwgdGhlIGxvbmdlciB0aGlzIHdpbGwgdGFrZS5cclxuICAgICAgICAvLyAtLUFsc28sIGFzIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXMgaW5jcmVhc2VzLCB3ZSBoYXZlIHRvIHNlYXJjaCBvbiBkaWFnb25hbHMgZnVydGhlclxyXG4gICAgICAgIC8vICAgYXdheSBmcm9tIHRoZSByZWZlcmVuY2UgZGlhZ29uYWwgKHdoaWNoIGlzIGRpYWdvbmFsRm9yd2FyZEJhc2UgZm9yIGZvcndhcmQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UgZm9yIHJldmVyc2UpLlxyXG4gICAgICAgIC8vIC0tV2UgZXh0ZW5kIG9uIGV2ZW4gZGlhZ29uYWxzIChyZWxhdGl2ZSB0byB0aGUgcmVmZXJlbmNlIGRpYWdvbmFsKSBvbmx5IHdoZW4gbnVtRGlmZmVyZW5jZXNcclxuICAgICAgICAvLyAgIGlzIGV2ZW4gYW5kIG9kZCBkaWFnb25hbHMgb25seSB3aGVuIG51bURpZmZlcmVuY2VzIGlzIG9kZC5cclxuICAgICAgICBmb3IgKGxldCBudW1EaWZmZXJlbmNlcyA9IDE7IG51bURpZmZlcmVuY2VzIDw9IChtYXhEaWZmZXJlbmNlcyAvIDIpICsgMTsgbnVtRGlmZmVyZW5jZXMrKykge1xyXG4gICAgICAgICAgICBsZXQgZnVydGhlc3RPcmlnaW5hbEluZGV4ID0gMDtcclxuICAgICAgICAgICAgbGV0IGZ1cnRoZXN0TW9kaWZpZWRJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIC8vIFJ1biB0aGUgYWxnb3JpdGhtIGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvblxyXG4gICAgICAgICAgICBkaWFnb25hbEZvcndhcmRTdGFydCA9IHRoaXMuQ2xpcERpYWdvbmFsQm91bmQoZGlhZ29uYWxGb3J3YXJkQmFzZSAtIG51bURpZmZlcmVuY2VzLCBudW1EaWZmZXJlbmNlcywgZGlhZ29uYWxGb3J3YXJkQmFzZSwgbnVtRGlhZ29uYWxzKTtcclxuICAgICAgICAgICAgZGlhZ29uYWxGb3J3YXJkRW5kID0gdGhpcy5DbGlwRGlhZ29uYWxCb3VuZChkaWFnb25hbEZvcndhcmRCYXNlICsgbnVtRGlmZmVyZW5jZXMsIG51bURpZmZlcmVuY2VzLCBkaWFnb25hbEZvcndhcmRCYXNlLCBudW1EaWFnb25hbHMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBkaWFnb25hbCA9IGRpYWdvbmFsRm9yd2FyZFN0YXJ0OyBkaWFnb25hbCA8PSBkaWFnb25hbEZvcndhcmRFbmQ7IGRpYWdvbmFsICs9IDIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNURVAgMTogV2UgZXh0ZW5kIHRoZSBmdXJ0aGVzdCByZWFjaGluZyBwb2ludCBpbiB0aGUgcHJlc2VudCBkaWFnb25hbFxyXG4gICAgICAgICAgICAgICAgLy8gYnkgbG9va2luZyBhdCB0aGUgZGlhZ29uYWxzIGFib3ZlIGFuZCBiZWxvdyBhbmQgcGlja2luZyB0aGUgb25lIHdob3NlIHBvaW50XHJcbiAgICAgICAgICAgICAgICAvLyBpcyBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgc3RhcnQgcG9pbnQgKG9yaWdpbmFsU3RhcnQsIG1vZGlmaWVkU3RhcnQpXHJcbiAgICAgICAgICAgICAgICBpZiAoZGlhZ29uYWwgPT09IGRpYWdvbmFsRm9yd2FyZFN0YXJ0IHx8IChkaWFnb25hbCA8IGRpYWdvbmFsRm9yd2FyZEVuZCAmJiBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsIC0gMV0gPCBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsICsgMV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IGZvcndhcmRQb2ludHNbZGlhZ29uYWwgKyAxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsIC0gMV0gKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbmRleCA9IG9yaWdpbmFsSW5kZXggLSAoZGlhZ29uYWwgLSBkaWFnb25hbEZvcndhcmRCYXNlKSAtIGRpYWdvbmFsRm9yd2FyZE9mZnNldDtcclxuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgb3JpZ2luYWxJbmRleCBzbyB3ZSBjYW4gdGVzdCBmb3IgZmFsc2Ugb3ZlcmxhcCBpbiBzdGVwIDNcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleDtcclxuICAgICAgICAgICAgICAgIC8vIFNURVAgMjogV2UgY2FuIGNvbnRpbnVlIHRvIGV4dGVuZCB0aGUgZnVydGhlc3QgcmVhY2hpbmcgcG9pbnQgaW4gdGhlIHByZXNlbnQgZGlhZ29uYWxcclxuICAgICAgICAgICAgICAgIC8vIHNvIGxvbmcgYXMgdGhlIGVsZW1lbnRzIGFyZSBlcXVhbC5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChvcmlnaW5hbEluZGV4IDwgb3JpZ2luYWxFbmQgJiYgbW9kaWZpZWRJbmRleCA8IG1vZGlmaWVkRW5kICYmIHRoaXMuRWxlbWVudHNBcmVFcXVhbChvcmlnaW5hbEluZGV4ICsgMSwgbW9kaWZpZWRJbmRleCArIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXgrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvcndhcmRQb2ludHNbZGlhZ29uYWxdID0gb3JpZ2luYWxJbmRleDtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4ICsgbW9kaWZpZWRJbmRleCA+IGZ1cnRoZXN0T3JpZ2luYWxJbmRleCArIGZ1cnRoZXN0TW9kaWZpZWRJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1cnRoZXN0T3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVydGhlc3RNb2RpZmllZEluZGV4ID0gbW9kaWZpZWRJbmRleDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFNURVAgMzogSWYgZGVsdGEgaXMgb2RkIChvdmVybGFwIGZpcnN0IGhhcHBlbnMgb24gZm9yd2FyZCB3aGVuIGRlbHRhIGlzIG9kZClcclxuICAgICAgICAgICAgICAgIC8vIGFuZCBkaWFnb25hbCBpcyBpbiB0aGUgcmFuZ2Ugb2YgcmV2ZXJzZSBkaWFnb25hbHMgY29tcHV0ZWQgZm9yIG51bURpZmZlcmVuY2VzLTFcclxuICAgICAgICAgICAgICAgIC8vICh0aGUgcHJldmlvdXMgaXRlcmF0aW9uOyB3ZSBoYXZlbid0IGNvbXB1dGVkIHJldmVyc2UgZGlhZ29uYWxzIGZvciBudW1EaWZmZXJlbmNlcyB5ZXQpXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGNoZWNrIGZvciBvdmVybGFwLlxyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWx0YUlzRXZlbiAmJiBNYXRoLmFicyhkaWFnb25hbCAtIGRpYWdvbmFsUmV2ZXJzZUJhc2UpIDw9IChudW1EaWZmZXJlbmNlcyAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPj0gcmV2ZXJzZVBvaW50c1tkaWFnb25hbF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWlkT3JpZ2luYWxBcnJbMF0gPSBvcmlnaW5hbEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaWRNb2RpZmllZEFyclswXSA9IG1vZGlmaWVkSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wT3JpZ2luYWxJbmRleCA8PSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsXSAmJiAxNDQ3IC8qIE1heERpZmZlcmVuY2VzSGlzdG9yeSAqLyA+IDAgJiYgbnVtRGlmZmVyZW5jZXMgPD0gKDE0NDcgLyogTWF4RGlmZmVyZW5jZXNIaXN0b3J5ICovICsgMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJJTkdPISBXZSBvdmVybGFwcGVkLCBhbmQgd2UgaGF2ZSB0aGUgZnVsbCB0cmFjZSBpbiBtZW1vcnkhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5XQUxLVFJBQ0UoZGlhZ29uYWxGb3J3YXJkQmFzZSwgZGlhZ29uYWxGb3J3YXJkU3RhcnQsIGRpYWdvbmFsRm9yd2FyZEVuZCwgZGlhZ29uYWxGb3J3YXJkT2Zmc2V0LCBkaWFnb25hbFJldmVyc2VCYXNlLCBkaWFnb25hbFJldmVyc2VTdGFydCwgZGlhZ29uYWxSZXZlcnNlRW5kLCBkaWFnb25hbFJldmVyc2VPZmZzZXQsIGZvcndhcmRQb2ludHMsIHJldmVyc2VQb2ludHMsIG9yaWdpbmFsSW5kZXgsIG9yaWdpbmFsRW5kLCBtaWRPcmlnaW5hbEFyciwgbW9kaWZpZWRJbmRleCwgbW9kaWZpZWRFbmQsIG1pZE1vZGlmaWVkQXJyLCBkZWx0YUlzRXZlbiwgcXVpdEVhcmx5QXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVpdGhlciBmYWxzZSBvdmVybGFwLCBvciB3ZSBkaWRuJ3QgaGF2ZSBlbm91Z2ggbWVtb3J5IGZvciB0aGUgZnVsbCB0cmFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCByZXR1cm4gdGhlIHJlY3Vyc2lvbiBwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIHNob3VsZCBiZSBxdWl0dGluZyBlYXJseSwgYmVmb3JlIG1vdmluZyBvbiB0byB0aGUgbmV4dCBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoTGVuZ3RoT2ZMb25nZXN0ID0gKChmdXJ0aGVzdE9yaWdpbmFsSW5kZXggLSBvcmlnaW5hbFN0YXJ0KSArIChmdXJ0aGVzdE1vZGlmaWVkSW5kZXggLSBtb2RpZmllZFN0YXJ0KSAtIG51bURpZmZlcmVuY2VzKSAvIDI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLkNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZSAhPT0gbnVsbCAmJiAhdGhpcy5Db250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUoZnVydGhlc3RPcmlnaW5hbEluZGV4LCBtYXRjaExlbmd0aE9mTG9uZ2VzdCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IGZpbmlzaCwgc28gc2tpcCBhaGVhZCB0byBnZW5lcmF0aW5nIGEgcmVzdWx0IGZyb20gd2hhdCB3ZSBoYXZlLlxyXG4gICAgICAgICAgICAgICAgcXVpdEVhcmx5QXJyWzBdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZnVydGhlc3QgZGlzdGFuY2Ugd2UgZ290IGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbi5cclxuICAgICAgICAgICAgICAgIG1pZE9yaWdpbmFsQXJyWzBdID0gZnVydGhlc3RPcmlnaW5hbEluZGV4O1xyXG4gICAgICAgICAgICAgICAgbWlkTW9kaWZpZWRBcnJbMF0gPSBmdXJ0aGVzdE1vZGlmaWVkSW5kZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hMZW5ndGhPZkxvbmdlc3QgPiAwICYmIDE0NDcgLyogTWF4RGlmZmVyZW5jZXNIaXN0b3J5ICovID4gMCAmJiBudW1EaWZmZXJlbmNlcyA8PSAoMTQ0NyAvKiBNYXhEaWZmZXJlbmNlc0hpc3RvcnkgKi8gKyAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVub3VnaCBvZiB0aGUgaGlzdG9yeSBpcyBpbiBtZW1vcnkgdG8gd2FsayBpdCBiYWNrd2FyZHNcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5XQUxLVFJBQ0UoZGlhZ29uYWxGb3J3YXJkQmFzZSwgZGlhZ29uYWxGb3J3YXJkU3RhcnQsIGRpYWdvbmFsRm9yd2FyZEVuZCwgZGlhZ29uYWxGb3J3YXJkT2Zmc2V0LCBkaWFnb25hbFJldmVyc2VCYXNlLCBkaWFnb25hbFJldmVyc2VTdGFydCwgZGlhZ29uYWxSZXZlcnNlRW5kLCBkaWFnb25hbFJldmVyc2VPZmZzZXQsIGZvcndhcmRQb2ludHMsIHJldmVyc2VQb2ludHMsIG9yaWdpbmFsSW5kZXgsIG9yaWdpbmFsRW5kLCBtaWRPcmlnaW5hbEFyciwgbW9kaWZpZWRJbmRleCwgbW9kaWZpZWRFbmQsIG1pZE1vZGlmaWVkQXJyLCBkZWx0YUlzRXZlbiwgcXVpdEVhcmx5QXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRpZG4ndCBhY3R1YWxseSByZW1lbWJlciBlbm91Z2ggb2YgdGhlIGhpc3RvcnkuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9TaW5jZSB3ZSBhcmUgcXVpdGluZyB0aGUgZGlmZiBlYXJseSwgd2UgbmVlZCB0byBzaGlmdCBiYWNrIHRoZSBvcmlnaW5hbFN0YXJ0IGFuZCBtb2RpZmllZCBzdGFydFxyXG4gICAgICAgICAgICAgICAgICAgIC8vYmFjayBpbnRvIHRoZSBib3VuZGFyeSBsaW1pdHMgc2luY2Ugd2UgZGVjcmVtZW50ZWQgdGhlaXIgdmFsdWUgYWJvdmUgYmV5b25kIHRoZSBib3VuZGFyeSBsaW1pdC5cclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydCArIDEsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kIC0gbW9kaWZpZWRTdGFydCArIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSdW4gdGhlIGFsZ29yaXRobSBpbiB0aGUgcmV2ZXJzZSBkaXJlY3Rpb25cclxuICAgICAgICAgICAgZGlhZ29uYWxSZXZlcnNlU3RhcnQgPSB0aGlzLkNsaXBEaWFnb25hbEJvdW5kKGRpYWdvbmFsUmV2ZXJzZUJhc2UgLSBudW1EaWZmZXJlbmNlcywgbnVtRGlmZmVyZW5jZXMsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIG51bURpYWdvbmFscyk7XHJcbiAgICAgICAgICAgIGRpYWdvbmFsUmV2ZXJzZUVuZCA9IHRoaXMuQ2xpcERpYWdvbmFsQm91bmQoZGlhZ29uYWxSZXZlcnNlQmFzZSArIG51bURpZmZlcmVuY2VzLCBudW1EaWZmZXJlbmNlcywgZGlhZ29uYWxSZXZlcnNlQmFzZSwgbnVtRGlhZ29uYWxzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgZGlhZ29uYWwgPSBkaWFnb25hbFJldmVyc2VTdGFydDsgZGlhZ29uYWwgPD0gZGlhZ29uYWxSZXZlcnNlRW5kOyBkaWFnb25hbCArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTVEVQIDE6IFdlIGV4dGVuZCB0aGUgZnVydGhlc3QgcmVhY2hpbmcgcG9pbnQgaW4gdGhlIHByZXNlbnQgZGlhZ29uYWxcclxuICAgICAgICAgICAgICAgIC8vIGJ5IGxvb2tpbmcgYXQgdGhlIGRpYWdvbmFscyBhYm92ZSBhbmQgYmVsb3cgYW5kIHBpY2tpbmcgdGhlIG9uZSB3aG9zZSBwb2ludFxyXG4gICAgICAgICAgICAgICAgLy8gaXMgZnVydGhlciBhd2F5IGZyb20gdGhlIHN0YXJ0IHBvaW50IChvcmlnaW5hbEVuZCwgbW9kaWZpZWRFbmQpXHJcbiAgICAgICAgICAgICAgICBpZiAoZGlhZ29uYWwgPT09IGRpYWdvbmFsUmV2ZXJzZVN0YXJ0IHx8IChkaWFnb25hbCA8IGRpYWdvbmFsUmV2ZXJzZUVuZCAmJiByZXZlcnNlUG9pbnRzW2RpYWdvbmFsIC0gMV0gPj0gcmV2ZXJzZVBvaW50c1tkaWFnb25hbCArIDFdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsICsgMV0gLSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IHJldmVyc2VQb2ludHNbZGlhZ29uYWwgLSAxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gKGRpYWdvbmFsIC0gZGlhZ29uYWxSZXZlcnNlQmFzZSkgLSBkaWFnb25hbFJldmVyc2VPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IG9yaWdpbmFsSW5kZXggc28gd2UgY2FuIHRlc3QgZm9yIGZhbHNlIG92ZXJsYXBcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleDtcclxuICAgICAgICAgICAgICAgIC8vIFNURVAgMjogV2UgY2FuIGNvbnRpbnVlIHRvIGV4dGVuZCB0aGUgZnVydGhlc3QgcmVhY2hpbmcgcG9pbnQgaW4gdGhlIHByZXNlbnQgZGlhZ29uYWxcclxuICAgICAgICAgICAgICAgIC8vIGFzIGxvbmcgYXMgdGhlIGVsZW1lbnRzIGFyZSBlcXVhbC5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChvcmlnaW5hbEluZGV4ID4gb3JpZ2luYWxTdGFydCAmJiBtb2RpZmllZEluZGV4ID4gbW9kaWZpZWRTdGFydCAmJiB0aGlzLkVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxJbmRleCwgbW9kaWZpZWRJbmRleCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4LS07XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRJbmRleC0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV2ZXJzZVBvaW50c1tkaWFnb25hbF0gPSBvcmlnaW5hbEluZGV4O1xyXG4gICAgICAgICAgICAgICAgLy8gU1RFUCA0OiBJZiBkZWx0YSBpcyBldmVuIChvdmVybGFwIGZpcnN0IGhhcHBlbnMgb24gcmV2ZXJzZSB3aGVuIGRlbHRhIGlzIGV2ZW4pXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgZGlhZ29uYWwgaXMgaW4gdGhlIHJhbmdlIG9mIGZvcndhcmQgZGlhZ29uYWxzIGNvbXB1dGVkIGZvciBudW1EaWZmZXJlbmNlc1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBjaGVjayBmb3Igb3ZlcmxhcC5cclxuICAgICAgICAgICAgICAgIGlmIChkZWx0YUlzRXZlbiAmJiBNYXRoLmFicyhkaWFnb25hbCAtIGRpYWdvbmFsRm9yd2FyZEJhc2UpIDw9IG51bURpZmZlcmVuY2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPD0gZm9yd2FyZFBvaW50c1tkaWFnb25hbF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWlkT3JpZ2luYWxBcnJbMF0gPSBvcmlnaW5hbEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaWRNb2RpZmllZEFyclswXSA9IG1vZGlmaWVkSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wT3JpZ2luYWxJbmRleCA+PSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsXSAmJiAxNDQ3IC8qIE1heERpZmZlcmVuY2VzSGlzdG9yeSAqLyA+IDAgJiYgbnVtRGlmZmVyZW5jZXMgPD0gKDE0NDcgLyogTWF4RGlmZmVyZW5jZXNIaXN0b3J5ICovICsgMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJJTkdPISBXZSBvdmVybGFwcGVkLCBhbmQgd2UgaGF2ZSB0aGUgZnVsbCB0cmFjZSBpbiBtZW1vcnkhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5XQUxLVFJBQ0UoZGlhZ29uYWxGb3J3YXJkQmFzZSwgZGlhZ29uYWxGb3J3YXJkU3RhcnQsIGRpYWdvbmFsRm9yd2FyZEVuZCwgZGlhZ29uYWxGb3J3YXJkT2Zmc2V0LCBkaWFnb25hbFJldmVyc2VCYXNlLCBkaWFnb25hbFJldmVyc2VTdGFydCwgZGlhZ29uYWxSZXZlcnNlRW5kLCBkaWFnb25hbFJldmVyc2VPZmZzZXQsIGZvcndhcmRQb2ludHMsIHJldmVyc2VQb2ludHMsIG9yaWdpbmFsSW5kZXgsIG9yaWdpbmFsRW5kLCBtaWRPcmlnaW5hbEFyciwgbW9kaWZpZWRJbmRleCwgbW9kaWZpZWRFbmQsIG1pZE1vZGlmaWVkQXJyLCBkZWx0YUlzRXZlbiwgcXVpdEVhcmx5QXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVpdGhlciBmYWxzZSBvdmVybGFwLCBvciB3ZSBkaWRuJ3QgaGF2ZSBlbm91Z2ggbWVtb3J5IGZvciB0aGUgZnVsbCB0cmFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCByZXR1cm4gdGhlIHJlY3Vyc2lvbiBwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2F2ZSBjdXJyZW50IHZlY3RvcnMgdG8gaGlzdG9yeSBiZWZvcmUgdGhlIG5leHQgaXRlcmF0aW9uXHJcbiAgICAgICAgICAgIGlmIChudW1EaWZmZXJlbmNlcyA8PSAxNDQ3IC8qIE1heERpZmZlcmVuY2VzSGlzdG9yeSAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIGFsbG9jYXRpbmcgc3BhY2UgZm9yIG9uZSBleHRyYSBpbnQsIHdoaWNoIHdlIGZpbGwgd2l0aFxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGluZGV4IG9mIHRoZSBkaWFnb25hbCBiYXNlIGluZGV4XHJcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IG5ldyBJbnQzMkFycmF5KGRpYWdvbmFsRm9yd2FyZEVuZCAtIGRpYWdvbmFsRm9yd2FyZFN0YXJ0ICsgMik7XHJcbiAgICAgICAgICAgICAgICB0ZW1wWzBdID0gZGlhZ29uYWxGb3J3YXJkQmFzZSAtIGRpYWdvbmFsRm9yd2FyZFN0YXJ0ICsgMTtcclxuICAgICAgICAgICAgICAgIE15QXJyYXkuQ29weTIoZm9yd2FyZFBvaW50cywgZGlhZ29uYWxGb3J3YXJkU3RhcnQsIHRlbXAsIDEsIGRpYWdvbmFsRm9yd2FyZEVuZCAtIGRpYWdvbmFsRm9yd2FyZFN0YXJ0ICsgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1fZm9yd2FyZEhpc3RvcnkucHVzaCh0ZW1wKTtcclxuICAgICAgICAgICAgICAgIHRlbXAgPSBuZXcgSW50MzJBcnJheShkaWFnb25hbFJldmVyc2VFbmQgLSBkaWFnb25hbFJldmVyc2VTdGFydCArIDIpO1xyXG4gICAgICAgICAgICAgICAgdGVtcFswXSA9IGRpYWdvbmFsUmV2ZXJzZUJhc2UgLSBkaWFnb25hbFJldmVyc2VTdGFydCArIDE7XHJcbiAgICAgICAgICAgICAgICBNeUFycmF5LkNvcHkyKHJldmVyc2VQb2ludHMsIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0LCB0ZW1wLCAxLCBkaWFnb25hbFJldmVyc2VFbmQgLSBkaWFnb25hbFJldmVyc2VTdGFydCArIDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tX3JldmVyc2VIaXN0b3J5LnB1c2godGVtcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgd2UgZ290IGhlcmUsIHRoZW4gd2UgaGF2ZSB0aGUgZnVsbCB0cmFjZSBpbiBoaXN0b3J5LiBXZSBqdXN0IGhhdmUgdG8gY29udmVydCBpdCB0byBhIGNoYW5nZSBsaXN0XHJcbiAgICAgICAgLy8gTk9URTogVGhpcyBwYXJ0IGlzIGEgYml0IG1lc3N5XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuV0FMS1RSQUNFKGRpYWdvbmFsRm9yd2FyZEJhc2UsIGRpYWdvbmFsRm9yd2FyZFN0YXJ0LCBkaWFnb25hbEZvcndhcmRFbmQsIGRpYWdvbmFsRm9yd2FyZE9mZnNldCwgZGlhZ29uYWxSZXZlcnNlQmFzZSwgZGlhZ29uYWxSZXZlcnNlU3RhcnQsIGRpYWdvbmFsUmV2ZXJzZUVuZCwgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0LCBmb3J3YXJkUG9pbnRzLCByZXZlcnNlUG9pbnRzLCBvcmlnaW5hbEluZGV4LCBvcmlnaW5hbEVuZCwgbWlkT3JpZ2luYWxBcnIsIG1vZGlmaWVkSW5kZXgsIG1vZGlmaWVkRW5kLCBtaWRNb2RpZmllZEFyciwgZGVsdGFJc0V2ZW4sIHF1aXRFYXJseUFycik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNoaWZ0cyB0aGUgZ2l2ZW4gY2hhbmdlcyB0byBwcm92aWRlIGEgbW9yZSBpbnR1aXRpdmUgZGlmZi5cclxuICAgICAqIFdoaWxlIHRoZSBmaXJzdCBlbGVtZW50IGluIGEgZGlmZiBtYXRjaGVzIHRoZSBmaXJzdCBlbGVtZW50IGFmdGVyIHRoZSBkaWZmLFxyXG4gICAgICogd2Ugc2hpZnQgdGhlIGRpZmYgZG93bi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2hhbmdlcyBUaGUgbGlzdCBvZiBjaGFuZ2VzIHRvIHNoaWZ0XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc2hpZnRlZCBjaGFuZ2VzXHJcbiAgICAgKi9cclxuICAgIFByZXR0aWZ5Q2hhbmdlcyhjaGFuZ2VzKSB7XHJcbiAgICAgICAgLy8gU2hpZnQgYWxsIHRoZSBjaGFuZ2VzIGRvd24gZmlyc3RcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY2hhbmdlID0gY2hhbmdlc1tpXTtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdG9wID0gKGkgPCBjaGFuZ2VzLmxlbmd0aCAtIDEpID8gY2hhbmdlc1tpICsgMV0ub3JpZ2luYWxTdGFydCA6IHRoaXMuX29yaWdpbmFsRWxlbWVudHNPckhhc2gubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZFN0b3AgPSAoaSA8IGNoYW5nZXMubGVuZ3RoIC0gMSkgPyBjaGFuZ2VzW2kgKyAxXS5tb2RpZmllZFN0YXJ0IDogdGhpcy5fbW9kaWZpZWRFbGVtZW50c09ySGFzaC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrT3JpZ2luYWwgPSBjaGFuZ2Uub3JpZ2luYWxMZW5ndGggPiAwO1xyXG4gICAgICAgICAgICBjb25zdCBjaGVja01vZGlmaWVkID0gY2hhbmdlLm1vZGlmaWVkTGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgd2hpbGUgKGNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgY2hhbmdlLm9yaWdpbmFsTGVuZ3RoIDwgb3JpZ2luYWxTdG9wICYmXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2UubW9kaWZpZWRTdGFydCArIGNoYW5nZS5tb2RpZmllZExlbmd0aCA8IG1vZGlmaWVkU3RvcCAmJlxyXG4gICAgICAgICAgICAgICAgKCFjaGVja09yaWdpbmFsIHx8IHRoaXMuT3JpZ2luYWxFbGVtZW50c0FyZUVxdWFsKGNoYW5nZS5vcmlnaW5hbFN0YXJ0LCBjaGFuZ2Uub3JpZ2luYWxTdGFydCArIGNoYW5nZS5vcmlnaW5hbExlbmd0aCkpICYmXHJcbiAgICAgICAgICAgICAgICAoIWNoZWNrTW9kaWZpZWQgfHwgdGhpcy5Nb2RpZmllZEVsZW1lbnRzQXJlRXF1YWwoY2hhbmdlLm1vZGlmaWVkU3RhcnQsIGNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgY2hhbmdlLm1vZGlmaWVkTGVuZ3RoKSkpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZS5vcmlnaW5hbFN0YXJ0Kys7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2UubW9kaWZpZWRTdGFydCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBtZXJnZWRDaGFuZ2VBcnIgPSBbbnVsbF07XHJcbiAgICAgICAgICAgIGlmIChpIDwgY2hhbmdlcy5sZW5ndGggLSAxICYmIHRoaXMuQ2hhbmdlc092ZXJsYXAoY2hhbmdlc1tpXSwgY2hhbmdlc1tpICsgMV0sIG1lcmdlZENoYW5nZUFycikpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZXNbaV0gPSBtZXJnZWRDaGFuZ2VBcnJbMF07XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnNwbGljZShpICsgMSwgMSk7XHJcbiAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTaGlmdCBjaGFuZ2VzIGJhY2sgdXAgdW50aWwgd2UgaGl0IGVtcHR5IG9yIHdoaXRlc3BhY2Utb25seSBsaW5lc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBjaGFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IGNoYW5nZXNbaV07XHJcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbFN0b3AgPSAwO1xyXG4gICAgICAgICAgICBsZXQgbW9kaWZpZWRTdG9wID0gMDtcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hhbmdlID0gY2hhbmdlc1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldkNoYW5nZS5vcmlnaW5hbExlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0b3AgPSBwcmV2Q2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBwcmV2Q2hhbmdlLm9yaWdpbmFsTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZDaGFuZ2UubW9kaWZpZWRMZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdG9wID0gcHJldkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgcHJldkNoYW5nZS5tb2RpZmllZExlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjaGVja09yaWdpbmFsID0gY2hhbmdlLm9yaWdpbmFsTGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgY29uc3QgY2hlY2tNb2RpZmllZCA9IGNoYW5nZS5tb2RpZmllZExlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgIGxldCBiZXN0RGVsdGEgPSAwO1xyXG4gICAgICAgICAgICBsZXQgYmVzdFNjb3JlID0gdGhpcy5fYm91bmRhcnlTY29yZShjaGFuZ2Uub3JpZ2luYWxTdGFydCwgY2hhbmdlLm9yaWdpbmFsTGVuZ3RoLCBjaGFuZ2UubW9kaWZpZWRTdGFydCwgY2hhbmdlLm1vZGlmaWVkTGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgZGVsdGEgPSAxOzsgZGVsdGErKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdGFydCA9IGNoYW5nZS5vcmlnaW5hbFN0YXJ0IC0gZGVsdGE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZFN0YXJ0ID0gY2hhbmdlLm1vZGlmaWVkU3RhcnQgLSBkZWx0YTtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbFN0YXJ0IDwgb3JpZ2luYWxTdG9wIHx8IG1vZGlmaWVkU3RhcnQgPCBtb2RpZmllZFN0b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjaGVja09yaWdpbmFsICYmICF0aGlzLk9yaWdpbmFsRWxlbWVudHNBcmVFcXVhbChvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbFN0YXJ0ICsgY2hhbmdlLm9yaWdpbmFsTGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrTW9kaWZpZWQgJiYgIXRoaXMuTW9kaWZpZWRFbGVtZW50c0FyZUVxdWFsKG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkU3RhcnQgKyBjaGFuZ2UubW9kaWZpZWRMZW5ndGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY29yZSA9IHRoaXMuX2JvdW5kYXJ5U2NvcmUob3JpZ2luYWxTdGFydCwgY2hhbmdlLm9yaWdpbmFsTGVuZ3RoLCBtb2RpZmllZFN0YXJ0LCBjaGFuZ2UubW9kaWZpZWRMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjb3JlID4gYmVzdFNjb3JlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVzdERlbHRhID0gZGVsdGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2hhbmdlLm9yaWdpbmFsU3RhcnQgLT0gYmVzdERlbHRhO1xyXG4gICAgICAgICAgICBjaGFuZ2UubW9kaWZpZWRTdGFydCAtPSBiZXN0RGVsdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjaGFuZ2VzO1xyXG4gICAgfVxyXG4gICAgX09yaWdpbmFsSXNCb3VuZGFyeShpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA8PSAwIHx8IGluZGV4ID49IHRoaXMuX29yaWdpbmFsRWxlbWVudHNPckhhc2gubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9oYXNTdHJpbmdzICYmIC9eXFxzKiQvLnRlc3QodGhpcy5fb3JpZ2luYWxTdHJpbmdFbGVtZW50c1tpbmRleF0pKTtcclxuICAgIH1cclxuICAgIF9PcmlnaW5hbFJlZ2lvbklzQm91bmRhcnkob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxMZW5ndGgpIHtcclxuICAgICAgICBpZiAodGhpcy5fT3JpZ2luYWxJc0JvdW5kYXJ5KG9yaWdpbmFsU3RhcnQpIHx8IHRoaXMuX09yaWdpbmFsSXNCb3VuZGFyeShvcmlnaW5hbFN0YXJ0IC0gMSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcmlnaW5hbExlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxFbmQgPSBvcmlnaW5hbFN0YXJ0ICsgb3JpZ2luYWxMZW5ndGg7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9PcmlnaW5hbElzQm91bmRhcnkob3JpZ2luYWxFbmQgLSAxKSB8fCB0aGlzLl9PcmlnaW5hbElzQm91bmRhcnkob3JpZ2luYWxFbmQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBfTW9kaWZpZWRJc0JvdW5kYXJ5KGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4IDw9IDAgfHwgaW5kZXggPj0gdGhpcy5fbW9kaWZpZWRFbGVtZW50c09ySGFzaC5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKHRoaXMuX2hhc1N0cmluZ3MgJiYgL15cXHMqJC8udGVzdCh0aGlzLl9tb2RpZmllZFN0cmluZ0VsZW1lbnRzW2luZGV4XSkpO1xyXG4gICAgfVxyXG4gICAgX01vZGlmaWVkUmVnaW9uSXNCb3VuZGFyeShtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9Nb2RpZmllZElzQm91bmRhcnkobW9kaWZpZWRTdGFydCkgfHwgdGhpcy5fTW9kaWZpZWRJc0JvdW5kYXJ5KG1vZGlmaWVkU3RhcnQgLSAxKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1vZGlmaWVkTGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZEVuZCA9IG1vZGlmaWVkU3RhcnQgKyBtb2RpZmllZExlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX01vZGlmaWVkSXNCb3VuZGFyeShtb2RpZmllZEVuZCAtIDEpIHx8IHRoaXMuX01vZGlmaWVkSXNCb3VuZGFyeShtb2RpZmllZEVuZCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIF9ib3VuZGFyeVNjb3JlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsTGVuZ3RoLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU2NvcmUgPSAodGhpcy5fT3JpZ2luYWxSZWdpb25Jc0JvdW5kYXJ5KG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsTGVuZ3RoKSA/IDEgOiAwKTtcclxuICAgICAgICBjb25zdCBtb2RpZmllZFNjb3JlID0gKHRoaXMuX01vZGlmaWVkUmVnaW9uSXNCb3VuZGFyeShtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCkgPyAxIDogMCk7XHJcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbFNjb3JlICsgbW9kaWZpZWRTY29yZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbmNhdGVuYXRlcyB0aGUgdHdvIGlucHV0IERpZmZDaGFuZ2UgbGlzdHMgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZ1xyXG4gICAgICogbGlzdC5cclxuICAgICAqIEBwYXJhbSBUaGUgbGVmdCBjaGFuZ2VzXHJcbiAgICAgKiBAcGFyYW0gVGhlIHJpZ2h0IGNoYW5nZXNcclxuICAgICAqIEByZXR1cm5zIFRoZSBjb25jYXRlbmF0ZWQgbGlzdFxyXG4gICAgICovXHJcbiAgICBDb25jYXRlbmF0ZUNoYW5nZXMobGVmdCwgcmlnaHQpIHtcclxuICAgICAgICBsZXQgbWVyZ2VkQ2hhbmdlQXJyID0gW107XHJcbiAgICAgICAgaWYgKGxlZnQubGVuZ3RoID09PSAwIHx8IHJpZ2h0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHJpZ2h0Lmxlbmd0aCA+IDApID8gcmlnaHQgOiBsZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLkNoYW5nZXNPdmVybGFwKGxlZnRbbGVmdC5sZW5ndGggLSAxXSwgcmlnaHRbMF0sIG1lcmdlZENoYW5nZUFycikpIHtcclxuICAgICAgICAgICAgLy8gU2luY2Ugd2UgYnJlYWsgdGhlIHByb2JsZW0gZG93biByZWN1cnNpdmVseSwgaXQgaXMgcG9zc2libGUgdGhhdCB3ZVxyXG4gICAgICAgICAgICAvLyBtaWdodCByZWN1cnNlIGluIHRoZSBtaWRkbGUgb2YgYSBjaGFuZ2UgdGhlcmVieSBzcGxpdHRpbmcgaXQgaW50b1xyXG4gICAgICAgICAgICAvLyB0d28gY2hhbmdlcy4gSGVyZSBpbiB0aGUgY29tYmluaW5nIHN0YWdlLCB3ZSBkZXRlY3QgYW5kIGZ1c2UgdGhvc2VcclxuICAgICAgICAgICAgLy8gY2hhbmdlcyBiYWNrIHRvZ2V0aGVyXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShsZWZ0Lmxlbmd0aCArIHJpZ2h0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICBNeUFycmF5LkNvcHkobGVmdCwgMCwgcmVzdWx0LCAwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICByZXN1bHRbbGVmdC5sZW5ndGggLSAxXSA9IG1lcmdlZENoYW5nZUFyclswXTtcclxuICAgICAgICAgICAgTXlBcnJheS5Db3B5KHJpZ2h0LCAxLCByZXN1bHQsIGxlZnQubGVuZ3RoLCByaWdodC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShsZWZ0Lmxlbmd0aCArIHJpZ2h0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIE15QXJyYXkuQ29weShsZWZ0LCAwLCByZXN1bHQsIDAsIGxlZnQubGVuZ3RoKTtcclxuICAgICAgICAgICAgTXlBcnJheS5Db3B5KHJpZ2h0LCAwLCByZXN1bHQsIGxlZnQubGVuZ3RoLCByaWdodC5sZW5ndGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gY2hhbmdlcyBvdmVybGFwIGFuZCBjYW4gYmUgbWVyZ2VkIGludG8gYSBzaW5nbGVcclxuICAgICAqIGNoYW5nZVxyXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgY2hhbmdlXHJcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IGNoYW5nZVxyXG4gICAgICogQHBhcmFtIG1lcmdlZENoYW5nZSBUaGUgbWVyZ2VkIGNoYW5nZSBpZiB0aGUgdHdvIG92ZXJsYXAsIG51bGwgb3RoZXJ3aXNlXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB0d28gY2hhbmdlcyBvdmVybGFwXHJcbiAgICAgKi9cclxuICAgIENoYW5nZXNPdmVybGFwKGxlZnQsIHJpZ2h0LCBtZXJnZWRDaGFuZ2VBcnIpIHtcclxuICAgICAgICBEZWJ1Zy5Bc3NlcnQobGVmdC5vcmlnaW5hbFN0YXJ0IDw9IHJpZ2h0Lm9yaWdpbmFsU3RhcnQsICdMZWZ0IGNoYW5nZSBpcyBub3QgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHJpZ2h0IGNoYW5nZScpO1xyXG4gICAgICAgIERlYnVnLkFzc2VydChsZWZ0Lm1vZGlmaWVkU3RhcnQgPD0gcmlnaHQubW9kaWZpZWRTdGFydCwgJ0xlZnQgY2hhbmdlIGlzIG5vdCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gcmlnaHQgY2hhbmdlJyk7XHJcbiAgICAgICAgaWYgKGxlZnQub3JpZ2luYWxTdGFydCArIGxlZnQub3JpZ2luYWxMZW5ndGggPj0gcmlnaHQub3JpZ2luYWxTdGFydCB8fCBsZWZ0Lm1vZGlmaWVkU3RhcnQgKyBsZWZ0Lm1vZGlmaWVkTGVuZ3RoID49IHJpZ2h0Lm1vZGlmaWVkU3RhcnQpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdGFydCA9IGxlZnQub3JpZ2luYWxTdGFydDtcclxuICAgICAgICAgICAgbGV0IG9yaWdpbmFsTGVuZ3RoID0gbGVmdC5vcmlnaW5hbExlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRTdGFydCA9IGxlZnQubW9kaWZpZWRTdGFydDtcclxuICAgICAgICAgICAgbGV0IG1vZGlmaWVkTGVuZ3RoID0gbGVmdC5tb2RpZmllZExlbmd0aDtcclxuICAgICAgICAgICAgaWYgKGxlZnQub3JpZ2luYWxTdGFydCArIGxlZnQub3JpZ2luYWxMZW5ndGggPj0gcmlnaHQub3JpZ2luYWxTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxMZW5ndGggPSByaWdodC5vcmlnaW5hbFN0YXJ0ICsgcmlnaHQub3JpZ2luYWxMZW5ndGggLSBsZWZ0Lm9yaWdpbmFsU3RhcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxlZnQubW9kaWZpZWRTdGFydCArIGxlZnQubW9kaWZpZWRMZW5ndGggPj0gcmlnaHQubW9kaWZpZWRTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRMZW5ndGggPSByaWdodC5tb2RpZmllZFN0YXJ0ICsgcmlnaHQubW9kaWZpZWRMZW5ndGggLSBsZWZ0Lm1vZGlmaWVkU3RhcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWVyZ2VkQ2hhbmdlQXJyWzBdID0gbmV3IERpZmZDaGFuZ2Uob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxMZW5ndGgsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkTGVuZ3RoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtZXJnZWRDaGFuZ2VBcnJbMF0gPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHVzZWQgdG8gY2xpcCBhIGRpYWdvbmFsIGluZGV4IHRvIHRoZSByYW5nZSBvZiB2YWxpZFxyXG4gICAgICogZGlhZ29uYWxzLiBUaGlzIGFsc28gZGVjaWRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgZGlhZ29uYWwgaW5kZXgsXHJcbiAgICAgKiBpZiBpdCBleGNlZWRzIHRoZSBib3VuZGFyeSwgc2hvdWxkIGJlIGNsaXBwZWQgdG8gdGhlIGJvdW5kYXJ5IG9yIGNsaXBwZWRcclxuICAgICAqIG9uZSBpbnNpZGUgdGhlIGJvdW5kYXJ5IGRlcGVuZGluZyBvbiB0aGUgRXZlbi9PZGQgc3RhdHVzIG9mIHRoZSBib3VuZGFyeVxyXG4gICAgICogYW5kIG51bURpZmZlcmVuY2VzLlxyXG4gICAgICogQHBhcmFtIGRpYWdvbmFsIFRoZSBpbmRleCBvZiB0aGUgZGlhZ29uYWwgdG8gY2xpcC5cclxuICAgICAqIEBwYXJhbSBudW1EaWZmZXJlbmNlcyBUaGUgY3VycmVudCBudW1iZXIgb2YgZGlmZmVyZW5jZXMgYmVpbmcgaXRlcmF0ZWQgdXBvbi5cclxuICAgICAqIEBwYXJhbSBkaWFnb25hbEJhc2VJbmRleCBUaGUgYmFzZSByZWZlcmVuY2UgZGlhZ29uYWwuXHJcbiAgICAgKiBAcGFyYW0gbnVtRGlhZ29uYWxzIFRoZSB0b3RhbCBudW1iZXIgb2YgZGlhZ29uYWxzLlxyXG4gICAgICogQHJldHVybnMgVGhlIGNsaXBwZWQgZGlhZ29uYWwgaW5kZXguXHJcbiAgICAgKi9cclxuICAgIENsaXBEaWFnb25hbEJvdW5kKGRpYWdvbmFsLCBudW1EaWZmZXJlbmNlcywgZGlhZ29uYWxCYXNlSW5kZXgsIG51bURpYWdvbmFscykge1xyXG4gICAgICAgIGlmIChkaWFnb25hbCA+PSAwICYmIGRpYWdvbmFsIDwgbnVtRGlhZ29uYWxzKSB7XHJcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gY2xpcCwgaXRzIGluIHJhbmdlXHJcbiAgICAgICAgICAgIHJldHVybiBkaWFnb25hbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGlhZ29uYWxzQmVsb3c6IFRoZSBudW1iZXIgb2YgZGlhZ29uYWxzIGJlbG93IHRoZSByZWZlcmVuY2UgZGlhZ29uYWxcclxuICAgICAgICAvLyBkaWFnb25hbHNBYm92ZTogVGhlIG51bWJlciBvZiBkaWFnb25hbHMgYWJvdmUgdGhlIHJlZmVyZW5jZSBkaWFnb25hbFxyXG4gICAgICAgIGNvbnN0IGRpYWdvbmFsc0JlbG93ID0gZGlhZ29uYWxCYXNlSW5kZXg7XHJcbiAgICAgICAgY29uc3QgZGlhZ29uYWxzQWJvdmUgPSBudW1EaWFnb25hbHMgLSBkaWFnb25hbEJhc2VJbmRleCAtIDE7XHJcbiAgICAgICAgY29uc3QgZGlmZkV2ZW4gPSAobnVtRGlmZmVyZW5jZXMgJSAyID09PSAwKTtcclxuICAgICAgICBpZiAoZGlhZ29uYWwgPCAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvd2VyQm91bmRFdmVuID0gKGRpYWdvbmFsc0JlbG93ICUgMiA9PT0gMCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoZGlmZkV2ZW4gPT09IGxvd2VyQm91bmRFdmVuKSA/IDAgOiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdXBwZXJCb3VuZEV2ZW4gPSAoZGlhZ29uYWxzQWJvdmUgJSAyID09PSAwKTtcclxuICAgICAgICAgICAgcmV0dXJuIChkaWZmRXZlbiA9PT0gdXBwZXJCb3VuZEV2ZW4pID8gbnVtRGlhZ29uYWxzIC0gMSA6IG51bURpYWdvbmFscyAtIDI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vKipcclxuICogUmVwcmVzZW50cyBpbmZvcm1hdGlvbiBhYm91dCBhIHNwZWNpZmljIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gc2VxdWVuY2VzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIERpZmZDaGFuZ2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IERpZmZDaGFuZ2Ugd2l0aCB0aGUgZ2l2ZW4gc2VxdWVuY2UgaW5mb3JtYXRpb25cclxuICAgICAqIGFuZCBjb250ZW50LlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbExlbmd0aCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRMZW5ndGgpIHtcclxuICAgICAgICAvL0RlYnVnLkFzc2VydChvcmlnaW5hbExlbmd0aCA+IDAgfHwgbW9kaWZpZWRMZW5ndGggPiAwLCBcIm9yaWdpbmFsTGVuZ3RoIGFuZCBtb2RpZmllZExlbmd0aCBjYW5ub3QgYm90aCBiZSA8PSAwXCIpO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxTdGFydCA9IG9yaWdpbmFsU3RhcnQ7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5hbExlbmd0aCA9IG9yaWdpbmFsTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMubW9kaWZpZWRTdGFydCA9IG1vZGlmaWVkU3RhcnQ7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllZExlbmd0aCA9IG1vZGlmaWVkTGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZW5kIHBvaW50IChleGNsdXNpdmUpIG9mIHRoZSBjaGFuZ2UgaW4gdGhlIG9yaWdpbmFsIHNlcXVlbmNlLlxyXG4gICAgICovXHJcbiAgICBnZXRPcmlnaW5hbEVuZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbFN0YXJ0ICsgdGhpcy5vcmlnaW5hbExlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGVuZCBwb2ludCAoZXhjbHVzaXZlKSBvZiB0aGUgY2hhbmdlIGluIHRoZSBtb2RpZmllZCBzZXF1ZW5jZS5cclxuICAgICAqL1xyXG4gICAgZ2V0TW9kaWZpZWRFbmQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kaWZpZWRTdGFydCArIHRoaXMubW9kaWZpZWRMZW5ndGg7XHJcbiAgICB9XHJcbn1cclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8vIEF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kgb24gRXZlbnRFbWl0dGVyIGJ5IGltcGxlbWVudGluZyBhIHN1YnNldCBvZiB0aGUgaW50ZXJmYWNlLlxyXG5leHBvcnQgY2xhc3MgRXJyb3JIYW5kbGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkRXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5zdGFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlLm1lc3NhZ2UgKyAnXFxuXFxuJyArIGUuc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVtaXQoZSkge1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyKGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb25VbmV4cGVjdGVkRXJyb3IoZSkge1xyXG4gICAgICAgIHRoaXMudW5leHBlY3RlZEVycm9ySGFuZGxlcihlKTtcclxuICAgICAgICB0aGlzLmVtaXQoZSk7XHJcbiAgICB9XHJcbiAgICAvLyBGb3IgZXh0ZXJuYWwgZXJyb3JzLCB3ZSBkb24ndCB3YW50IHRoZSBsaXN0ZW5lcnMgdG8gYmUgY2FsbGVkXHJcbiAgICBvblVuZXhwZWN0ZWRFeHRlcm5hbEVycm9yKGUpIHtcclxuICAgICAgICB0aGlzLnVuZXhwZWN0ZWRFcnJvckhhbmRsZXIoZSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNvbnN0IGVycm9ySGFuZGxlciA9IG5ldyBFcnJvckhhbmRsZXIoKTtcclxuZXhwb3J0IGZ1bmN0aW9uIG9uVW5leHBlY3RlZEVycm9yKGUpIHtcclxuICAgIC8vIGlnbm9yZSBlcnJvcnMgZnJvbSBjYW5jZWxsZWQgcHJvbWlzZXNcclxuICAgIGlmICghaXNQcm9taXNlQ2FuY2VsZWRFcnJvcihlKSkge1xyXG4gICAgICAgIGVycm9ySGFuZGxlci5vblVuZXhwZWN0ZWRFcnJvcihlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIG9uVW5leHBlY3RlZEV4dGVybmFsRXJyb3IoZSkge1xyXG4gICAgLy8gaWdub3JlIGVycm9ycyBmcm9tIGNhbmNlbGxlZCBwcm9taXNlc1xyXG4gICAgaWYgKCFpc1Byb21pc2VDYW5jZWxlZEVycm9yKGUpKSB7XHJcbiAgICAgICAgZXJyb3JIYW5kbGVyLm9uVW5leHBlY3RlZEV4dGVybmFsRXJyb3IoZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1FcnJvckZvclNlcmlhbGl6YXRpb24oZXJyb3IpIHtcclxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgbGV0IHsgbmFtZSwgbWVzc2FnZSB9ID0gZXJyb3I7XHJcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBlcnJvci5zdGFja3RyYWNlIHx8IGVycm9yLnN0YWNrO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICRpc0Vycm9yOiB0cnVlLFxyXG4gICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgICAgICBzdGFja1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyByZXR1cm4gYXMgaXNcclxuICAgIHJldHVybiBlcnJvcjtcclxufVxyXG5jb25zdCBjYW5jZWxlZE5hbWUgPSAnQ2FuY2VsZWQnO1xyXG4vKipcclxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBhIHByb21pc2UgaW4gY2FuY2VsZWQgc3RhdGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2VDYW5jZWxlZEVycm9yKGVycm9yKSB7XHJcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBjYW5jZWxlZE5hbWUgJiYgZXJyb3IubWVzc2FnZSA9PT0gY2FuY2VsZWROYW1lO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGVycm9yIHRoYXQgc2lnbmFscyBjYW5jZWxsYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FuY2VsZWQoKSB7XHJcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihjYW5jZWxlZE5hbWUpO1xyXG4gICAgZXJyb3IubmFtZSA9IGVycm9yLm1lc3NhZ2U7XHJcbiAgICByZXR1cm4gZXJyb3I7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGlsbGVnYWxBcmd1bWVudChuYW1lKSB7XHJcbiAgICBpZiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYElsbGVnYWwgYXJndW1lbnQ6ICR7bmFtZX1gKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0lsbGVnYWwgYXJndW1lbnQnKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaWxsZWdhbFN0YXRlKG5hbWUpIHtcclxuICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgSWxsZWdhbCBzdGF0ZTogJHtuYW1lfWApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignSWxsZWdhbCBzdGF0ZScpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBvblVuZXhwZWN0ZWRFcnJvciB9IGZyb20gJy4vZXJyb3JzLmpzJztcclxuaW1wb3J0IHsgRGlzcG9zYWJsZSwgY29tYmluZWREaXNwb3NhYmxlLCBEaXNwb3NhYmxlU3RvcmUgfSBmcm9tICcuL2xpZmVjeWNsZS5qcyc7XHJcbmltcG9ydCB7IExpbmtlZExpc3QgfSBmcm9tICcuL2xpbmtlZExpc3QuanMnO1xyXG5leHBvcnQgdmFyIEV2ZW50O1xyXG4oZnVuY3Rpb24gKEV2ZW50KSB7XHJcbiAgICBFdmVudC5Ob25lID0gKCkgPT4gRGlzcG9zYWJsZS5Ob25lO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhbiBldmVudCwgcmV0dXJucyBhbm90aGVyIGV2ZW50IHdoaWNoIG9ubHkgZmlyZXMgb25jZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25jZShldmVudCkge1xyXG4gICAgICAgIHJldHVybiAobGlzdGVuZXIsIHRoaXNBcmdzID0gbnVsbCwgZGlzcG9zYWJsZXMpID0+IHtcclxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzLCBpbiBjYXNlIHRoZSBldmVudCBmaXJlcyBkdXJpbmcgdGhlIGxpc3RlbmVyIGNhbGxcclxuICAgICAgICAgICAgbGV0IGRpZEZpcmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICAgICAgcmVzdWx0ID0gZXZlbnQoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlkRmlyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkaWRGaXJlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5jYWxsKHRoaXNBcmdzLCBlKTtcclxuICAgICAgICAgICAgfSwgbnVsbCwgZGlzcG9zYWJsZXMpO1xyXG4gICAgICAgICAgICBpZiAoZGlkRmlyZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBFdmVudC5vbmNlID0gb25jZTtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYW4gZXZlbnQgYW5kIGEgYG1hcGAgZnVuY3Rpb24sIHJldHVybnMgYW5vdGhlciBldmVudCB3aGljaCBtYXBzIGVhY2ggZWxlbWVudFxyXG4gICAgICogdGhyb3VnaCB0aGUgbWFwcGluZyBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWFwKGV2ZW50LCBtYXApIHtcclxuICAgICAgICByZXR1cm4gc25hcHNob3QoKGxpc3RlbmVyLCB0aGlzQXJncyA9IG51bGwsIGRpc3Bvc2FibGVzKSA9PiBldmVudChpID0+IGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIG1hcChpKSksIG51bGwsIGRpc3Bvc2FibGVzKSk7XHJcbiAgICB9XHJcbiAgICBFdmVudC5tYXAgPSBtYXA7XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGV2ZW50IGFuZCBhbiBgZWFjaGAgZnVuY3Rpb24sIHJldHVybnMgYW5vdGhlciBpZGVudGljYWwgZXZlbnQgYW5kIGNhbGxzXHJcbiAgICAgKiB0aGUgYGVhY2hgIGZ1bmN0aW9uIHBlciBlYWNoIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvckVhY2goZXZlbnQsIGVhY2gpIHtcclxuICAgICAgICByZXR1cm4gc25hcHNob3QoKGxpc3RlbmVyLCB0aGlzQXJncyA9IG51bGwsIGRpc3Bvc2FibGVzKSA9PiBldmVudChpID0+IHsgZWFjaChpKTsgbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgaSk7IH0sIG51bGwsIGRpc3Bvc2FibGVzKSk7XHJcbiAgICB9XHJcbiAgICBFdmVudC5mb3JFYWNoID0gZm9yRWFjaDtcclxuICAgIGZ1bmN0aW9uIGZpbHRlcihldmVudCwgZmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHNuYXBzaG90KChsaXN0ZW5lciwgdGhpc0FyZ3MgPSBudWxsLCBkaXNwb3NhYmxlcykgPT4gZXZlbnQoZSA9PiBmaWx0ZXIoZSkgJiYgbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgZSksIG51bGwsIGRpc3Bvc2FibGVzKSk7XHJcbiAgICB9XHJcbiAgICBFdmVudC5maWx0ZXIgPSBmaWx0ZXI7XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGV2ZW50LCByZXR1cm5zIHRoZSBzYW1lIGV2ZW50IGJ1dCB0eXBlZCBhcyBgRXZlbnQ8dm9pZD5gLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzaWduYWwoZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBFdmVudC5zaWduYWwgPSBzaWduYWw7XHJcbiAgICBmdW5jdGlvbiBhbnkoLi4uZXZlbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIChsaXN0ZW5lciwgdGhpc0FyZ3MgPSBudWxsLCBkaXNwb3NhYmxlcykgPT4gY29tYmluZWREaXNwb3NhYmxlKC4uLmV2ZW50cy5tYXAoZXZlbnQgPT4gZXZlbnQoZSA9PiBsaXN0ZW5lci5jYWxsKHRoaXNBcmdzLCBlKSwgbnVsbCwgZGlzcG9zYWJsZXMpKSk7XHJcbiAgICB9XHJcbiAgICBFdmVudC5hbnkgPSBhbnk7XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGV2ZW50IGFuZCBhIGBtZXJnZWAgZnVuY3Rpb24sIHJldHVybnMgYW5vdGhlciBldmVudCB3aGljaCBtYXBzIGVhY2ggZWxlbWVudFxyXG4gICAgICogYW5kIHRoZSBjdW11bGF0aXZlIHJlc3VsdCB0aHJvdWdoIHRoZSBgbWVyZ2VgIGZ1bmN0aW9uLiBTaW1pbGFyIHRvIGBtYXBgLCBidXQgd2l0aCBtZW1vcnkuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlZHVjZShldmVudCwgbWVyZ2UsIGluaXRpYWwpIHtcclxuICAgICAgICBsZXQgb3V0cHV0ID0gaW5pdGlhbDtcclxuICAgICAgICByZXR1cm4gbWFwKGV2ZW50LCBlID0+IHtcclxuICAgICAgICAgICAgb3V0cHV0ID0gbWVyZ2Uob3V0cHV0LCBlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIEV2ZW50LnJlZHVjZSA9IHJlZHVjZTtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBjaGFpbiBvZiBldmVudCBwcm9jZXNzaW5nIGZ1bmN0aW9ucyAoZmlsdGVyLCBtYXAsIGV0YyksIGVhY2hcclxuICAgICAqIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBwZXIgZXZlbnQgJiBwZXIgbGlzdGVuZXIuIFNuYXBzaG90dGluZyBhbiBldmVudFxyXG4gICAgICogY2hhaW4gYWxsb3dzIGVhY2ggZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBqdXN0IG9uY2UgcGVyIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzbmFwc2hvdChldmVudCkge1xyXG4gICAgICAgIGxldCBsaXN0ZW5lcjtcclxuICAgICAgICBjb25zdCBlbWl0dGVyID0gbmV3IEVtaXR0ZXIoe1xyXG4gICAgICAgICAgICBvbkZpcnN0TGlzdGVuZXJBZGQoKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGV2ZW50KGVtaXR0ZXIuZmlyZSwgZW1pdHRlcik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uTGFzdExpc3RlbmVyUmVtb3ZlKCkge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXIuZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBFdmVudC5zbmFwc2hvdCA9IHNuYXBzaG90O1xyXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZXZlbnQsIG1lcmdlLCBkZWxheSA9IDEwMCwgbGVhZGluZyA9IGZhbHNlLCBsZWFrV2FybmluZ1RocmVzaG9sZCkge1xyXG4gICAgICAgIGxldCBzdWJzY3JpcHRpb247XHJcbiAgICAgICAgbGV0IG91dHB1dCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBsZXQgaGFuZGxlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGxldCBudW1EZWJvdW5jZWRDYWxscyA9IDA7XHJcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBFbWl0dGVyKHtcclxuICAgICAgICAgICAgbGVha1dhcm5pbmdUaHJlc2hvbGQsXHJcbiAgICAgICAgICAgIG9uRmlyc3RMaXN0ZW5lckFkZCgpIHtcclxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IGV2ZW50KGN1ciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtRGVib3VuY2VkQ2FsbHMrKztcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBtZXJnZShvdXRwdXQsIGN1cik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlYWRpbmcgJiYgIWhhbmRsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmZpcmUob3V0cHV0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX291dHB1dCA9IG91dHB1dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGVhZGluZyB8fCBudW1EZWJvdW5jZWRDYWxscyA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZmlyZShfb3V0cHV0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1EZWJvdW5jZWRDYWxscyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uTGFzdExpc3RlbmVyUmVtb3ZlKCkge1xyXG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBlbWl0dGVyLmV2ZW50O1xyXG4gICAgfVxyXG4gICAgRXZlbnQuZGVib3VuY2UgPSBkZWJvdW5jZTtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYW4gZXZlbnQsIGl0IHJldHVybnMgYW5vdGhlciBldmVudCB3aGljaCBmaXJlcyBvbmx5IG9uY2UgYW5kIGFzIHNvb24gYXNcclxuICAgICAqIHRoZSBpbnB1dCBldmVudCBlbWl0cy4gVGhlIGV2ZW50IGRhdGEgaXMgdGhlIG51bWJlciBvZiBtaWxsaXMgaXQgdG9vayBmb3IgdGhlXHJcbiAgICAgKiBldmVudCB0byBmaXJlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzdG9wd2F0Y2goZXZlbnQpIHtcclxuICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIHJldHVybiBtYXAob25jZShldmVudCksIF8gPT4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydCk7XHJcbiAgICB9XHJcbiAgICBFdmVudC5zdG9wd2F0Y2ggPSBzdG9wd2F0Y2g7XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGV2ZW50LCBpdCByZXR1cm5zIGFub3RoZXIgZXZlbnQgd2hpY2ggZmlyZXMgb25seSB3aGVuIHRoZSBldmVudFxyXG4gICAgICogZWxlbWVudCBjaGFuZ2VzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBsYXRjaChldmVudCkge1xyXG4gICAgICAgIGxldCBmaXJzdENhbGwgPSB0cnVlO1xyXG4gICAgICAgIGxldCBjYWNoZTtcclxuICAgICAgICByZXR1cm4gZmlsdGVyKGV2ZW50LCB2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEVtaXQgPSBmaXJzdENhbGwgfHwgdmFsdWUgIT09IGNhY2hlO1xyXG4gICAgICAgICAgICBmaXJzdENhbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgY2FjaGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHNob3VsZEVtaXQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBFdmVudC5sYXRjaCA9IGxhdGNoO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCdWZmZXJzIHRoZSBwcm92aWRlZCBldmVudCB1bnRpbCBhIGZpcnN0IGxpc3RlbmVyIGNvbWVzXHJcbiAgICAgKiBhbG9uZywgYXQgd2hpY2ggcG9pbnQgZmlyZSBhbGwgdGhlIGV2ZW50cyBhdCBvbmNlIGFuZFxyXG4gICAgICogcGlwZSB0aGUgZXZlbnQgZnJvbSB0aGVuIG9uLlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRW1pdHRlcjxudW1iZXI+KCk7XHJcbiAgICAgKiBjb25zdCBldmVudCA9IGVtaXR0ZXIuZXZlbnQ7XHJcbiAgICAgKiBjb25zdCBidWZmZXJlZEV2ZW50ID0gYnVmZmVyKGV2ZW50KTtcclxuICAgICAqXHJcbiAgICAgKiBlbWl0dGVyLmZpcmUoMSk7XHJcbiAgICAgKiBlbWl0dGVyLmZpcmUoMik7XHJcbiAgICAgKiBlbWl0dGVyLmZpcmUoMyk7XHJcbiAgICAgKiAvLyBub3RoaW5nLi4uXHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgbGlzdGVuZXIgPSBidWZmZXJlZEV2ZW50KG51bSA9PiBjb25zb2xlLmxvZyhudW0pKTtcclxuICAgICAqIC8vIDEsIDIsIDNcclxuICAgICAqXHJcbiAgICAgKiBlbWl0dGVyLmZpcmUoNCk7XHJcbiAgICAgKiAvLyA0XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYnVmZmVyKGV2ZW50LCBuZXh0VGljayA9IGZhbHNlLCBfYnVmZmVyID0gW10pIHtcclxuICAgICAgICBsZXQgYnVmZmVyID0gX2J1ZmZlci5zbGljZSgpO1xyXG4gICAgICAgIGxldCBsaXN0ZW5lciA9IGV2ZW50KGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIucHVzaChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZmlyZShlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGZsdXNoID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIuZm9yRWFjaChlID0+IGVtaXR0ZXIuZmlyZShlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnVmZmVyID0gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRW1pdHRlcih7XHJcbiAgICAgICAgICAgIG9uRmlyc3RMaXN0ZW5lckFkZCgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGV2ZW50KGUgPT4gZW1pdHRlci5maXJlKGUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25GaXJzdExpc3RlbmVyRGlkQWRkKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VGljaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkxhc3RMaXN0ZW5lclJlbW92ZSgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBlbWl0dGVyLmV2ZW50O1xyXG4gICAgfVxyXG4gICAgRXZlbnQuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgY2xhc3MgQ2hhaW5hYmxlRXZlbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWFwKGZuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhaW5hYmxlRXZlbnQobWFwKHRoaXMuZXZlbnQsIGZuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvckVhY2goZm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFpbmFibGVFdmVudChmb3JFYWNoKHRoaXMuZXZlbnQsIGZuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbHRlcihmbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYWluYWJsZUV2ZW50KGZpbHRlcih0aGlzLmV2ZW50LCBmbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWR1Y2UobWVyZ2UsIGluaXRpYWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFpbmFibGVFdmVudChyZWR1Y2UodGhpcy5ldmVudCwgbWVyZ2UsIGluaXRpYWwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGF0Y2goKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhaW5hYmxlRXZlbnQobGF0Y2godGhpcy5ldmVudCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWJvdW5jZShtZXJnZSwgZGVsYXkgPSAxMDAsIGxlYWRpbmcgPSBmYWxzZSwgbGVha1dhcm5pbmdUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFpbmFibGVFdmVudChkZWJvdW5jZSh0aGlzLmV2ZW50LCBtZXJnZSwgZGVsYXksIGxlYWRpbmcsIGxlYWtXYXJuaW5nVGhyZXNob2xkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9uKGxpc3RlbmVyLCB0aGlzQXJncywgZGlzcG9zYWJsZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnQobGlzdGVuZXIsIHRoaXNBcmdzLCBkaXNwb3NhYmxlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9uY2UobGlzdGVuZXIsIHRoaXNBcmdzLCBkaXNwb3NhYmxlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gb25jZSh0aGlzLmV2ZW50KShsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjaGFpbihldmVudCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2hhaW5hYmxlRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG4gICAgRXZlbnQuY2hhaW4gPSBjaGFpbjtcclxuICAgIGZ1bmN0aW9uIGZyb21Ob2RlRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGV2ZW50TmFtZSwgbWFwID0gaWQgPT4gaWQpIHtcclxuICAgICAgICBjb25zdCBmbiA9ICguLi5hcmdzKSA9PiByZXN1bHQuZmlyZShtYXAoLi4uYXJncykpO1xyXG4gICAgICAgIGNvbnN0IG9uRmlyc3RMaXN0ZW5lckFkZCA9ICgpID0+IGVtaXR0ZXIub24oZXZlbnROYW1lLCBmbik7XHJcbiAgICAgICAgY29uc3Qgb25MYXN0TGlzdGVuZXJSZW1vdmUgPSAoKSA9PiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgZm4pO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBFbWl0dGVyKHsgb25GaXJzdExpc3RlbmVyQWRkLCBvbkxhc3RMaXN0ZW5lclJlbW92ZSB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LmV2ZW50O1xyXG4gICAgfVxyXG4gICAgRXZlbnQuZnJvbU5vZGVFdmVudEVtaXR0ZXIgPSBmcm9tTm9kZUV2ZW50RW1pdHRlcjtcclxuICAgIGZ1bmN0aW9uIGZyb21ET01FdmVudEVtaXR0ZXIoZW1pdHRlciwgZXZlbnROYW1lLCBtYXAgPSBpZCA9PiBpZCkge1xyXG4gICAgICAgIGNvbnN0IGZuID0gKC4uLmFyZ3MpID0+IHJlc3VsdC5maXJlKG1hcCguLi5hcmdzKSk7XHJcbiAgICAgICAgY29uc3Qgb25GaXJzdExpc3RlbmVyQWRkID0gKCkgPT4gZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4pO1xyXG4gICAgICAgIGNvbnN0IG9uTGFzdExpc3RlbmVyUmVtb3ZlID0gKCkgPT4gZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4pO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBFbWl0dGVyKHsgb25GaXJzdExpc3RlbmVyQWRkLCBvbkxhc3RMaXN0ZW5lclJlbW92ZSB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LmV2ZW50O1xyXG4gICAgfVxyXG4gICAgRXZlbnQuZnJvbURPTUV2ZW50RW1pdHRlciA9IGZyb21ET01FdmVudEVtaXR0ZXI7XHJcbiAgICBmdW5jdGlvbiBmcm9tUHJvbWlzZShwcm9taXNlKSB7XHJcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XHJcbiAgICAgICAgbGV0IHNob3VsZEVtaXQgPSBmYWxzZTtcclxuICAgICAgICBwcm9taXNlXHJcbiAgICAgICAgICAgIC50aGVuKHVuZGVmaW5lZCwgKCkgPT4gbnVsbClcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXNob3VsZEVtaXQpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZW1pdHRlci5maXJlKHVuZGVmaW5lZCksIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzaG91bGRFbWl0ID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gZW1pdHRlci5ldmVudDtcclxuICAgIH1cclxuICAgIEV2ZW50LmZyb21Qcm9taXNlID0gZnJvbVByb21pc2U7XHJcbiAgICBmdW5jdGlvbiB0b1Byb21pc2UoZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYyA9PiBvbmNlKGV2ZW50KShjKSk7XHJcbiAgICB9XHJcbiAgICBFdmVudC50b1Byb21pc2UgPSB0b1Byb21pc2U7XHJcbn0pKEV2ZW50IHx8IChFdmVudCA9IHt9KSk7XHJcbmxldCBfZ2xvYmFsTGVha1dhcm5pbmdUaHJlc2hvbGQgPSAtMTtcclxuY2xhc3MgTGVha2FnZU1vbml0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoY3VzdG9tVGhyZXNob2xkLCBuYW1lID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygxOCkuc2xpY2UoMiwgNSkpIHtcclxuICAgICAgICB0aGlzLmN1c3RvbVRocmVzaG9sZCA9IGN1c3RvbVRocmVzaG9sZDtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuX3dhcm5Db3VudGRvd24gPSAwO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fc3RhY2tzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrcy5jbGVhcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNoZWNrKGxpc3RlbmVyQ291bnQpIHtcclxuICAgICAgICBsZXQgdGhyZXNob2xkID0gX2dsb2JhbExlYWtXYXJuaW5nVGhyZXNob2xkO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jdXN0b21UaHJlc2hvbGQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IHRoaXMuY3VzdG9tVGhyZXNob2xkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhyZXNob2xkIDw9IDAgfHwgbGlzdGVuZXJDb3VudCA8IHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX3N0YWNrcykge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFja3MgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2suc3BsaXQoJ1xcbicpLnNsaWNlKDMpLmpvaW4oJ1xcbicpO1xyXG4gICAgICAgIGNvbnN0IGNvdW50ID0gKHRoaXMuX3N0YWNrcy5nZXQoc3RhY2spIHx8IDApO1xyXG4gICAgICAgIHRoaXMuX3N0YWNrcy5zZXQoc3RhY2ssIGNvdW50ICsgMSk7XHJcbiAgICAgICAgdGhpcy5fd2FybkNvdW50ZG93biAtPSAxO1xyXG4gICAgICAgIGlmICh0aGlzLl93YXJuQ291bnRkb3duIDw9IDApIHtcclxuICAgICAgICAgICAgLy8gb25seSB3YXJuIG9uIGZpcnN0IGV4Y2VlZCBhbmQgdGhlbiBldmVyeSB0aW1lIHRoZSBsaW1pdFxyXG4gICAgICAgICAgICAvLyBpcyBleGNlZWRlZCBieSA1MCUgYWdhaW5cclxuICAgICAgICAgICAgdGhpcy5fd2FybkNvdW50ZG93biA9IHRocmVzaG9sZCAqIDAuNTtcclxuICAgICAgICAgICAgLy8gZmluZCBtb3N0IGZyZXF1ZW50IGxpc3RlbmVyIGFuZCBwcmludCB3YXJuaW5nXHJcbiAgICAgICAgICAgIGxldCB0b3BTdGFjaztcclxuICAgICAgICAgICAgbGV0IHRvcENvdW50ID0gMDtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBbc3RhY2ssIGNvdW50XSBvZiB0aGlzLl9zdGFja3MpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdG9wU3RhY2sgfHwgdG9wQ291bnQgPCBjb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcFN0YWNrID0gc3RhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9wQ291bnQgPSBjb3VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFske3RoaXMubmFtZX1dIHBvdGVudGlhbCBsaXN0ZW5lciBMRUFLIGRldGVjdGVkLCBoYXZpbmcgJHtsaXN0ZW5lckNvdW50fSBsaXN0ZW5lcnMgYWxyZWFkeS4gTU9TVCBmcmVxdWVudCBsaXN0ZW5lciAoJHt0b3BDb3VudH0pOmApO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4odG9wU3RhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb3VudCA9ICh0aGlzLl9zdGFja3MuZ2V0KHN0YWNrKSB8fCAwKTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhY2tzLnNldChzdGFjaywgY291bnQgLSAxKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgRW1pdHRlciBjYW4gYmUgdXNlZCB0byBleHBvc2UgYW4gRXZlbnQgdG8gdGhlIHB1YmxpY1xyXG4gKiB0byBmaXJlIGl0IGZyb20gdGhlIGluc2lkZXMuXHJcbiAqIFNhbXBsZTpcclxuICAgIGNsYXNzIERvY3VtZW50IHtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfb25EaWRDaGFuZ2UgPSBuZXcgRW1pdHRlcjwodmFsdWU6c3RyaW5nKT0+YW55PigpO1xyXG5cclxuICAgICAgICBwdWJsaWMgb25EaWRDaGFuZ2UgPSB0aGlzLl9vbkRpZENoYW5nZS5ldmVudDtcclxuXHJcbiAgICAgICAgLy8gZ2V0dGVyLXN0eWxlXHJcbiAgICAgICAgLy8gZ2V0IG9uRGlkQ2hhbmdlKCk6IEV2ZW50PCh2YWx1ZTpzdHJpbmcpPT5hbnk+IHtcclxuICAgICAgICAvLyBcdHJldHVybiB0aGlzLl9vbkRpZENoYW5nZS5ldmVudDtcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgX2RvSXQoKSB7XHJcbiAgICAgICAgICAgIC8vLi4uXHJcbiAgICAgICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlLmZpcmUodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICovXHJcbmV4cG9ydCBjbGFzcyBFbWl0dGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuX2xlYWthZ2VNb24gPSBfZ2xvYmFsTGVha1dhcm5pbmdUaHJlc2hvbGQgPiAwXHJcbiAgICAgICAgICAgID8gbmV3IExlYWthZ2VNb25pdG9yKHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5sZWFrV2FybmluZ1RocmVzaG9sZClcclxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZvciB0aGUgcHVibGljIHRvIGFsbG93IHRvIHN1YnNjcmliZVxyXG4gICAgICogdG8gZXZlbnRzIGZyb20gdGhpcyBFbWl0dGVyXHJcbiAgICAgKi9cclxuICAgIGdldCBldmVudCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50ID0gKGxpc3RlbmVyLCB0aGlzQXJncywgZGlzcG9zYWJsZXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gbmV3IExpbmtlZExpc3QoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0TGlzdGVuZXIgPSB0aGlzLl9saXN0ZW5lcnMuaXNFbXB0eSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0TGlzdGVuZXIgJiYgdGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLm9uRmlyc3RMaXN0ZW5lckFkZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub25GaXJzdExpc3RlbmVyQWRkKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlID0gdGhpcy5fbGlzdGVuZXJzLnB1c2goIXRoaXNBcmdzID8gbGlzdGVuZXIgOiBbbGlzdGVuZXIsIHRoaXNBcmdzXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RMaXN0ZW5lciAmJiB0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMub25GaXJzdExpc3RlbmVyRGlkQWRkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkZpcnN0TGlzdGVuZXJEaWRBZGQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLm9uTGlzdGVuZXJEaWRBZGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLm9uTGlzdGVuZXJEaWRBZGQodGhpcywgbGlzdGVuZXIsIHRoaXNBcmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGFuZCByZWNvcmQgdGhpcyBlbWl0dGVyIGZvciBwb3RlbnRpYWwgbGVha2FnZVxyXG4gICAgICAgICAgICAgICAgbGV0IHJlbW92ZU1vbml0b3I7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGVha2FnZU1vbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU1vbml0b3IgPSB0aGlzLl9sZWFrYWdlTW9uLmNoZWNrKHRoaXMuX2xpc3RlbmVycy5zaXplKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlTW9uaXRvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTW9uaXRvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwb3NlID0gRW1pdHRlci5fbm9vcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kaXNwb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLm9uTGFzdExpc3RlbmVyUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzTGlzdGVuZXJzID0gKHRoaXMuX2xpc3RlbmVycyAmJiAhdGhpcy5fbGlzdGVuZXJzLmlzRW1wdHkoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNMaXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkxhc3RMaXN0ZW5lclJlbW92ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3Bvc2FibGVzIGluc3RhbmNlb2YgRGlzcG9zYWJsZVN0b3JlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zYWJsZXMuYWRkKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRpc3Bvc2FibGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGVzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVG8gYmUga2VwdCBwcml2YXRlIHRvIGZpcmUgYW4gZXZlbnQgdG9cclxuICAgICAqIHN1YnNjcmliZXJzXHJcbiAgICAgKi9cclxuICAgIGZpcmUoZXZlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAgIC8vIHB1dCBhbGwgW2xpc3RlbmVyLGV2ZW50XS1wYWlycyBpbnRvIGRlbGl2ZXJ5IHF1ZXVlXHJcbiAgICAgICAgICAgIC8vIHRoZW4gZW1pdCBhbGwgZXZlbnQuIGFuIGlubmVyL25lc3RlZCBldmVudCBtaWdodCBiZVxyXG4gICAgICAgICAgICAvLyB0aGUgZHJpdmVyIG9mIHRoaXNcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kZWxpdmVyeVF1ZXVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWxpdmVyeVF1ZXVlID0gbmV3IExpbmtlZExpc3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9saXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RlbGl2ZXJ5UXVldWUucHVzaChbbGlzdGVuZXIsIGV2ZW50XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2RlbGl2ZXJ5UXVldWUuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtsaXN0ZW5lciwgZXZlbnRdID0gdGhpcy5fZGVsaXZlcnlRdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodW5kZWZpbmVkLCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lclswXS5jYWxsKGxpc3RlbmVyWzFdLCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBvblVuZXhwZWN0ZWRFcnJvcihlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVycykge1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMuY2xlYXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2RlbGl2ZXJ5UXVldWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVsaXZlcnlRdWV1ZS5jbGVhcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fbGVha2FnZU1vbikge1xyXG4gICAgICAgICAgICB0aGlzLl9sZWFrYWdlTW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcbkVtaXR0ZXIuX25vb3AgPSBmdW5jdGlvbiAoKSB7IH07XHJcbmV4cG9ydCBjbGFzcyBQYXVzZWFibGVFbWl0dGVyIGV4dGVuZHMgRW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSAwO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50UXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xyXG4gICAgICAgIHRoaXMuX21lcmdlRm4gPSBvcHRpb25zICYmIG9wdGlvbnMubWVyZ2U7XHJcbiAgICB9XHJcbiAgICBwYXVzZSgpIHtcclxuICAgICAgICB0aGlzLl9pc1BhdXNlZCsrO1xyXG4gICAgfVxyXG4gICAgcmVzdW1lKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCAhPT0gMCAmJiAtLXRoaXMuX2lzUGF1c2VkID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9tZXJnZUZuKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIG1lcmdlIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHNpbmdsZSBjb21wb3NpdGVcclxuICAgICAgICAgICAgICAgIC8vIGV2ZW50LiBtYWtlIGEgY29weSBpbiBjYXNlIGZpcmluZyBwYXVzZXMgdGhpcyBlbWl0dGVyXHJcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudHMgPSB0aGlzLl9ldmVudFF1ZXVlLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50UXVldWUuY2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIHN1cGVyLmZpcmUodGhpcy5fbWVyZ2VGbihldmVudHMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vIG1lcmdpbmcsIGZpcmUgZWFjaCBldmVudCBpbmRpdmlkdWFsbHkgYW5kIHRlc3RcclxuICAgICAgICAgICAgICAgIC8vIHRoYXQgdGhpcyBlbWl0dGVyIGlzbid0IHBhdXNlZCBoYWxmd2F5IHRocm91Z2hcclxuICAgICAgICAgICAgICAgIHdoaWxlICghdGhpcy5faXNQYXVzZWQgJiYgdGhpcy5fZXZlbnRRdWV1ZS5zaXplICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuZmlyZSh0aGlzLl9ldmVudFF1ZXVlLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZmlyZShldmVudCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudFF1ZXVlLnB1c2goZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3VwZXIuZmlyZShldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBFdmVudEJ1ZmZlcmVyIGlzIHVzZWZ1bCBpbiBzaXR1YXRpb25zIGluIHdoaWNoIHlvdSB3YW50XHJcbiAqIHRvIGRlbGF5IGZpcmluZyB5b3VyIGV2ZW50cyBkdXJpbmcgc29tZSBjb2RlLlxyXG4gKiBZb3UgY2FuIHdyYXAgdGhhdCBjb2RlIGFuZCBiZSBzdXJlIHRoYXQgdGhlIGV2ZW50IHdpbGwgbm90XHJcbiAqIGJlIGZpcmVkIGR1cmluZyB0aGF0IHdyYXAuXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBjb25zdCBlbWl0dGVyOiBFbWl0dGVyO1xyXG4gKiBjb25zdCBkZWxheWVyID0gbmV3IEV2ZW50RGVsYXllcigpO1xyXG4gKiBjb25zdCBkZWxheWVkRXZlbnQgPSBkZWxheWVyLndyYXBFdmVudChlbWl0dGVyLmV2ZW50KTtcclxuICpcclxuICogZGVsYXllZEV2ZW50KGNvbnNvbGUubG9nKTtcclxuICpcclxuICogZGVsYXllci5idWZmZXJFdmVudHMoKCkgPT4ge1xyXG4gKiAgIGVtaXR0ZXIuZmlyZSgpOyAvLyBldmVudCB3aWxsIG5vdCBiZSBmaXJlZCB5ZXRcclxuICogfSk7XHJcbiAqXHJcbiAqIC8vIGV2ZW50IHdpbGwgb25seSBiZSBmaXJlZCBhdCB0aGlzIHBvaW50XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEV2ZW50QnVmZmVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5idWZmZXJzID0gW107XHJcbiAgICB9XHJcbiAgICB3cmFwRXZlbnQoZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gKGxpc3RlbmVyLCB0aGlzQXJncywgZGlzcG9zYWJsZXMpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50KGkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXJzW3RoaXMuYnVmZmVycy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIGlmIChidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaCgoKSA9PiBsaXN0ZW5lci5jYWxsKHRoaXNBcmdzLCBpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXNBcmdzLCBpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdW5kZWZpbmVkLCBkaXNwb3NhYmxlcyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGJ1ZmZlckV2ZW50cyhmbikge1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xyXG4gICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGJ1ZmZlcik7XHJcbiAgICAgICAgY29uc3QgciA9IGZuKCk7XHJcbiAgICAgICAgdGhpcy5idWZmZXJzLnBvcCgpO1xyXG4gICAgICAgIGJ1ZmZlci5mb3JFYWNoKGZsdXNoID0+IGZsdXNoKCkpO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIFJlbGF5IGlzIGFuIGV2ZW50IGZvcndhcmRlciB3aGljaCBmdW5jdGlvbnMgYXMgYSByZXBsdWdhYmJsZSBldmVudCBwaXBlLlxyXG4gKiBPbmNlIGNyZWF0ZWQsIHlvdSBjYW4gY29ubmVjdCBhbiBpbnB1dCBldmVudCB0byBpdCBhbmQgaXQgd2lsbCBzaW1wbHkgZm9yd2FyZFxyXG4gKiBldmVudHMgZnJvbSB0aGF0IGlucHV0IGV2ZW50IHRocm91Z2ggaXRzIG93biBgZXZlbnRgIHByb3BlcnR5LiBUaGUgYGlucHV0YFxyXG4gKiBjYW4gYmUgY2hhbmdlZCBhdCBhbnkgcG9pbnQgaW4gdGltZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSZWxheSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmxpc3RlbmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaW5wdXRFdmVudCA9IEV2ZW50Lk5vbmU7XHJcbiAgICAgICAgdGhpcy5pbnB1dEV2ZW50TGlzdGVuZXIgPSBEaXNwb3NhYmxlLk5vbmU7XHJcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoe1xyXG4gICAgICAgICAgICBvbkZpcnN0TGlzdGVuZXJEaWRBZGQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRFdmVudExpc3RlbmVyID0gdGhpcy5pbnB1dEV2ZW50KHRoaXMuZW1pdHRlci5maXJlLCB0aGlzLmVtaXR0ZXIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkxhc3RMaXN0ZW5lclJlbW92ZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRFdmVudExpc3RlbmVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZXZlbnQgPSB0aGlzLmVtaXR0ZXIuZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBzZXQgaW5wdXQoZXZlbnQpIHtcclxuICAgICAgICB0aGlzLmlucHV0RXZlbnQgPSBldmVudDtcclxuICAgICAgICBpZiAodGhpcy5saXN0ZW5pbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dEV2ZW50TGlzdGVuZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0RXZlbnRMaXN0ZW5lciA9IGV2ZW50KHRoaXMuZW1pdHRlci5maXJlLCB0aGlzLmVtaXR0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5pbnB1dEV2ZW50TGlzdGVuZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuZW1pdHRlci5kaXNwb3NlKCk7XHJcbiAgICB9XHJcbn1cclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCAqIGFzIHN0cmluZ3MgZnJvbSAnLi9zdHJpbmdzLmpzJztcclxuLyoqXHJcbiAqIFJldHVybiBhIGhhc2ggdmFsdWUgZm9yIGFuIG9iamVjdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBoYXNoKG9iaikge1xyXG4gICAgcmV0dXJuIGRvSGFzaChvYmosIDApO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBkb0hhc2gob2JqLCBoYXNoVmFsKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGVvZiBvYmopIHtcclxuICAgICAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICAgICAgICBpZiAob2JqID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVySGFzaCgzNDksIGhhc2hWYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5SGFzaChvYmosIGhhc2hWYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RIYXNoKG9iaiwgaGFzaFZhbCk7XHJcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ0hhc2gob2JqLCBoYXNoVmFsKTtcclxuICAgICAgICBjYXNlICdib29sZWFuJzpcclxuICAgICAgICAgICAgcmV0dXJuIGJvb2xlYW5IYXNoKG9iaiwgaGFzaFZhbCk7XHJcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlckhhc2gob2JqLCBoYXNoVmFsKTtcclxuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVySGFzaCg5MzcsIGhhc2hWYWwpO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJIYXNoKDYxNywgaGFzaFZhbCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbnVtYmVySGFzaCh2YWwsIGluaXRpYWxIYXNoVmFsKSB7XHJcbiAgICByZXR1cm4gKCgoaW5pdGlhbEhhc2hWYWwgPDwgNSkgLSBpbml0aWFsSGFzaFZhbCkgKyB2YWwpIHwgMDsgLy8gaGFzaFZhbCAqIDMxICsgY2gsIGtlZXAgYXMgaW50MzJcclxufVxyXG5mdW5jdGlvbiBib29sZWFuSGFzaChiLCBpbml0aWFsSGFzaFZhbCkge1xyXG4gICAgcmV0dXJuIG51bWJlckhhc2goYiA/IDQzMyA6IDg2MywgaW5pdGlhbEhhc2hWYWwpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdIYXNoKHMsIGhhc2hWYWwpIHtcclxuICAgIGhhc2hWYWwgPSBudW1iZXJIYXNoKDE0OTQxNywgaGFzaFZhbCk7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGhhc2hWYWwgPSBudW1iZXJIYXNoKHMuY2hhckNvZGVBdChpKSwgaGFzaFZhbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFzaFZhbDtcclxufVxyXG5mdW5jdGlvbiBhcnJheUhhc2goYXJyLCBpbml0aWFsSGFzaFZhbCkge1xyXG4gICAgaW5pdGlhbEhhc2hWYWwgPSBudW1iZXJIYXNoKDEwNDU3OSwgaW5pdGlhbEhhc2hWYWwpO1xyXG4gICAgcmV0dXJuIGFyci5yZWR1Y2UoKGhhc2hWYWwsIGl0ZW0pID0+IGRvSGFzaChpdGVtLCBoYXNoVmFsKSwgaW5pdGlhbEhhc2hWYWwpO1xyXG59XHJcbmZ1bmN0aW9uIG9iamVjdEhhc2gob2JqLCBpbml0aWFsSGFzaFZhbCkge1xyXG4gICAgaW5pdGlhbEhhc2hWYWwgPSBudW1iZXJIYXNoKDE4MTM4NywgaW5pdGlhbEhhc2hWYWwpO1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikuc29ydCgpLnJlZHVjZSgoaGFzaFZhbCwga2V5KSA9PiB7XHJcbiAgICAgICAgaGFzaFZhbCA9IHN0cmluZ0hhc2goa2V5LCBoYXNoVmFsKTtcclxuICAgICAgICByZXR1cm4gZG9IYXNoKG9ialtrZXldLCBoYXNoVmFsKTtcclxuICAgIH0sIGluaXRpYWxIYXNoVmFsKTtcclxufVxyXG5mdW5jdGlvbiBsZWZ0Um90YXRlKHZhbHVlLCBiaXRzLCB0b3RhbEJpdHMgPSAzMikge1xyXG4gICAgLy8gZGVsdGEgKyBiaXRzID0gdG90YWxCaXRzXHJcbiAgICBjb25zdCBkZWx0YSA9IHRvdGFsQml0cyAtIGJpdHM7XHJcbiAgICAvLyBBbGwgb25lcywgZXhwZWN0IGBkZWx0YWAgemVyb3MgYWxpZ25lZCB0byB0aGUgcmlnaHRcclxuICAgIGNvbnN0IG1hc2sgPSB+KCgxIDw8IGRlbHRhKSAtIDEpO1xyXG4gICAgLy8gSm9pbiAodmFsdWUgbGVmdC1zaGlmdGVkIGBiaXRzYCBiaXRzKSB3aXRoIChtYXNrZWQgdmFsdWUgcmlnaHQtc2hpZnRlZCBgZGVsdGFgIGJpdHMpXHJcbiAgICByZXR1cm4gKCh2YWx1ZSA8PCBiaXRzKSB8ICgobWFzayAmIHZhbHVlKSA+Pj4gZGVsdGEpKSA+Pj4gMDtcclxufVxyXG5mdW5jdGlvbiBmaWxsKGRlc3QsIGluZGV4ID0gMCwgY291bnQgPSBkZXN0LmJ5dGVMZW5ndGgsIHZhbHVlID0gMCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgZGVzdFtpbmRleCArIGldID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbGVmdFBhZCh2YWx1ZSwgbGVuZ3RoLCBjaGFyID0gJzAnKSB7XHJcbiAgICB3aGlsZSAodmFsdWUubGVuZ3RoIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdmFsdWUgPSBjaGFyICsgdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gdG9IZXhTdHJpbmcodmFsdWUsIGJpdHNpemUgPSAzMikge1xyXG4gICAgcmV0dXJuIGxlZnRQYWQoKHZhbHVlID4+PiAwKS50b1N0cmluZygxNiksIGJpdHNpemUgLyA0KTtcclxufVxyXG4vKipcclxuICogQSBTSEExIGltcGxlbWVudGF0aW9uIHRoYXQgd29ya3Mgd2l0aCBzdHJpbmdzIGFuZCBkb2VzIG5vdCBhbGxvY2F0ZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBTdHJpbmdTSEExIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2gwID0gMHg2NzQ1MjMwMTtcclxuICAgICAgICB0aGlzLl9oMSA9IDB4RUZDREFCODk7XHJcbiAgICAgICAgdGhpcy5faDIgPSAweDk4QkFEQ0ZFO1xyXG4gICAgICAgIHRoaXMuX2gzID0gMHgxMDMyNTQ3NjtcclxuICAgICAgICB0aGlzLl9oNCA9IDB4QzNEMkUxRjA7XHJcbiAgICAgICAgdGhpcy5fYnVmZiA9IG5ldyBVaW50OEFycmF5KDY0IC8qIEJMT0NLX1NJWkUgKi8gKyAzIC8qIHRvIGZpdCBhbnkgdXRmLTggKi8pO1xyXG4gICAgICAgIHRoaXMuX2J1ZmZEViA9IG5ldyBEYXRhVmlldyh0aGlzLl9idWZmLmJ1ZmZlcik7XHJcbiAgICAgICAgdGhpcy5fYnVmZkxlbiA9IDA7XHJcbiAgICAgICAgdGhpcy5fdG90YWxMZW4gPSAwO1xyXG4gICAgICAgIHRoaXMuX2xlZnRvdmVySGlnaFN1cnJvZ2F0ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShzdHIpIHtcclxuICAgICAgICBjb25zdCBzdHJMZW4gPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgIGlmIChzdHJMZW4gPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBidWZmID0gdGhpcy5fYnVmZjtcclxuICAgICAgICBsZXQgYnVmZkxlbiA9IHRoaXMuX2J1ZmZMZW47XHJcbiAgICAgICAgbGV0IGxlZnRvdmVySGlnaFN1cnJvZ2F0ZSA9IHRoaXMuX2xlZnRvdmVySGlnaFN1cnJvZ2F0ZTtcclxuICAgICAgICBsZXQgY2hhckNvZGU7XHJcbiAgICAgICAgbGV0IG9mZnNldDtcclxuICAgICAgICBpZiAobGVmdG92ZXJIaWdoU3Vycm9nYXRlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGNoYXJDb2RlID0gbGVmdG92ZXJIaWdoU3Vycm9nYXRlO1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAtMTtcclxuICAgICAgICAgICAgbGVmdG92ZXJIaWdoU3Vycm9nYXRlID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGxldCBjb2RlUG9pbnQgPSBjaGFyQ29kZTtcclxuICAgICAgICAgICAgaWYgKHN0cmluZ3MuaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCArIDEgPCBzdHJMZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChvZmZzZXQgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5ncy5pc0xvd1N1cnJvZ2F0ZShuZXh0Q2hhckNvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSBzdHJpbmdzLmNvbXB1dGVDb2RlUG9pbnQoY2hhckNvZGUsIG5leHRDaGFyQ29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbGxlZ2FsID0+IHVuaWNvZGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IDY1NTMzIC8qIFVOSUNPREVfUkVQTEFDRU1FTlQgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbGFzdCBjaGFyYWN0ZXIgaXMgYSBzdXJyb2dhdGUgcGFpclxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRvdmVySGlnaFN1cnJvZ2F0ZSA9IGNoYXJDb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmluZ3MuaXNMb3dTdXJyb2dhdGUoY2hhckNvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbGxlZ2FsID0+IHVuaWNvZGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSA2NTUzMyAvKiBVTklDT0RFX1JFUExBQ0VNRU5UICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJ1ZmZMZW4gPSB0aGlzLl9wdXNoKGJ1ZmYsIGJ1ZmZMZW4sIGNvZGVQb2ludCk7XHJcbiAgICAgICAgICAgIG9mZnNldCsrO1xyXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgc3RyTGVuKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KG9mZnNldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9idWZmTGVuID0gYnVmZkxlbjtcclxuICAgICAgICB0aGlzLl9sZWZ0b3ZlckhpZ2hTdXJyb2dhdGUgPSBsZWZ0b3ZlckhpZ2hTdXJyb2dhdGU7XHJcbiAgICB9XHJcbiAgICBfcHVzaChidWZmLCBidWZmTGVuLCBjb2RlUG9pbnQpIHtcclxuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHgwMDgwKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IGNvZGVQb2ludDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50IDwgMHgwODAwKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTEwMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTExMTEwMDAwMDApID4+PiA2KTtcclxuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMDAwMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDExMTExMSkgPj4+IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTExMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAwMDExMTEwMDAwMDAwMDAwMDApID4+PiAxMik7XHJcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTAwMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAwMDAwMDAxMTExMTEwMDAwMDApID4+PiA2KTtcclxuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMDAwMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDExMTExMSkgPj4+IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMTExMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDExMTAwMDAwMDAwMDAwMDAwMDAwMCkgPj4+IDE4KTtcclxuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMDAwMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDAwMDExMTExMTAwMDAwMDAwMDAwMCkgPj4+IDEyKTtcclxuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMDAwMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDAwMDAwMDAwMDExMTExMTAwMDAwMCkgPj4+IDYpO1xyXG4gICAgICAgICAgICBidWZmW2J1ZmZMZW4rK10gPSAwYjEwMDAwMDAwIHwgKChjb2RlUG9pbnQgJiAwYjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTExMTExKSA+Pj4gMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChidWZmTGVuID49IDY0IC8qIEJMT0NLX1NJWkUgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RlcCgpO1xyXG4gICAgICAgICAgICBidWZmTGVuIC09IDY0IC8qIEJMT0NLX1NJWkUgKi87XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuICs9IDY0IC8qIEJMT0NLX1NJWkUgKi87XHJcbiAgICAgICAgICAgIC8vIHRha2UgbGFzdCAzIGluIGNhc2Ugb2YgVVRGOCBvdmVyZmxvd1xyXG4gICAgICAgICAgICBidWZmWzBdID0gYnVmZls2NCAvKiBCTE9DS19TSVpFICovICsgMF07XHJcbiAgICAgICAgICAgIGJ1ZmZbMV0gPSBidWZmWzY0IC8qIEJMT0NLX1NJWkUgKi8gKyAxXTtcclxuICAgICAgICAgICAgYnVmZlsyXSA9IGJ1ZmZbNjQgLyogQkxPQ0tfU0laRSAqLyArIDJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnVmZkxlbjtcclxuICAgIH1cclxuICAgIGRpZ2VzdCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2ZpbmlzaGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xlZnRvdmVySGlnaFN1cnJvZ2F0ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWxsZWdhbCA9PiB1bmljb2RlIHJlcGxhY2VtZW50IGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGVmdG92ZXJIaWdoU3Vycm9nYXRlID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZMZW4gPSB0aGlzLl9wdXNoKHRoaXMuX2J1ZmYsIHRoaXMuX2J1ZmZMZW4sIDY1NTMzIC8qIFVOSUNPREVfUkVQTEFDRU1FTlQgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuICs9IHRoaXMuX2J1ZmZMZW47XHJcbiAgICAgICAgICAgIHRoaXMuX3dyYXBVcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG9IZXhTdHJpbmcodGhpcy5faDApICsgdG9IZXhTdHJpbmcodGhpcy5faDEpICsgdG9IZXhTdHJpbmcodGhpcy5faDIpICsgdG9IZXhTdHJpbmcodGhpcy5faDMpICsgdG9IZXhTdHJpbmcodGhpcy5faDQpO1xyXG4gICAgfVxyXG4gICAgX3dyYXBVcCgpIHtcclxuICAgICAgICB0aGlzLl9idWZmW3RoaXMuX2J1ZmZMZW4rK10gPSAweDgwO1xyXG4gICAgICAgIGZpbGwodGhpcy5fYnVmZiwgdGhpcy5fYnVmZkxlbik7XHJcbiAgICAgICAgaWYgKHRoaXMuX2J1ZmZMZW4gPiA1Nikge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGVwKCk7XHJcbiAgICAgICAgICAgIGZpbGwodGhpcy5fYnVmZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRoaXMgd2lsbCBmaXQgYmVjYXVzZSB0aGUgbWFudGlzc2EgY2FuIGNvdmVyIHVwIHRvIDUyIGJpdHNcclxuICAgICAgICBjb25zdCBtbCA9IDggKiB0aGlzLl90b3RhbExlbjtcclxuICAgICAgICB0aGlzLl9idWZmRFYuc2V0VWludDMyKDU2LCBNYXRoLmZsb29yKG1sIC8gNDI5NDk2NzI5NiksIGZhbHNlKTtcclxuICAgICAgICB0aGlzLl9idWZmRFYuc2V0VWludDMyKDYwLCBtbCAlIDQyOTQ5NjcyOTYsIGZhbHNlKTtcclxuICAgICAgICB0aGlzLl9zdGVwKCk7XHJcbiAgICB9XHJcbiAgICBfc3RlcCgpIHtcclxuICAgICAgICBjb25zdCBiaWdCbG9jazMyID0gU3RyaW5nU0hBMS5fYmlnQmxvY2szMjtcclxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fYnVmZkRWO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNjQgLyogMTYqNCAqLzsgaiArPSA0KSB7XHJcbiAgICAgICAgICAgIGJpZ0Jsb2NrMzIuc2V0VWludDMyKGosIGRhdGEuZ2V0VWludDMyKGosIGZhbHNlKSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBqID0gNjQ7IGogPCAzMjAgLyogODAqNCAqLzsgaiArPSA0KSB7XHJcbiAgICAgICAgICAgIGJpZ0Jsb2NrMzIuc2V0VWludDMyKGosIGxlZnRSb3RhdGUoKGJpZ0Jsb2NrMzIuZ2V0VWludDMyKGogLSAxMiwgZmFsc2UpIF4gYmlnQmxvY2szMi5nZXRVaW50MzIoaiAtIDMyLCBmYWxzZSkgXiBiaWdCbG9jazMyLmdldFVpbnQzMihqIC0gNTYsIGZhbHNlKSBeIGJpZ0Jsb2NrMzIuZ2V0VWludDMyKGogLSA2NCwgZmFsc2UpKSwgMSksIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGEgPSB0aGlzLl9oMDtcclxuICAgICAgICBsZXQgYiA9IHRoaXMuX2gxO1xyXG4gICAgICAgIGxldCBjID0gdGhpcy5faDI7XHJcbiAgICAgICAgbGV0IGQgPSB0aGlzLl9oMztcclxuICAgICAgICBsZXQgZSA9IHRoaXMuX2g0O1xyXG4gICAgICAgIGxldCBmLCBrO1xyXG4gICAgICAgIGxldCB0ZW1wO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgODA7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoaiA8IDIwKSB7XHJcbiAgICAgICAgICAgICAgICBmID0gKGIgJiBjKSB8ICgofmIpICYgZCk7XHJcbiAgICAgICAgICAgICAgICBrID0gMHg1QTgyNzk5OTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChqIDwgNDApIHtcclxuICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XHJcbiAgICAgICAgICAgICAgICBrID0gMHg2RUQ5RUJBMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChqIDwgNjApIHtcclxuICAgICAgICAgICAgICAgIGYgPSAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCk7XHJcbiAgICAgICAgICAgICAgICBrID0gMHg4RjFCQkNEQztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XHJcbiAgICAgICAgICAgICAgICBrID0gMHhDQTYyQzFENjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ZW1wID0gKGxlZnRSb3RhdGUoYSwgNSkgKyBmICsgZSArIGsgKyBiaWdCbG9jazMyLmdldFVpbnQzMihqICogNCwgZmFsc2UpKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgICAgIGUgPSBkO1xyXG4gICAgICAgICAgICBkID0gYztcclxuICAgICAgICAgICAgYyA9IGxlZnRSb3RhdGUoYiwgMzApO1xyXG4gICAgICAgICAgICBiID0gYTtcclxuICAgICAgICAgICAgYSA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2gwID0gKHRoaXMuX2gwICsgYSkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIHRoaXMuX2gxID0gKHRoaXMuX2gxICsgYikgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIHRoaXMuX2gyID0gKHRoaXMuX2gyICsgYykgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIHRoaXMuX2gzID0gKHRoaXMuX2gzICsgZCkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIHRoaXMuX2g0ID0gKHRoaXMuX2g0ICsgZSkgJiAweGZmZmZmZmZmO1xyXG4gICAgfVxyXG59XHJcblN0cmluZ1NIQTEuX2JpZ0Jsb2NrMzIgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDMyMCkpOyAvLyA4MCAqIDQgPSAzMjBcclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmV4cG9ydCB2YXIgSXRlcmFibGU7XHJcbihmdW5jdGlvbiAoSXRlcmFibGUpIHtcclxuICAgIGZ1bmN0aW9uIGlzKHRoaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaW5nICYmIHR5cGVvZiB0aGluZyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRoaW5nW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XHJcbiAgICB9XHJcbiAgICBJdGVyYWJsZS5pcyA9IGlzO1xyXG4gICAgY29uc3QgX2VtcHR5ID0gT2JqZWN0LmZyZWV6ZShbXSk7XHJcbiAgICBmdW5jdGlvbiBlbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gX2VtcHR5O1xyXG4gICAgfVxyXG4gICAgSXRlcmFibGUuZW1wdHkgPSBlbXB0eTtcclxuICAgIGZ1bmN0aW9uKiBzaW5nbGUoZWxlbWVudCkge1xyXG4gICAgICAgIHlpZWxkIGVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBJdGVyYWJsZS5zaW5nbGUgPSBzaW5nbGU7XHJcbiAgICBmdW5jdGlvbiBmcm9tKGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlIHx8IF9lbXB0eTtcclxuICAgIH1cclxuICAgIEl0ZXJhYmxlLmZyb20gPSBmcm9tO1xyXG4gICAgZnVuY3Rpb24gZmlyc3QoaXRlcmFibGUpIHtcclxuICAgICAgICByZXR1cm4gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpLm5leHQoKS52YWx1ZTtcclxuICAgIH1cclxuICAgIEl0ZXJhYmxlLmZpcnN0ID0gZmlyc3Q7XHJcbiAgICBmdW5jdGlvbiBzb21lKGl0ZXJhYmxlLCBwcmVkaWNhdGUpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgaXRlcmFibGUpIHtcclxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgSXRlcmFibGUuc29tZSA9IHNvbWU7XHJcbiAgICBmdW5jdGlvbiogZmlsdGVyKGl0ZXJhYmxlLCBwcmVkaWNhdGUpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgaXRlcmFibGUpIHtcclxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgeWllbGQgZWxlbWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEl0ZXJhYmxlLmZpbHRlciA9IGZpbHRlcjtcclxuICAgIGZ1bmN0aW9uKiBtYXAoaXRlcmFibGUsIGZuKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIGZuKGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEl0ZXJhYmxlLm1hcCA9IG1hcDtcclxuICAgIGZ1bmN0aW9uKiBjb25jYXQoLi4uaXRlcmFibGVzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVyYWJsZSBvZiBpdGVyYWJsZXMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBlbGVtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgSXRlcmFibGUuY29uY2F0ID0gY29uY2F0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdW1lcyBgYXRNb3N0YCBlbGVtZW50cyBmcm9tIGl0ZXJhYmxlIGFuZCByZXR1cm5zIHRoZSBjb25zdW1lZCBlbGVtZW50cyxcclxuICAgICAqIGFuZCBhbiBpdGVyYWJsZSBmb3IgdGhlIHJlc3Qgb2YgdGhlIGVsZW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb25zdW1lKGl0ZXJhYmxlLCBhdE1vc3QgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcclxuICAgICAgICBjb25zdCBjb25zdW1lZCA9IFtdO1xyXG4gICAgICAgIGlmIChhdE1vc3QgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtjb25zdW1lZCwgaXRlcmFibGVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0TW9zdDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgICAgIGlmIChuZXh0LmRvbmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbY29uc3VtZWQsIEl0ZXJhYmxlLmVtcHR5KCldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN1bWVkLnB1c2gobmV4dC52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbY29uc3VtZWQsIHsgW1N5bWJvbC5pdGVyYXRvcl0oKSB7IHJldHVybiBpdGVyYXRvcjsgfSB9XTtcclxuICAgIH1cclxuICAgIEl0ZXJhYmxlLmNvbnN1bWUgPSBjb25zdW1lO1xyXG59KShJdGVyYWJsZSB8fCAoSXRlcmFibGUgPSB7fSkpO1xyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgaWxsZWdhbEFyZ3VtZW50IH0gZnJvbSAnLi9lcnJvcnMuanMnO1xyXG5jbGFzcyBLZXlDb2RlU3RyTWFwIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2tleUNvZGVUb1N0ciA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3N0clRvS2V5Q29kZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICB9XHJcbiAgICBkZWZpbmUoa2V5Q29kZSwgc3RyKSB7XHJcbiAgICAgICAgdGhpcy5fa2V5Q29kZVRvU3RyW2tleUNvZGVdID0gc3RyO1xyXG4gICAgICAgIHRoaXMuX3N0clRvS2V5Q29kZVtzdHIudG9Mb3dlckNhc2UoKV0gPSBrZXlDb2RlO1xyXG4gICAgfVxyXG4gICAga2V5Q29kZVRvU3RyKGtleUNvZGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fa2V5Q29kZVRvU3RyW2tleUNvZGVdO1xyXG4gICAgfVxyXG4gICAgc3RyVG9LZXlDb2RlKHN0cikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJUb0tleUNvZGVbc3RyLnRvTG93ZXJDYXNlKCldIHx8IDAgLyogVW5rbm93biAqLztcclxuICAgIH1cclxufVxyXG5jb25zdCB1aU1hcCA9IG5ldyBLZXlDb2RlU3RyTWFwKCk7XHJcbmNvbnN0IHVzZXJTZXR0aW5nc1VTTWFwID0gbmV3IEtleUNvZGVTdHJNYXAoKTtcclxuY29uc3QgdXNlclNldHRpbmdzR2VuZXJhbE1hcCA9IG5ldyBLZXlDb2RlU3RyTWFwKCk7XHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBkZWZpbmUoa2V5Q29kZSwgdWlMYWJlbCwgdXNVc2VyU2V0dGluZ3NMYWJlbCA9IHVpTGFiZWwsIGdlbmVyYWxVc2VyU2V0dGluZ3NMYWJlbCA9IHVzVXNlclNldHRpbmdzTGFiZWwpIHtcclxuICAgICAgICB1aU1hcC5kZWZpbmUoa2V5Q29kZSwgdWlMYWJlbCk7XHJcbiAgICAgICAgdXNlclNldHRpbmdzVVNNYXAuZGVmaW5lKGtleUNvZGUsIHVzVXNlclNldHRpbmdzTGFiZWwpO1xyXG4gICAgICAgIHVzZXJTZXR0aW5nc0dlbmVyYWxNYXAuZGVmaW5lKGtleUNvZGUsIGdlbmVyYWxVc2VyU2V0dGluZ3NMYWJlbCk7XHJcbiAgICB9XHJcbiAgICBkZWZpbmUoMCAvKiBVbmtub3duICovLCAndW5rbm93bicpO1xyXG4gICAgZGVmaW5lKDEgLyogQmFja3NwYWNlICovLCAnQmFja3NwYWNlJyk7XHJcbiAgICBkZWZpbmUoMiAvKiBUYWIgKi8sICdUYWInKTtcclxuICAgIGRlZmluZSgzIC8qIEVudGVyICovLCAnRW50ZXInKTtcclxuICAgIGRlZmluZSg0IC8qIFNoaWZ0ICovLCAnU2hpZnQnKTtcclxuICAgIGRlZmluZSg1IC8qIEN0cmwgKi8sICdDdHJsJyk7XHJcbiAgICBkZWZpbmUoNiAvKiBBbHQgKi8sICdBbHQnKTtcclxuICAgIGRlZmluZSg3IC8qIFBhdXNlQnJlYWsgKi8sICdQYXVzZUJyZWFrJyk7XHJcbiAgICBkZWZpbmUoOCAvKiBDYXBzTG9jayAqLywgJ0NhcHNMb2NrJyk7XHJcbiAgICBkZWZpbmUoOSAvKiBFc2NhcGUgKi8sICdFc2NhcGUnKTtcclxuICAgIGRlZmluZSgxMCAvKiBTcGFjZSAqLywgJ1NwYWNlJyk7XHJcbiAgICBkZWZpbmUoMTEgLyogUGFnZVVwICovLCAnUGFnZVVwJyk7XHJcbiAgICBkZWZpbmUoMTIgLyogUGFnZURvd24gKi8sICdQYWdlRG93bicpO1xyXG4gICAgZGVmaW5lKDEzIC8qIEVuZCAqLywgJ0VuZCcpO1xyXG4gICAgZGVmaW5lKDE0IC8qIEhvbWUgKi8sICdIb21lJyk7XHJcbiAgICBkZWZpbmUoMTUgLyogTGVmdEFycm93ICovLCAnTGVmdEFycm93JywgJ0xlZnQnKTtcclxuICAgIGRlZmluZSgxNiAvKiBVcEFycm93ICovLCAnVXBBcnJvdycsICdVcCcpO1xyXG4gICAgZGVmaW5lKDE3IC8qIFJpZ2h0QXJyb3cgKi8sICdSaWdodEFycm93JywgJ1JpZ2h0Jyk7XHJcbiAgICBkZWZpbmUoMTggLyogRG93bkFycm93ICovLCAnRG93bkFycm93JywgJ0Rvd24nKTtcclxuICAgIGRlZmluZSgxOSAvKiBJbnNlcnQgKi8sICdJbnNlcnQnKTtcclxuICAgIGRlZmluZSgyMCAvKiBEZWxldGUgKi8sICdEZWxldGUnKTtcclxuICAgIGRlZmluZSgyMSAvKiBLRVlfMCAqLywgJzAnKTtcclxuICAgIGRlZmluZSgyMiAvKiBLRVlfMSAqLywgJzEnKTtcclxuICAgIGRlZmluZSgyMyAvKiBLRVlfMiAqLywgJzInKTtcclxuICAgIGRlZmluZSgyNCAvKiBLRVlfMyAqLywgJzMnKTtcclxuICAgIGRlZmluZSgyNSAvKiBLRVlfNCAqLywgJzQnKTtcclxuICAgIGRlZmluZSgyNiAvKiBLRVlfNSAqLywgJzUnKTtcclxuICAgIGRlZmluZSgyNyAvKiBLRVlfNiAqLywgJzYnKTtcclxuICAgIGRlZmluZSgyOCAvKiBLRVlfNyAqLywgJzcnKTtcclxuICAgIGRlZmluZSgyOSAvKiBLRVlfOCAqLywgJzgnKTtcclxuICAgIGRlZmluZSgzMCAvKiBLRVlfOSAqLywgJzknKTtcclxuICAgIGRlZmluZSgzMSAvKiBLRVlfQSAqLywgJ0EnKTtcclxuICAgIGRlZmluZSgzMiAvKiBLRVlfQiAqLywgJ0InKTtcclxuICAgIGRlZmluZSgzMyAvKiBLRVlfQyAqLywgJ0MnKTtcclxuICAgIGRlZmluZSgzNCAvKiBLRVlfRCAqLywgJ0QnKTtcclxuICAgIGRlZmluZSgzNSAvKiBLRVlfRSAqLywgJ0UnKTtcclxuICAgIGRlZmluZSgzNiAvKiBLRVlfRiAqLywgJ0YnKTtcclxuICAgIGRlZmluZSgzNyAvKiBLRVlfRyAqLywgJ0cnKTtcclxuICAgIGRlZmluZSgzOCAvKiBLRVlfSCAqLywgJ0gnKTtcclxuICAgIGRlZmluZSgzOSAvKiBLRVlfSSAqLywgJ0knKTtcclxuICAgIGRlZmluZSg0MCAvKiBLRVlfSiAqLywgJ0onKTtcclxuICAgIGRlZmluZSg0MSAvKiBLRVlfSyAqLywgJ0snKTtcclxuICAgIGRlZmluZSg0MiAvKiBLRVlfTCAqLywgJ0wnKTtcclxuICAgIGRlZmluZSg0MyAvKiBLRVlfTSAqLywgJ00nKTtcclxuICAgIGRlZmluZSg0NCAvKiBLRVlfTiAqLywgJ04nKTtcclxuICAgIGRlZmluZSg0NSAvKiBLRVlfTyAqLywgJ08nKTtcclxuICAgIGRlZmluZSg0NiAvKiBLRVlfUCAqLywgJ1AnKTtcclxuICAgIGRlZmluZSg0NyAvKiBLRVlfUSAqLywgJ1EnKTtcclxuICAgIGRlZmluZSg0OCAvKiBLRVlfUiAqLywgJ1InKTtcclxuICAgIGRlZmluZSg0OSAvKiBLRVlfUyAqLywgJ1MnKTtcclxuICAgIGRlZmluZSg1MCAvKiBLRVlfVCAqLywgJ1QnKTtcclxuICAgIGRlZmluZSg1MSAvKiBLRVlfVSAqLywgJ1UnKTtcclxuICAgIGRlZmluZSg1MiAvKiBLRVlfViAqLywgJ1YnKTtcclxuICAgIGRlZmluZSg1MyAvKiBLRVlfVyAqLywgJ1cnKTtcclxuICAgIGRlZmluZSg1NCAvKiBLRVlfWCAqLywgJ1gnKTtcclxuICAgIGRlZmluZSg1NSAvKiBLRVlfWSAqLywgJ1knKTtcclxuICAgIGRlZmluZSg1NiAvKiBLRVlfWiAqLywgJ1onKTtcclxuICAgIGRlZmluZSg1NyAvKiBNZXRhICovLCAnTWV0YScpO1xyXG4gICAgZGVmaW5lKDU4IC8qIENvbnRleHRNZW51ICovLCAnQ29udGV4dE1lbnUnKTtcclxuICAgIGRlZmluZSg1OSAvKiBGMSAqLywgJ0YxJyk7XHJcbiAgICBkZWZpbmUoNjAgLyogRjIgKi8sICdGMicpO1xyXG4gICAgZGVmaW5lKDYxIC8qIEYzICovLCAnRjMnKTtcclxuICAgIGRlZmluZSg2MiAvKiBGNCAqLywgJ0Y0Jyk7XHJcbiAgICBkZWZpbmUoNjMgLyogRjUgKi8sICdGNScpO1xyXG4gICAgZGVmaW5lKDY0IC8qIEY2ICovLCAnRjYnKTtcclxuICAgIGRlZmluZSg2NSAvKiBGNyAqLywgJ0Y3Jyk7XHJcbiAgICBkZWZpbmUoNjYgLyogRjggKi8sICdGOCcpO1xyXG4gICAgZGVmaW5lKDY3IC8qIEY5ICovLCAnRjknKTtcclxuICAgIGRlZmluZSg2OCAvKiBGMTAgKi8sICdGMTAnKTtcclxuICAgIGRlZmluZSg2OSAvKiBGMTEgKi8sICdGMTEnKTtcclxuICAgIGRlZmluZSg3MCAvKiBGMTIgKi8sICdGMTInKTtcclxuICAgIGRlZmluZSg3MSAvKiBGMTMgKi8sICdGMTMnKTtcclxuICAgIGRlZmluZSg3MiAvKiBGMTQgKi8sICdGMTQnKTtcclxuICAgIGRlZmluZSg3MyAvKiBGMTUgKi8sICdGMTUnKTtcclxuICAgIGRlZmluZSg3NCAvKiBGMTYgKi8sICdGMTYnKTtcclxuICAgIGRlZmluZSg3NSAvKiBGMTcgKi8sICdGMTcnKTtcclxuICAgIGRlZmluZSg3NiAvKiBGMTggKi8sICdGMTgnKTtcclxuICAgIGRlZmluZSg3NyAvKiBGMTkgKi8sICdGMTknKTtcclxuICAgIGRlZmluZSg3OCAvKiBOdW1Mb2NrICovLCAnTnVtTG9jaycpO1xyXG4gICAgZGVmaW5lKDc5IC8qIFNjcm9sbExvY2sgKi8sICdTY3JvbGxMb2NrJyk7XHJcbiAgICBkZWZpbmUoODAgLyogVVNfU0VNSUNPTE9OICovLCAnOycsICc7JywgJ09FTV8xJyk7XHJcbiAgICBkZWZpbmUoODEgLyogVVNfRVFVQUwgKi8sICc9JywgJz0nLCAnT0VNX1BMVVMnKTtcclxuICAgIGRlZmluZSg4MiAvKiBVU19DT01NQSAqLywgJywnLCAnLCcsICdPRU1fQ09NTUEnKTtcclxuICAgIGRlZmluZSg4MyAvKiBVU19NSU5VUyAqLywgJy0nLCAnLScsICdPRU1fTUlOVVMnKTtcclxuICAgIGRlZmluZSg4NCAvKiBVU19ET1QgKi8sICcuJywgJy4nLCAnT0VNX1BFUklPRCcpO1xyXG4gICAgZGVmaW5lKDg1IC8qIFVTX1NMQVNIICovLCAnLycsICcvJywgJ09FTV8yJyk7XHJcbiAgICBkZWZpbmUoODYgLyogVVNfQkFDS1RJQ0sgKi8sICdgJywgJ2AnLCAnT0VNXzMnKTtcclxuICAgIGRlZmluZSgxMTAgLyogQUJOVF9DMSAqLywgJ0FCTlRfQzEnKTtcclxuICAgIGRlZmluZSgxMTEgLyogQUJOVF9DMiAqLywgJ0FCTlRfQzInKTtcclxuICAgIGRlZmluZSg4NyAvKiBVU19PUEVOX1NRVUFSRV9CUkFDS0VUICovLCAnWycsICdbJywgJ09FTV80Jyk7XHJcbiAgICBkZWZpbmUoODggLyogVVNfQkFDS1NMQVNIICovLCAnXFxcXCcsICdcXFxcJywgJ09FTV81Jyk7XHJcbiAgICBkZWZpbmUoODkgLyogVVNfQ0xPU0VfU1FVQVJFX0JSQUNLRVQgKi8sICddJywgJ10nLCAnT0VNXzYnKTtcclxuICAgIGRlZmluZSg5MCAvKiBVU19RVU9URSAqLywgJ1xcJycsICdcXCcnLCAnT0VNXzcnKTtcclxuICAgIGRlZmluZSg5MSAvKiBPRU1fOCAqLywgJ09FTV84Jyk7XHJcbiAgICBkZWZpbmUoOTIgLyogT0VNXzEwMiAqLywgJ09FTV8xMDInKTtcclxuICAgIGRlZmluZSg5MyAvKiBOVU1QQURfMCAqLywgJ051bVBhZDAnKTtcclxuICAgIGRlZmluZSg5NCAvKiBOVU1QQURfMSAqLywgJ051bVBhZDEnKTtcclxuICAgIGRlZmluZSg5NSAvKiBOVU1QQURfMiAqLywgJ051bVBhZDInKTtcclxuICAgIGRlZmluZSg5NiAvKiBOVU1QQURfMyAqLywgJ051bVBhZDMnKTtcclxuICAgIGRlZmluZSg5NyAvKiBOVU1QQURfNCAqLywgJ051bVBhZDQnKTtcclxuICAgIGRlZmluZSg5OCAvKiBOVU1QQURfNSAqLywgJ051bVBhZDUnKTtcclxuICAgIGRlZmluZSg5OSAvKiBOVU1QQURfNiAqLywgJ051bVBhZDYnKTtcclxuICAgIGRlZmluZSgxMDAgLyogTlVNUEFEXzcgKi8sICdOdW1QYWQ3Jyk7XHJcbiAgICBkZWZpbmUoMTAxIC8qIE5VTVBBRF84ICovLCAnTnVtUGFkOCcpO1xyXG4gICAgZGVmaW5lKDEwMiAvKiBOVU1QQURfOSAqLywgJ051bVBhZDknKTtcclxuICAgIGRlZmluZSgxMDMgLyogTlVNUEFEX01VTFRJUExZICovLCAnTnVtUGFkX011bHRpcGx5Jyk7XHJcbiAgICBkZWZpbmUoMTA0IC8qIE5VTVBBRF9BREQgKi8sICdOdW1QYWRfQWRkJyk7XHJcbiAgICBkZWZpbmUoMTA1IC8qIE5VTVBBRF9TRVBBUkFUT1IgKi8sICdOdW1QYWRfU2VwYXJhdG9yJyk7XHJcbiAgICBkZWZpbmUoMTA2IC8qIE5VTVBBRF9TVUJUUkFDVCAqLywgJ051bVBhZF9TdWJ0cmFjdCcpO1xyXG4gICAgZGVmaW5lKDEwNyAvKiBOVU1QQURfREVDSU1BTCAqLywgJ051bVBhZF9EZWNpbWFsJyk7XHJcbiAgICBkZWZpbmUoMTA4IC8qIE5VTVBBRF9ESVZJREUgKi8sICdOdW1QYWRfRGl2aWRlJyk7XHJcbn0pKCk7XHJcbmV4cG9ydCB2YXIgS2V5Q29kZVV0aWxzO1xyXG4oZnVuY3Rpb24gKEtleUNvZGVVdGlscykge1xyXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoa2V5Q29kZSkge1xyXG4gICAgICAgIHJldHVybiB1aU1hcC5rZXlDb2RlVG9TdHIoa2V5Q29kZSk7XHJcbiAgICB9XHJcbiAgICBLZXlDb2RlVXRpbHMudG9TdHJpbmcgPSB0b1N0cmluZztcclxuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHVpTWFwLnN0clRvS2V5Q29kZShrZXkpO1xyXG4gICAgfVxyXG4gICAgS2V5Q29kZVV0aWxzLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xyXG4gICAgZnVuY3Rpb24gdG9Vc2VyU2V0dGluZ3NVUyhrZXlDb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIHVzZXJTZXR0aW5nc1VTTWFwLmtleUNvZGVUb1N0cihrZXlDb2RlKTtcclxuICAgIH1cclxuICAgIEtleUNvZGVVdGlscy50b1VzZXJTZXR0aW5nc1VTID0gdG9Vc2VyU2V0dGluZ3NVUztcclxuICAgIGZ1bmN0aW9uIHRvVXNlclNldHRpbmdzR2VuZXJhbChrZXlDb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIHVzZXJTZXR0aW5nc0dlbmVyYWxNYXAua2V5Q29kZVRvU3RyKGtleUNvZGUpO1xyXG4gICAgfVxyXG4gICAgS2V5Q29kZVV0aWxzLnRvVXNlclNldHRpbmdzR2VuZXJhbCA9IHRvVXNlclNldHRpbmdzR2VuZXJhbDtcclxuICAgIGZ1bmN0aW9uIGZyb21Vc2VyU2V0dGluZ3Moa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHVzZXJTZXR0aW5nc1VTTWFwLnN0clRvS2V5Q29kZShrZXkpIHx8IHVzZXJTZXR0aW5nc0dlbmVyYWxNYXAuc3RyVG9LZXlDb2RlKGtleSk7XHJcbiAgICB9XHJcbiAgICBLZXlDb2RlVXRpbHMuZnJvbVVzZXJTZXR0aW5ncyA9IGZyb21Vc2VyU2V0dGluZ3M7XHJcbn0pKEtleUNvZGVVdGlscyB8fCAoS2V5Q29kZVV0aWxzID0ge30pKTtcclxuZXhwb3J0IGZ1bmN0aW9uIEtleUNob3JkKGZpcnN0UGFydCwgc2Vjb25kUGFydCkge1xyXG4gICAgY29uc3QgY2hvcmRQYXJ0ID0gKChzZWNvbmRQYXJ0ICYgMHgwMDAwRkZGRikgPDwgMTYpID4+PiAwO1xyXG4gICAgcmV0dXJuIChmaXJzdFBhcnQgfCBjaG9yZFBhcnQpID4+PiAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVLZXliaW5kaW5nKGtleWJpbmRpbmcsIE9TKSB7XHJcbiAgICBpZiAoa2V5YmluZGluZyA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZmlyc3RQYXJ0ID0gKGtleWJpbmRpbmcgJiAweDAwMDBGRkZGKSA+Pj4gMDtcclxuICAgIGNvbnN0IGNob3JkUGFydCA9IChrZXliaW5kaW5nICYgMHhGRkZGMDAwMCkgPj4+IDE2O1xyXG4gICAgaWYgKGNob3JkUGFydCAhPT0gMCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2hvcmRLZXliaW5kaW5nKFtcclxuICAgICAgICAgICAgY3JlYXRlU2ltcGxlS2V5YmluZGluZyhmaXJzdFBhcnQsIE9TKSxcclxuICAgICAgICAgICAgY3JlYXRlU2ltcGxlS2V5YmluZGluZyhjaG9yZFBhcnQsIE9TKVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBDaG9yZEtleWJpbmRpbmcoW2NyZWF0ZVNpbXBsZUtleWJpbmRpbmcoZmlyc3RQYXJ0LCBPUyldKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2ltcGxlS2V5YmluZGluZyhrZXliaW5kaW5nLCBPUykge1xyXG4gICAgY29uc3QgY3RybENtZCA9IChrZXliaW5kaW5nICYgMjA0OCAvKiBDdHJsQ21kICovID8gdHJ1ZSA6IGZhbHNlKTtcclxuICAgIGNvbnN0IHdpbkN0cmwgPSAoa2V5YmluZGluZyAmIDI1NiAvKiBXaW5DdHJsICovID8gdHJ1ZSA6IGZhbHNlKTtcclxuICAgIGNvbnN0IGN0cmxLZXkgPSAoT1MgPT09IDIgLyogTWFjaW50b3NoICovID8gd2luQ3RybCA6IGN0cmxDbWQpO1xyXG4gICAgY29uc3Qgc2hpZnRLZXkgPSAoa2V5YmluZGluZyAmIDEwMjQgLyogU2hpZnQgKi8gPyB0cnVlIDogZmFsc2UpO1xyXG4gICAgY29uc3QgYWx0S2V5ID0gKGtleWJpbmRpbmcgJiA1MTIgLyogQWx0ICovID8gdHJ1ZSA6IGZhbHNlKTtcclxuICAgIGNvbnN0IG1ldGFLZXkgPSAoT1MgPT09IDIgLyogTWFjaW50b3NoICovID8gY3RybENtZCA6IHdpbkN0cmwpO1xyXG4gICAgY29uc3Qga2V5Q29kZSA9IChrZXliaW5kaW5nICYgMjU1IC8qIEtleUNvZGUgKi8pO1xyXG4gICAgcmV0dXJuIG5ldyBTaW1wbGVLZXliaW5kaW5nKGN0cmxLZXksIHNoaWZ0S2V5LCBhbHRLZXksIG1ldGFLZXksIGtleUNvZGUpO1xyXG59XHJcbmV4cG9ydCBjbGFzcyBTaW1wbGVLZXliaW5kaW5nIHtcclxuICAgIGNvbnN0cnVjdG9yKGN0cmxLZXksIHNoaWZ0S2V5LCBhbHRLZXksIG1ldGFLZXksIGtleUNvZGUpIHtcclxuICAgICAgICB0aGlzLmN0cmxLZXkgPSBjdHJsS2V5O1xyXG4gICAgICAgIHRoaXMuc2hpZnRLZXkgPSBzaGlmdEtleTtcclxuICAgICAgICB0aGlzLmFsdEtleSA9IGFsdEtleTtcclxuICAgICAgICB0aGlzLm1ldGFLZXkgPSBtZXRhS2V5O1xyXG4gICAgICAgIHRoaXMua2V5Q29kZSA9IGtleUNvZGU7XHJcbiAgICB9XHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuY3RybEtleSA9PT0gb3RoZXIuY3RybEtleVxyXG4gICAgICAgICAgICAmJiB0aGlzLnNoaWZ0S2V5ID09PSBvdGhlci5zaGlmdEtleVxyXG4gICAgICAgICAgICAmJiB0aGlzLmFsdEtleSA9PT0gb3RoZXIuYWx0S2V5XHJcbiAgICAgICAgICAgICYmIHRoaXMubWV0YUtleSA9PT0gb3RoZXIubWV0YUtleVxyXG4gICAgICAgICAgICAmJiB0aGlzLmtleUNvZGUgPT09IG90aGVyLmtleUNvZGUpO1xyXG4gICAgfVxyXG4gICAgaXNNb2RpZmllcktleSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMua2V5Q29kZSA9PT0gMCAvKiBVbmtub3duICovXHJcbiAgICAgICAgICAgIHx8IHRoaXMua2V5Q29kZSA9PT0gNSAvKiBDdHJsICovXHJcbiAgICAgICAgICAgIHx8IHRoaXMua2V5Q29kZSA9PT0gNTcgLyogTWV0YSAqL1xyXG4gICAgICAgICAgICB8fCB0aGlzLmtleUNvZGUgPT09IDYgLyogQWx0ICovXHJcbiAgICAgICAgICAgIHx8IHRoaXMua2V5Q29kZSA9PT0gNCAvKiBTaGlmdCAqLyk7XHJcbiAgICB9XHJcbiAgICB0b0Nob3JkKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2hvcmRLZXliaW5kaW5nKFt0aGlzXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERvZXMgdGhpcyBrZXliaW5kaW5nIHJlZmVyIHRvIHRoZSBrZXkgY29kZSBvZiBhIG1vZGlmaWVyIGFuZCBpdCBhbHNvIGhhcyB0aGUgbW9kaWZpZXIgZmxhZz9cclxuICAgICAqL1xyXG4gICAgaXNEdXBsaWNhdGVNb2RpZmllckNhc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuICgodGhpcy5jdHJsS2V5ICYmIHRoaXMua2V5Q29kZSA9PT0gNSAvKiBDdHJsICovKVxyXG4gICAgICAgICAgICB8fCAodGhpcy5zaGlmdEtleSAmJiB0aGlzLmtleUNvZGUgPT09IDQgLyogU2hpZnQgKi8pXHJcbiAgICAgICAgICAgIHx8ICh0aGlzLmFsdEtleSAmJiB0aGlzLmtleUNvZGUgPT09IDYgLyogQWx0ICovKVxyXG4gICAgICAgICAgICB8fCAodGhpcy5tZXRhS2V5ICYmIHRoaXMua2V5Q29kZSA9PT0gNTcgLyogTWV0YSAqLykpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBDaG9yZEtleWJpbmRpbmcge1xyXG4gICAgY29uc3RydWN0b3IocGFydHMpIHtcclxuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWxBcmd1bWVudChgcGFydHNgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBSZXNvbHZlZEtleWJpbmRpbmdQYXJ0IHtcclxuICAgIGNvbnN0cnVjdG9yKGN0cmxLZXksIHNoaWZ0S2V5LCBhbHRLZXksIG1ldGFLZXksIGtiTGFiZWwsIGtiQXJpYUxhYmVsKSB7XHJcbiAgICAgICAgdGhpcy5jdHJsS2V5ID0gY3RybEtleTtcclxuICAgICAgICB0aGlzLnNoaWZ0S2V5ID0gc2hpZnRLZXk7XHJcbiAgICAgICAgdGhpcy5hbHRLZXkgPSBhbHRLZXk7XHJcbiAgICAgICAgdGhpcy5tZXRhS2V5ID0gbWV0YUtleTtcclxuICAgICAgICB0aGlzLmtleUxhYmVsID0ga2JMYWJlbDtcclxuICAgICAgICB0aGlzLmtleUFyaWFMYWJlbCA9IGtiQXJpYUxhYmVsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIHJlc29sdmVkIGtleWJpbmRpbmcuIENhbiBiZSBhIHNpbXBsZSBrZXliaW5kaW5nIG9yIGEgY2hvcmQga2V5YmluZGluZy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSZXNvbHZlZEtleWJpbmRpbmcge1xyXG59XHJcbiIsImltcG9ydCB7IEl0ZXJhYmxlIH0gZnJvbSAnLi9pdGVyYXRvci5qcyc7XHJcbi8qKlxyXG4gKiBFbmFibGVzIGxvZ2dpbmcgb2YgcG90ZW50aWFsbHkgbGVha2VkIGRpc3Bvc2FibGVzLlxyXG4gKlxyXG4gKiBBIGRpc3Bvc2FibGUgaXMgY29uc2lkZXJlZCBsZWFrZWQgaWYgaXQgaXMgbm90IGRpc3Bvc2VkIG9yIG5vdCByZWdpc3RlcmVkIGFzIHRoZSBjaGlsZCBvZlxyXG4gKiBhbm90aGVyIGRpc3Bvc2FibGUuIFRoaXMgdHJhY2tpbmcgaXMgdmVyeSBzaW1wbGUgYW4gb25seSB3b3JrcyBmb3IgY2xhc3NlcyB0aGF0IGVpdGhlclxyXG4gKiBleHRlbmQgRGlzcG9zYWJsZSBvciB1c2UgYSBEaXNwb3NhYmxlU3RvcmUuIFRoaXMgbWVhbnMgdGhlcmUgYXJlIGEgbG90IG9mIGZhbHNlIHBvc2l0aXZlcy5cclxuICovXHJcbmNvbnN0IFRSQUNLX0RJU1BPU0FCTEVTID0gZmFsc2U7XHJcbmNvbnN0IF9faXNfZGlzcG9zYWJsZV90cmFja2VkX18gPSAnX19pc19kaXNwb3NhYmxlX3RyYWNrZWRfXyc7XHJcbmZ1bmN0aW9uIG1hcmtUcmFja2VkKHgpIHtcclxuICAgIGlmICghVFJBQ0tfRElTUE9TQUJMRVMpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoeCAmJiB4ICE9PSBEaXNwb3NhYmxlLk5vbmUpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB4W19faXNfZGlzcG9zYWJsZV90cmFja2VkX19dID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgIC8vIG5vb3BcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJhY2tEaXNwb3NhYmxlKHgpIHtcclxuICAgIGlmICghVFJBQ0tfRElTUE9TQUJMRVMpIHtcclxuICAgICAgICByZXR1cm4geDtcclxuICAgIH1cclxuICAgIGNvbnN0IHN0YWNrID0gbmV3IEVycm9yKCdQb3RlbnRpYWxseSBsZWFrZWQgZGlzcG9zYWJsZScpLnN0YWNrO1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCF4W19faXNfZGlzcG9zYWJsZV90cmFja2VkX19dKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0YWNrKTtcclxuICAgICAgICB9XHJcbiAgICB9LCAzMDAwKTtcclxuICAgIHJldHVybiB4O1xyXG59XHJcbmV4cG9ydCBjbGFzcyBNdWx0aURpc3Bvc2VFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGVycm9ycykge1xyXG4gICAgICAgIHN1cGVyKGBFbmNvdW50ZXIgZXJyb3JzIHdoaWxlIGRpc3Bvc2luZyBvZiBzdG9yZS4gRXJyb3JzOiBbJHtlcnJvcnMuam9pbignLCAnKX1dYCk7XHJcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRGlzcG9zYWJsZSh0aGluZykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZy5kaXNwb3NlID09PSAnZnVuY3Rpb24nICYmIHRoaW5nLmRpc3Bvc2UubGVuZ3RoID09PSAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNwb3NlKGFyZykge1xyXG4gICAgaWYgKEl0ZXJhYmxlLmlzKGFyZykpIHtcclxuICAgICAgICBsZXQgZXJyb3JzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIGFyZykge1xyXG4gICAgICAgICAgICBpZiAoZCkge1xyXG4gICAgICAgICAgICAgICAgbWFya1RyYWNrZWQoZCk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGQuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcnNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGVycm9ycy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBNdWx0aURpc3Bvc2VFcnJvcihlcnJvcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpID8gW10gOiBhcmc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhcmcpIHtcclxuICAgICAgICBtYXJrVHJhY2tlZChhcmcpO1xyXG4gICAgICAgIGFyZy5kaXNwb3NlKCk7XHJcbiAgICAgICAgcmV0dXJuIGFyZztcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZWREaXNwb3NhYmxlKC4uLmRpc3Bvc2FibGVzKSB7XHJcbiAgICBkaXNwb3NhYmxlcy5mb3JFYWNoKG1hcmtUcmFja2VkKTtcclxuICAgIHJldHVybiB0cmFja0Rpc3Bvc2FibGUoeyBkaXNwb3NlOiAoKSA9PiBkaXNwb3NlKGRpc3Bvc2FibGVzKSB9KTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdG9EaXNwb3NhYmxlKGZuKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdHJhY2tEaXNwb3NhYmxlKHtcclxuICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIG1hcmtUcmFja2VkKHNlbGYpO1xyXG4gICAgICAgICAgICBmbigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHNlbGY7XHJcbn1cclxuZXhwb3J0IGNsYXNzIERpc3Bvc2FibGVTdG9yZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl90b0Rpc3Bvc2UgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwb3NlIG9mIGFsbCByZWdpc3RlcmVkIGRpc3Bvc2FibGVzIGFuZCBtYXJrIHRoaXMgb2JqZWN0IGFzIGRpc3Bvc2VkLlxyXG4gICAgICpcclxuICAgICAqIEFueSBmdXR1cmUgZGlzcG9zYWJsZXMgYWRkZWQgdG8gdGhpcyBvYmplY3Qgd2lsbCBiZSBkaXNwb3NlZCBvZiBvbiBgYWRkYC5cclxuICAgICAqL1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5faXNEaXNwb3NlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hcmtUcmFja2VkKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcG9zZSBvZiBhbGwgcmVnaXN0ZXJlZCBkaXNwb3NhYmxlcyBidXQgZG8gbm90IG1hcmsgdGhpcyBvYmplY3QgYXMgZGlzcG9zZWQuXHJcbiAgICAgKi9cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGRpc3Bvc2UodGhpcy5fdG9EaXNwb3NlLnZhbHVlcygpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvRGlzcG9zZS5jbGVhcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZCh0KSB7XHJcbiAgICAgICAgaWYgKCF0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWdpc3RlciBhIGRpc3Bvc2FibGUgb24gaXRzZWxmIScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrVHJhY2tlZCh0KTtcclxuICAgICAgICBpZiAodGhpcy5faXNEaXNwb3NlZCkge1xyXG4gICAgICAgICAgICBpZiAoIURpc3Bvc2FibGVTdG9yZS5ESVNBQkxFX0RJU1BPU0VEX1dBUk5JTkcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihuZXcgRXJyb3IoJ1RyeWluZyB0byBhZGQgYSBkaXNwb3NhYmxlIHRvIGEgRGlzcG9zYWJsZVN0b3JlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZCBvZi4gVGhlIGFkZGVkIG9iamVjdCB3aWxsIGJlIGxlYWtlZCEnKS5zdGFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvRGlzcG9zZS5hZGQodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG59XHJcbkRpc3Bvc2FibGVTdG9yZS5ESVNBQkxFX0RJU1BPU0VEX1dBUk5JTkcgPSBmYWxzZTtcclxuZXhwb3J0IGNsYXNzIERpc3Bvc2FibGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RvcmUgPSBuZXcgRGlzcG9zYWJsZVN0b3JlKCk7XHJcbiAgICAgICAgdHJhY2tEaXNwb3NhYmxlKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBtYXJrVHJhY2tlZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9zdG9yZS5kaXNwb3NlKCk7XHJcbiAgICB9XHJcbiAgICBfcmVnaXN0ZXIodCkge1xyXG4gICAgICAgIGlmICh0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZ2lzdGVyIGEgZGlzcG9zYWJsZSBvbiBpdHNlbGYhJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9yZS5hZGQodCk7XHJcbiAgICB9XHJcbn1cclxuRGlzcG9zYWJsZS5Ob25lID0gT2JqZWN0LmZyZWV6ZSh7IGRpc3Bvc2UoKSB7IH0gfSk7XHJcbi8qKlxyXG4gKiBNYW5hZ2VzIHRoZSBsaWZlY3ljbGUgb2YgYSBkaXNwb3NhYmxlIHZhbHVlIHRoYXQgbWF5IGJlIGNoYW5nZWQuXHJcbiAqXHJcbiAqIFRoaXMgZW5zdXJlcyB0aGF0IHdoZW4gdGhlIGRpc3Bvc2FibGUgdmFsdWUgaXMgY2hhbmdlZCwgdGhlIHByZXZpb3VzbHkgaGVsZCBkaXNwb3NhYmxlIGlzIGRpc3Bvc2VkIG9mLiBZb3UgY2FuXHJcbiAqIGFsc28gcmVnaXN0ZXIgYSBgTXV0YWJsZURpc3Bvc2FibGVgIG9uIGEgYERpc3Bvc2FibGVgIHRvIGVuc3VyZSBpdCBpcyBhdXRvbWF0aWNhbGx5IGNsZWFuZWQgdXAuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTXV0YWJsZURpc3Bvc2FibGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRyYWNrRGlzcG9zYWJsZSh0aGlzKTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNEaXNwb3NlZCA/IHVuZGVmaW5lZCA6IHRoaXMuX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQgfHwgdmFsdWUgPT09IHRoaXMuX3ZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIG1hcmtUcmFja2VkKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgICAgIG1hcmtUcmFja2VkKHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzLl92YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBJbW1vcnRhbFJlZmVyZW5jZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihvYmplY3QpIHtcclxuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7IH1cclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuY2xhc3MgTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICB0aGlzLm5leHQgPSBOb2RlLlVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnByZXYgPSBOb2RlLlVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5Ob2RlLlVuZGVmaW5lZCA9IG5ldyBOb2RlKHVuZGVmaW5lZCk7XHJcbmV4cG9ydCBjbGFzcyBMaW5rZWRMaXN0IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2ZpcnN0ID0gTm9kZS5VbmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fbGFzdCA9IE5vZGUuVW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XHJcbiAgICB9XHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9maXJzdCA9PT0gTm9kZS5VbmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLl9maXJzdCA9IE5vZGUuVW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2xhc3QgPSBOb2RlLlVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9zaXplID0gMDtcclxuICAgIH1cclxuICAgIHVuc2hpZnQoZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnQoZWxlbWVudCwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgcHVzaChlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydChlbGVtZW50LCB0cnVlKTtcclxuICAgIH1cclxuICAgIF9pbnNlcnQoZWxlbWVudCwgYXRUaGVFbmQpIHtcclxuICAgICAgICBjb25zdCBuZXdOb2RlID0gbmV3IE5vZGUoZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZpcnN0ID09PSBOb2RlLlVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9maXJzdCA9IG5ld05vZGU7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3QgPSBuZXdOb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhdFRoZUVuZCkge1xyXG4gICAgICAgICAgICAvLyBwdXNoXHJcbiAgICAgICAgICAgIGNvbnN0IG9sZExhc3QgPSB0aGlzLl9sYXN0O1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0ID0gbmV3Tm9kZTtcclxuICAgICAgICAgICAgbmV3Tm9kZS5wcmV2ID0gb2xkTGFzdDtcclxuICAgICAgICAgICAgb2xkTGFzdC5uZXh0ID0gbmV3Tm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHVuc2hpZnRcclxuICAgICAgICAgICAgY29uc3Qgb2xkRmlyc3QgPSB0aGlzLl9maXJzdDtcclxuICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSBuZXdOb2RlO1xyXG4gICAgICAgICAgICBuZXdOb2RlLm5leHQgPSBvbGRGaXJzdDtcclxuICAgICAgICAgICAgb2xkRmlyc3QucHJldiA9IG5ld05vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NpemUgKz0gMTtcclxuICAgICAgICBsZXQgZGlkUmVtb3ZlID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFkaWRSZW1vdmUpIHtcclxuICAgICAgICAgICAgICAgIGRpZFJlbW92ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmUobmV3Tm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc2hpZnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZpcnN0ID09PSBOb2RlLlVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzID0gdGhpcy5fZmlyc3QuZWxlbWVudDtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKHRoaXMuX2ZpcnN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwb3AoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xhc3QgPT09IE5vZGUuVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLl9sYXN0LmVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZSh0aGlzLl9sYXN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcmVtb3ZlKG5vZGUpIHtcclxuICAgICAgICBpZiAobm9kZS5wcmV2ICE9PSBOb2RlLlVuZGVmaW5lZCAmJiBub2RlLm5leHQgIT09IE5vZGUuVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIG1pZGRsZVxyXG4gICAgICAgICAgICBjb25zdCBhbmNob3IgPSBub2RlLnByZXY7XHJcbiAgICAgICAgICAgIGFuY2hvci5uZXh0ID0gbm9kZS5uZXh0O1xyXG4gICAgICAgICAgICBub2RlLm5leHQucHJldiA9IGFuY2hvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobm9kZS5wcmV2ID09PSBOb2RlLlVuZGVmaW5lZCAmJiBub2RlLm5leHQgPT09IE5vZGUuVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgbm9kZVxyXG4gICAgICAgICAgICB0aGlzLl9maXJzdCA9IE5vZGUuVW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0ID0gTm9kZS5VbmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5vZGUubmV4dCA9PT0gTm9kZS5VbmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gbGFzdFxyXG4gICAgICAgICAgICB0aGlzLl9sYXN0ID0gdGhpcy5fbGFzdC5wcmV2O1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0Lm5leHQgPSBOb2RlLlVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobm9kZS5wcmV2ID09PSBOb2RlLlVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBmaXJzdFxyXG4gICAgICAgICAgICB0aGlzLl9maXJzdCA9IHRoaXMuX2ZpcnN0Lm5leHQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0LnByZXYgPSBOb2RlLlVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZG9uZVxyXG4gICAgICAgIHRoaXMuX3NpemUgLT0gMTtcclxuICAgIH1cclxuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuX2ZpcnN0O1xyXG4gICAgICAgIHdoaWxlIChub2RlICE9PSBOb2RlLlVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB5aWVsZCBub2RlLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9BcnJheSgpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBub2RlID0gdGhpcy5fZmlyc3Q7IG5vZGUgIT09IE5vZGUuVW5kZWZpbmVkOyBub2RlID0gbm9kZS5uZXh0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUuZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8vIE5PVEU6IFZTQ29kZSdzIGNvcHkgb2Ygbm9kZWpzIHBhdGggbGlicmFyeSB0byBiZSB1c2FibGUgaW4gY29tbW9uIChub24tbm9kZSkgbmFtZXNwYWNlXHJcbi8vIENvcGllZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTIuOC4xL2xpYi9wYXRoLmpzXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcclxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XHJcbiAqIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxyXG4gKiBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcclxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcclxuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXHJcbiAqIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxyXG4gKiBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcclxuICogT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxyXG4gKiBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuaW1wb3J0ICogYXMgcHJvY2VzcyBmcm9tICcuL3Byb2Nlc3MuanMnO1xyXG5jb25zdCBDSEFSX1VQUEVSQ0FTRV9BID0gNjU7IC8qIEEgKi9cclxuY29uc3QgQ0hBUl9MT1dFUkNBU0VfQSA9IDk3OyAvKiBhICovXHJcbmNvbnN0IENIQVJfVVBQRVJDQVNFX1ogPSA5MDsgLyogWiAqL1xyXG5jb25zdCBDSEFSX0xPV0VSQ0FTRV9aID0gMTIyOyAvKiB6ICovXHJcbmNvbnN0IENIQVJfRE9UID0gNDY7IC8qIC4gKi9cclxuY29uc3QgQ0hBUl9GT1JXQVJEX1NMQVNIID0gNDc7IC8qIC8gKi9cclxuY29uc3QgQ0hBUl9CQUNLV0FSRF9TTEFTSCA9IDkyOyAvKiBcXCAqL1xyXG5jb25zdCBDSEFSX0NPTE9OID0gNTg7IC8qIDogKi9cclxuY29uc3QgQ0hBUl9RVUVTVElPTl9NQVJLID0gNjM7IC8qID8gKi9cclxuY2xhc3MgRXJyb3JJbnZhbGlkQXJnVHlwZSBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcclxuICAgICAgICAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xyXG4gICAgICAgIGxldCBkZXRlcm1pbmVyO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIGV4cGVjdGVkLmluZGV4T2YoJ25vdCAnKSA9PT0gMCkge1xyXG4gICAgICAgICAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcclxuICAgICAgICAgICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBuYW1lLmluZGV4T2YoJy4nKSAhPT0gLTEgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcclxuICAgICAgICBsZXQgbXNnID0gYFRoZSBcIiR7bmFtZX1cIiAke3R5cGV9ICR7ZGV0ZXJtaW5lcn0gb2YgdHlwZSAke2V4cGVjdGVkfWA7XHJcbiAgICAgICAgbXNnICs9IGAuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWA7XHJcbiAgICAgICAgc3VwZXIobXNnKTtcclxuICAgICAgICB0aGlzLmNvZGUgPSAnRVJSX0lOVkFMSURfQVJHX1RZUEUnO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nKHZhbHVlLCBuYW1lKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvckludmFsaWRBcmdUeXBlKG5hbWUsICdzdHJpbmcnLCB2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNQYXRoU2VwYXJhdG9yKGNvZGUpIHtcclxuICAgIHJldHVybiBjb2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0ggfHwgY29kZSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSDtcclxufVxyXG5mdW5jdGlvbiBpc1Bvc2l4UGF0aFNlcGFyYXRvcihjb2RlKSB7XHJcbiAgICByZXR1cm4gY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIO1xyXG59XHJcbmZ1bmN0aW9uIGlzV2luZG93c0RldmljZVJvb3QoY29kZSkge1xyXG4gICAgcmV0dXJuIGNvZGUgPj0gQ0hBUl9VUFBFUkNBU0VfQSAmJiBjb2RlIDw9IENIQVJfVVBQRVJDQVNFX1ogfHxcclxuICAgICAgICBjb2RlID49IENIQVJfTE9XRVJDQVNFX0EgJiYgY29kZSA8PSBDSEFSX0xPV0VSQ0FTRV9aO1xyXG59XHJcbi8vIFJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCB3aXRoIGRpcmVjdG9yeSBuYW1lc1xyXG5mdW5jdGlvbiBub3JtYWxpemVTdHJpbmcocGF0aCwgYWxsb3dBYm92ZVJvb3QsIHNlcGFyYXRvciwgaXNQYXRoU2VwYXJhdG9yKSB7XHJcbiAgICBsZXQgcmVzID0gJyc7XHJcbiAgICBsZXQgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xyXG4gICAgbGV0IGxhc3RTbGFzaCA9IC0xO1xyXG4gICAgbGV0IGRvdHMgPSAwO1xyXG4gICAgbGV0IGNvZGUgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcGF0aC5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGlmIChpIDwgcGF0aC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29kZSA9IENIQVJfRk9SV0FSRF9TTEFTSDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xyXG4gICAgICAgICAgICBpZiAobGFzdFNsYXNoID09PSBpIC0gMSB8fCBkb3RzID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOT09QXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZG90cyA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPCAyIHx8IGxhc3RTZWdtZW50TGVuZ3RoICE9PSAyIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDEpICE9PSBDSEFSX0RPVCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAyKSAhPT0gQ0hBUl9ET1QpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdFNsYXNoSW5kZXggPSByZXMubGFzdEluZGV4T2Yoc2VwYXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RTbGFzaEluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuc2xpY2UoMCwgbGFzdFNsYXNoSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSByZXMubGVuZ3RoIC0gMSAtIHJlcy5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdHMgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb3RzID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFsbG93QWJvdmVSb290KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IHJlcy5sZW5ndGggPiAwID8gYCR7c2VwYXJhdG9yfS4uYCA6ICcuLic7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IGAke3NlcGFyYXRvcn0ke3BhdGguc2xpY2UobGFzdFNsYXNoICsgMSwgaSl9YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHBhdGguc2xpY2UobGFzdFNsYXNoICsgMSwgaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IGkgLSBsYXN0U2xhc2ggLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XHJcbiAgICAgICAgICAgIGRvdHMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb2RlID09PSBDSEFSX0RPVCAmJiBkb3RzICE9PSAtMSkge1xyXG4gICAgICAgICAgICArK2RvdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb3RzID0gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBfZm9ybWF0KHNlcCwgcGF0aE9iamVjdCkge1xyXG4gICAgaWYgKHBhdGhPYmplY3QgPT09IG51bGwgfHwgdHlwZW9mIHBhdGhPYmplY3QgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW52YWxpZEFyZ1R5cGUoJ3BhdGhPYmplY3QnLCAnT2JqZWN0JywgcGF0aE9iamVjdCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkaXIgPSBwYXRoT2JqZWN0LmRpciB8fCBwYXRoT2JqZWN0LnJvb3Q7XHJcbiAgICBjb25zdCBiYXNlID0gcGF0aE9iamVjdC5iYXNlIHx8XHJcbiAgICAgICAgYCR7cGF0aE9iamVjdC5uYW1lIHx8ICcnfSR7cGF0aE9iamVjdC5leHQgfHwgJyd9YDtcclxuICAgIGlmICghZGlyKSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGlyID09PSBwYXRoT2JqZWN0LnJvb3QgPyBgJHtkaXJ9JHtiYXNlfWAgOiBgJHtkaXJ9JHtzZXB9JHtiYXNlfWA7XHJcbn1cclxuZXhwb3J0IGNvbnN0IHdpbjMyID0ge1xyXG4gICAgLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxyXG4gICAgcmVzb2x2ZSguLi5wYXRoU2VnbWVudHMpIHtcclxuICAgICAgICBsZXQgcmVzb2x2ZWREZXZpY2UgPSAnJztcclxuICAgICAgICBsZXQgcmVzb2x2ZWRUYWlsID0gJyc7XHJcbiAgICAgICAgbGV0IHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gcGF0aFNlZ21lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTE7IGktLSkge1xyXG4gICAgICAgICAgICBsZXQgcGF0aDtcclxuICAgICAgICAgICAgaWYgKGkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGhTZWdtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XHJcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGVtcHR5IGVudHJpZXNcclxuICAgICAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc29sdmVkRGV2aWNlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IHByb2Nlc3MuY3dkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXaW5kb3dzIGhhcyB0aGUgY29uY2VwdCBvZiBkcml2ZS1zcGVjaWZpYyBjdXJyZW50IHdvcmtpbmdcclxuICAgICAgICAgICAgICAgIC8vIGRpcmVjdG9yaWVzLiBJZiB3ZSd2ZSByZXNvbHZlZCBhIGRyaXZlIGxldHRlciBidXQgbm90IHlldCBhblxyXG4gICAgICAgICAgICAgICAgLy8gYWJzb2x1dGUgcGF0aCwgZ2V0IGN3ZCBmb3IgdGhhdCBkcml2ZSwgb3IgdGhlIHByb2Nlc3MgY3dkIGlmXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgZHJpdmUgY3dkIGlzIG5vdCBhdmFpbGFibGUuIFdlJ3JlIHN1cmUgdGhlIGRldmljZSBpcyBub3RcclxuICAgICAgICAgICAgICAgIC8vIGEgVU5DIHBhdGggYXQgdGhpcyBwb2ludHMsIGJlY2F1c2UgVU5DIHBhdGhzIGFyZSBhbHdheXMgYWJzb2x1dGUuXHJcbiAgICAgICAgICAgICAgICBwYXRoID0gcHJvY2Vzcy5lbnZbYD0ke3Jlc29sdmVkRGV2aWNlfWBdIHx8IHByb2Nlc3MuY3dkKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhhdCBhIGN3ZCB3YXMgZm91bmQgYW5kIHRoYXQgaXQgYWN0dWFsbHkgcG9pbnRzXHJcbiAgICAgICAgICAgICAgICAvLyB0byBvdXIgZHJpdmUuIElmIG5vdCwgZGVmYXVsdCB0byB0aGUgZHJpdmUncyByb290LlxyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGguc2xpY2UoMCwgMikudG9Mb3dlckNhc2UoKSAhPT0gcmVzb2x2ZWREZXZpY2UudG9Mb3dlckNhc2UoKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmNoYXJDb2RlQXQoMikgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gYCR7cmVzb2x2ZWREZXZpY2V9XFxcXGA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbGVuID0gcGF0aC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxldCByb290RW5kID0gMDtcclxuICAgICAgICAgICAgbGV0IGRldmljZSA9ICcnO1xyXG4gICAgICAgICAgICBsZXQgaXNBYnNvbHV0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggYSByb290XHJcbiAgICAgICAgICAgIGlmIChsZW4gPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBgcGF0aGAgY29udGFpbnMganVzdCBhIHBhdGggc2VwYXJhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdEVuZCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBYnNvbHV0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQb3NzaWJsZSBVTkMgcm9vdFxyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2Ugc3RhcnRlZCB3aXRoIGEgc2VwYXJhdG9yLCB3ZSBrbm93IHdlIGF0IGxlYXN0IGhhdmUgYW5cclxuICAgICAgICAgICAgICAgIC8vIGFic29sdXRlIHBhdGggb2Ygc29tZSBraW5kIChVTkMgb3Igb3RoZXJ3aXNlKVxyXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgxKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIGRvdWJsZSBwYXRoIHNlcGFyYXRvciBhdCBiZWdpbm5pbmdcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBub24tcGF0aCBzZXBhcmF0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFBhcnQgPSBwYXRoLnNsaWNlKGxhc3QsIGopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIHBhdGggc2VwYXJhdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiBpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBub24tcGF0aCBzZXBhcmF0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiAhaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PT0gbGVuIHx8IGogIT09IGxhc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2UgPSBgXFxcXFxcXFwke2ZpcnN0UGFydH1cXFxcJHtwYXRoLnNsaWNlKGxhc3QsIGopfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEVuZCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByb290RW5kID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1dpbmRvd3NEZXZpY2VSb290KGNvZGUpICYmXHJcbiAgICAgICAgICAgICAgICBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04pIHtcclxuICAgICAgICAgICAgICAgIC8vIFBvc3NpYmxlIGRldmljZSByb290XHJcbiAgICAgICAgICAgICAgICBkZXZpY2UgPSBwYXRoLnNsaWNlKDAsIDIpO1xyXG4gICAgICAgICAgICAgICAgcm9vdEVuZCA9IDI7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMiAmJiBpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyZWF0IHNlcGFyYXRvciBmb2xsb3dpbmcgZHJpdmUgbmFtZSBhcyBhbiBhYnNvbHV0ZSBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kaWNhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgaXNBYnNvbHV0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdEVuZCA9IDM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRldmljZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWREZXZpY2UubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2UudG9Mb3dlckNhc2UoKSAhPT0gcmVzb2x2ZWREZXZpY2UudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHBhdGggcG9pbnRzIHRvIGFub3RoZXIgZGV2aWNlIHNvIGl0IGlzIG5vdCBhcHBsaWNhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkRGV2aWNlID0gZGV2aWNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZEFic29sdXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWREZXZpY2UubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRUYWlsID0gYCR7cGF0aC5zbGljZShyb290RW5kKX1cXFxcJHtyZXNvbHZlZFRhaWx9YDtcclxuICAgICAgICAgICAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBpc0Fic29sdXRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQWJzb2x1dGUgJiYgcmVzb2x2ZWREZXZpY2UubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLFxyXG4gICAgICAgIC8vIGJ1dCBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKVxyXG4gICAgICAgIC8vIGZhaWxzKVxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgdGFpbCBwYXRoXHJcbiAgICAgICAgcmVzb2x2ZWRUYWlsID0gbm9ybWFsaXplU3RyaW5nKHJlc29sdmVkVGFpbCwgIXJlc29sdmVkQWJzb2x1dGUsICdcXFxcJywgaXNQYXRoU2VwYXJhdG9yKTtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZWRBYnNvbHV0ZSA/XHJcbiAgICAgICAgICAgIGAke3Jlc29sdmVkRGV2aWNlfVxcXFwke3Jlc29sdmVkVGFpbH1gIDpcclxuICAgICAgICAgICAgYCR7cmVzb2x2ZWREZXZpY2V9JHtyZXNvbHZlZFRhaWx9YCB8fCAnLic7XHJcbiAgICB9LFxyXG4gICAgbm9ybWFsaXplKHBhdGgpIHtcclxuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHBhdGgubGVuZ3RoO1xyXG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICcuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJvb3RFbmQgPSAwO1xyXG4gICAgICAgIGxldCBkZXZpY2U7XHJcbiAgICAgICAgbGV0IGlzQWJzb2x1dGUgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgIC8vIFRyeSB0byBtYXRjaCBhIHJvb3RcclxuICAgICAgICBpZiAobGVuID09PSAxKSB7XHJcbiAgICAgICAgICAgIC8vIGBwYXRoYCBjb250YWlucyBqdXN0IGEgc2luZ2xlIGNoYXIsIGV4aXQgZWFybHkgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gdW5uZWNlc3Nhcnkgd29ya1xyXG4gICAgICAgICAgICByZXR1cm4gaXNQb3NpeFBhdGhTZXBhcmF0b3IoY29kZSkgPyAnXFxcXCcgOiBwYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XHJcbiAgICAgICAgICAgIC8vIFBvc3NpYmxlIFVOQyByb290XHJcbiAgICAgICAgICAgIC8vIElmIHdlIHN0YXJ0ZWQgd2l0aCBhIHNlcGFyYXRvciwgd2Uga25vdyB3ZSBhdCBsZWFzdCBoYXZlIGFuIGFic29sdXRlXHJcbiAgICAgICAgICAgIC8vIHBhdGggb2Ygc29tZSBraW5kIChVTkMgb3Igb3RoZXJ3aXNlKVxyXG4gICAgICAgICAgICBpc0Fic29sdXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIGRvdWJsZSBwYXRoIHNlcGFyYXRvciBhdCBiZWdpbm5pbmdcclxuICAgICAgICAgICAgICAgIGxldCBqID0gMjtcclxuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gajtcclxuICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBub24tcGF0aCBzZXBhcmF0b3JzXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiAhaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RQYXJ0ID0gcGF0aC5zbGljZShsYXN0LCBqKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIVxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBwYXRoIHNlcGFyYXRvcnNcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiBpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCFcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBub24tcGF0aCBzZXBhcmF0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmICFpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqID09PSBsZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcm9vdCBvbmx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgVU5DIHJvb3Qgc2luY2UgdGhlcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdGhpbmcgbGVmdCB0byBwcm9jZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFxcXFxcXFxcJHtmaXJzdFBhcnR9XFxcXCR7cGF0aC5zbGljZShsYXN0KX1cXFxcYDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiAhPT0gbGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyByb290IHdpdGggbGVmdG92ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2UgPSBgXFxcXFxcXFwke2ZpcnN0UGFydH1cXFxcJHtwYXRoLnNsaWNlKGxhc3QsIGopfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290RW5kID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJvb3RFbmQgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzV2luZG93c0RldmljZVJvb3QoY29kZSkgJiYgcGF0aC5jaGFyQ29kZUF0KDEpID09PSBDSEFSX0NPTE9OKSB7XHJcbiAgICAgICAgICAgIC8vIFBvc3NpYmxlIGRldmljZSByb290XHJcbiAgICAgICAgICAgIGRldmljZSA9IHBhdGguc2xpY2UoMCwgMik7XHJcbiAgICAgICAgICAgIHJvb3RFbmQgPSAyO1xyXG4gICAgICAgICAgICBpZiAobGVuID4gMiAmJiBpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDIpKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgc2VwYXJhdG9yIGZvbGxvd2luZyBkcml2ZSBuYW1lIGFzIGFuIGFic29sdXRlIHBhdGhcclxuICAgICAgICAgICAgICAgIC8vIGluZGljYXRvclxyXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByb290RW5kID0gMztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdGFpbCA9IHJvb3RFbmQgPCBsZW4gP1xyXG4gICAgICAgICAgICBub3JtYWxpemVTdHJpbmcocGF0aC5zbGljZShyb290RW5kKSwgIWlzQWJzb2x1dGUsICdcXFxcJywgaXNQYXRoU2VwYXJhdG9yKSA6XHJcbiAgICAgICAgICAgICcnO1xyXG4gICAgICAgIGlmICh0YWlsLmxlbmd0aCA9PT0gMCAmJiAhaXNBYnNvbHV0ZSkge1xyXG4gICAgICAgICAgICB0YWlsID0gJy4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFpbC5sZW5ndGggPiAwICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQobGVuIC0gMSkpKSB7XHJcbiAgICAgICAgICAgIHRhaWwgKz0gJ1xcXFwnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGV2aWNlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzQWJzb2x1dGUgPyBgXFxcXCR7dGFpbH1gIDogdGFpbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzQWJzb2x1dGUgPyBgJHtkZXZpY2V9XFxcXCR7dGFpbH1gIDogYCR7ZGV2aWNlfSR7dGFpbH1gO1xyXG4gICAgfSxcclxuICAgIGlzQWJzb2x1dGUocGF0aCkge1xyXG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XHJcbiAgICAgICAgY29uc3QgbGVuID0gcGF0aC5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgcmV0dXJuIGlzUGF0aFNlcGFyYXRvcihjb2RlKSB8fFxyXG4gICAgICAgICAgICAvLyBQb3NzaWJsZSBkZXZpY2Ugcm9vdFxyXG4gICAgICAgICAgICBsZW4gPiAyICYmXHJcbiAgICAgICAgICAgICAgICBpc1dpbmRvd3NEZXZpY2VSb290KGNvZGUpICYmXHJcbiAgICAgICAgICAgICAgICBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04gJiZcclxuICAgICAgICAgICAgICAgIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMikpO1xyXG4gICAgfSxcclxuICAgIGpvaW4oLi4ucGF0aHMpIHtcclxuICAgICAgICBpZiAocGF0aHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBqb2luZWQ7XHJcbiAgICAgICAgbGV0IGZpcnN0UGFydDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFyZyA9IHBhdGhzW2ldO1xyXG4gICAgICAgICAgICB2YWxpZGF0ZVN0cmluZyhhcmcsICdwYXRoJyk7XHJcbiAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGpvaW5lZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgam9pbmVkID0gZmlyc3RQYXJ0ID0gYXJnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgam9pbmVkICs9IGBcXFxcJHthcmd9YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoam9pbmVkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGpvaW5lZCBwYXRoIGRvZXNuJ3Qgc3RhcnQgd2l0aCB0d28gc2xhc2hlcywgYmVjYXVzZVxyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSgpIHdpbGwgbWlzdGFrZSBpdCBmb3IgYW4gVU5DIHBhdGggdGhlbi5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFRoaXMgc3RlcCBpcyBza2lwcGVkIHdoZW4gaXQgaXMgdmVyeSBjbGVhciB0aGF0IHRoZSB1c2VyIGFjdHVhbGx5XHJcbiAgICAgICAgLy8gaW50ZW5kZWQgdG8gcG9pbnQgYXQgYW4gVU5DIHBhdGguIFRoaXMgaXMgYXNzdW1lZCB3aGVuIHRoZSBmaXJzdFxyXG4gICAgICAgIC8vIG5vbi1lbXB0eSBzdHJpbmcgYXJndW1lbnRzIHN0YXJ0cyB3aXRoIGV4YWN0bHkgdHdvIHNsYXNoZXMgZm9sbG93ZWQgYnlcclxuICAgICAgICAvLyBhdCBsZWFzdCBvbmUgbW9yZSBub24tc2xhc2ggY2hhcmFjdGVyLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gTm90ZSB0aGF0IGZvciBub3JtYWxpemUoKSB0byB0cmVhdCBhIHBhdGggYXMgYW4gVU5DIHBhdGggaXQgbmVlZHMgdG9cclxuICAgICAgICAvLyBoYXZlIGF0IGxlYXN0IDIgY29tcG9uZW50cywgc28gd2UgZG9uJ3QgZmlsdGVyIGZvciB0aGF0IGhlcmUuXHJcbiAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHRoZSB1c2VyIGNhbiB1c2Ugam9pbiB0byBjb25zdHJ1Y3QgVU5DIHBhdGhzIGZyb21cclxuICAgICAgICAvLyBhIHNlcnZlciBuYW1lIGFuZCBhIHNoYXJlIG5hbWU7IGZvciBleGFtcGxlOlxyXG4gICAgICAgIC8vICAgcGF0aC5qb2luKCcvL3NlcnZlcicsICdzaGFyZScpIC0+ICdcXFxcXFxcXHNlcnZlclxcXFxzaGFyZVxcXFwnKVxyXG4gICAgICAgIGxldCBuZWVkc1JlcGxhY2UgPSB0cnVlO1xyXG4gICAgICAgIGxldCBzbGFzaENvdW50ID0gMDtcclxuICAgICAgICBpZiAodHlwZW9mIGZpcnN0UGFydCA9PT0gJ3N0cmluZycgJiYgaXNQYXRoU2VwYXJhdG9yKGZpcnN0UGFydC5jaGFyQ29kZUF0KDApKSkge1xyXG4gICAgICAgICAgICArK3NsYXNoQ291bnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0TGVuID0gZmlyc3RQYXJ0Lmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKGZpcnN0TGVuID4gMSAmJiBpc1BhdGhTZXBhcmF0b3IoZmlyc3RQYXJ0LmNoYXJDb2RlQXQoMSkpKSB7XHJcbiAgICAgICAgICAgICAgICArK3NsYXNoQ291bnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RMZW4gPiAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihmaXJzdFBhcnQuY2hhckNvZGVBdCgyKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKytzbGFzaENvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyBwYXRoIGluIHRoZSBmaXJzdCBwYXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRzUmVwbGFjZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmVlZHNSZXBsYWNlKSB7XHJcbiAgICAgICAgICAgIC8vIEZpbmQgYW55IG1vcmUgY29uc2VjdXRpdmUgc2xhc2hlcyB3ZSBuZWVkIHRvIHJlcGxhY2VcclxuICAgICAgICAgICAgd2hpbGUgKHNsYXNoQ291bnQgPCBqb2luZWQubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICBpc1BhdGhTZXBhcmF0b3Ioam9pbmVkLmNoYXJDb2RlQXQoc2xhc2hDb3VudCkpKSB7XHJcbiAgICAgICAgICAgICAgICBzbGFzaENvdW50Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgc2xhc2hlcyBpZiBuZWVkZWRcclxuICAgICAgICAgICAgaWYgKHNsYXNoQ291bnQgPj0gMikge1xyXG4gICAgICAgICAgICAgICAgam9pbmVkID0gYFxcXFwke2pvaW5lZC5zbGljZShzbGFzaENvdW50KX1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3aW4zMi5ub3JtYWxpemUoam9pbmVkKTtcclxuICAgIH0sXHJcbiAgICAvLyBJdCB3aWxsIHNvbHZlIHRoZSByZWxhdGl2ZSBwYXRoIGZyb20gYGZyb21gIHRvIGB0b2AsIGZvciBpbnN0YW5jZTpcclxuICAgIC8vICBmcm9tID0gJ0M6XFxcXG9yYW5kZWFcXFxcdGVzdFxcXFxhYWEnXHJcbiAgICAvLyAgdG8gPSAnQzpcXFxcb3JhbmRlYVxcXFxpbXBsXFxcXGJiYidcclxuICAgIC8vIFRoZSBvdXRwdXQgb2YgdGhlIGZ1bmN0aW9uIHNob3VsZCBiZTogJy4uXFxcXC4uXFxcXGltcGxcXFxcYmJiJ1xyXG4gICAgcmVsYXRpdmUoZnJvbSwgdG8pIHtcclxuICAgICAgICB2YWxpZGF0ZVN0cmluZyhmcm9tLCAnZnJvbScpO1xyXG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHRvLCAndG8nKTtcclxuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmcm9tT3JpZyA9IHdpbjMyLnJlc29sdmUoZnJvbSk7XHJcbiAgICAgICAgY29uc3QgdG9PcmlnID0gd2luMzIucmVzb2x2ZSh0byk7XHJcbiAgICAgICAgaWYgKGZyb21PcmlnID09PSB0b09yaWcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmcm9tID0gZnJvbU9yaWcudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB0byA9IHRvT3JpZy50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChmcm9tID09PSB0bykge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRyaW0gYW55IGxlYWRpbmcgYmFja3NsYXNoZXNcclxuICAgICAgICBsZXQgZnJvbVN0YXJ0ID0gMDtcclxuICAgICAgICB3aGlsZSAoZnJvbVN0YXJ0IDwgZnJvbS5sZW5ndGggJiZcclxuICAgICAgICAgICAgZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgZnJvbVN0YXJ0Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRyaW0gdHJhaWxpbmcgYmFja3NsYXNoZXMgKGFwcGxpY2FibGUgdG8gVU5DIHBhdGhzIG9ubHkpXHJcbiAgICAgICAgbGV0IGZyb21FbmQgPSBmcm9tLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoZnJvbUVuZCAtIDEgPiBmcm9tU3RhcnQgJiZcclxuICAgICAgICAgICAgZnJvbS5jaGFyQ29kZUF0KGZyb21FbmQgLSAxKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xyXG4gICAgICAgICAgICBmcm9tRW5kLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZyb21MZW4gPSBmcm9tRW5kIC0gZnJvbVN0YXJ0O1xyXG4gICAgICAgIC8vIFRyaW0gYW55IGxlYWRpbmcgYmFja3NsYXNoZXNcclxuICAgICAgICBsZXQgdG9TdGFydCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHRvU3RhcnQgPCB0by5sZW5ndGggJiZcclxuICAgICAgICAgICAgdG8uY2hhckNvZGVBdCh0b1N0YXJ0KSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xyXG4gICAgICAgICAgICB0b1N0YXJ0Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRyaW0gdHJhaWxpbmcgYmFja3NsYXNoZXMgKGFwcGxpY2FibGUgdG8gVU5DIHBhdGhzIG9ubHkpXHJcbiAgICAgICAgbGV0IHRvRW5kID0gdG8ubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlICh0b0VuZCAtIDEgPiB0b1N0YXJ0ICYmXHJcbiAgICAgICAgICAgIHRvLmNoYXJDb2RlQXQodG9FbmQgLSAxKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xyXG4gICAgICAgICAgICB0b0VuZC0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0b0xlbiA9IHRvRW5kIC0gdG9TdGFydDtcclxuICAgICAgICAvLyBDb21wYXJlIHBhdGhzIHRvIGZpbmQgdGhlIGxvbmdlc3QgY29tbW9uIHBhdGggZnJvbSByb290XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZnJvbUxlbiA8IHRvTGVuID8gZnJvbUxlbiA6IHRvTGVuO1xyXG4gICAgICAgIGxldCBsYXN0Q29tbW9uU2VwID0gLTE7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZnJvbUNvZGUgPSBmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0ICsgaSk7XHJcbiAgICAgICAgICAgIGlmIChmcm9tQ29kZSAhPT0gdG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSkpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb21Db2RlID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSBmb3VuZCBhIG1pc21hdGNoIGJlZm9yZSB0aGUgZmlyc3QgY29tbW9uIHBhdGggc2VwYXJhdG9yIHdhcyBzZWVuLCBzb1xyXG4gICAgICAgIC8vIHJldHVybiB0aGUgb3JpZ2luYWwgYHRvYC5cclxuICAgICAgICBpZiAoaSAhPT0gbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmIChsYXN0Q29tbW9uU2VwID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvT3JpZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRvTGVuID4gbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYHRvYC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nQzpcXFxcZm9vXFxcXGJhcic7IHRvPSdDOlxcXFxmb29cXFxcYmFyXFxcXGJheidcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9PcmlnLnNsaWNlKHRvU3RhcnQgKyBpICsgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGBmcm9tYCBpcyB0aGUgZGV2aWNlIHJvb3QuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209J0M6XFxcXCc7IHRvPSdDOlxcXFxmb28nXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvT3JpZy5zbGljZSh0b1N0YXJ0ICsgaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZyb21MZW4gPiBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0ICsgaSkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgdG9gIGlzIHRoZSBleGFjdCBiYXNlIHBhdGggZm9yIGBmcm9tYC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nQzpcXFxcZm9vXFxcXGJhcic7IHRvPSdDOlxcXFxmb28nXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgZGV2aWNlIHJvb3QuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209J0M6XFxcXGZvb1xcXFxiYXInOyB0bz0nQzpcXFxcJ1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSAzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYXN0Q29tbW9uU2VwID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgbGFzdENvbW1vblNlcCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG91dCA9ICcnO1xyXG4gICAgICAgIC8vIEdlbmVyYXRlIHRoZSByZWxhdGl2ZSBwYXRoIGJhc2VkIG9uIHRoZSBwYXRoIGRpZmZlcmVuY2UgYmV0d2VlbiBgdG9gIGFuZFxyXG4gICAgICAgIC8vIGBmcm9tYFxyXG4gICAgICAgIGZvciAoaSA9IGZyb21TdGFydCArIGxhc3RDb21tb25TZXAgKyAxOyBpIDw9IGZyb21FbmQ7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gZnJvbUVuZCB8fCBmcm9tLmNoYXJDb2RlQXQoaSkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgICAgIG91dCArPSBvdXQubGVuZ3RoID09PSAwID8gJy4uJyA6ICdcXFxcLi4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRvU3RhcnQgKz0gbGFzdENvbW1vblNlcDtcclxuICAgICAgICAvLyBMYXN0bHksIGFwcGVuZCB0aGUgcmVzdCBvZiB0aGUgZGVzdGluYXRpb24gKGB0b2ApIHBhdGggdGhhdCBjb21lcyBhZnRlclxyXG4gICAgICAgIC8vIHRoZSBjb21tb24gcGF0aCBwYXJ0c1xyXG4gICAgICAgIGlmIChvdXQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYCR7b3V0fSR7dG9PcmlnLnNsaWNlKHRvU3RhcnQsIHRvRW5kKX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9PcmlnLmNoYXJDb2RlQXQodG9TdGFydCkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgKyt0b1N0YXJ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG9PcmlnLnNsaWNlKHRvU3RhcnQsIHRvRW5kKTtcclxuICAgIH0sXHJcbiAgICB0b05hbWVzcGFjZWRQYXRoKHBhdGgpIHtcclxuICAgICAgICAvLyBOb3RlOiB0aGlzIHdpbGwgKnByb2JhYmx5KiB0aHJvdyBzb21ld2hlcmUuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXRoID0gd2luMzIucmVzb2x2ZShwYXRoKTtcclxuICAgICAgICBpZiAocmVzb2x2ZWRQYXRoLmxlbmd0aCA8PSAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzb2x2ZWRQYXRoLmNoYXJDb2RlQXQoMCkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgLy8gUG9zc2libGUgVU5DIHJvb3RcclxuICAgICAgICAgICAgaWYgKHJlc29sdmVkUGF0aC5jaGFyQ29kZUF0KDEpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gcmVzb2x2ZWRQYXRoLmNoYXJDb2RlQXQoMik7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gQ0hBUl9RVUVTVElPTl9NQVJLICYmIGNvZGUgIT09IENIQVJfRE9UKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCBub24tbG9uZyBVTkMgcm9vdCwgY29udmVydCB0aGUgcGF0aCB0byBhIGxvbmcgVU5DIHBhdGhcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFxcXFxcXFxcP1xcXFxVTkNcXFxcJHtyZXNvbHZlZFBhdGguc2xpY2UoMil9YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1dpbmRvd3NEZXZpY2VSb290KHJlc29sdmVkUGF0aC5jaGFyQ29kZUF0KDApKSAmJlxyXG4gICAgICAgICAgICByZXNvbHZlZFBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTiAmJlxyXG4gICAgICAgICAgICByZXNvbHZlZFBhdGguY2hhckNvZGVBdCgyKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xyXG4gICAgICAgICAgICAvLyBNYXRjaGVkIGRldmljZSByb290LCBjb252ZXJ0IHRoZSBwYXRoIHRvIGEgbG9uZyBVTkMgcGF0aFxyXG4gICAgICAgICAgICByZXR1cm4gYFxcXFxcXFxcP1xcXFwke3Jlc29sdmVkUGF0aH1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH0sXHJcbiAgICBkaXJuYW1lKHBhdGgpIHtcclxuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHBhdGgubGVuZ3RoO1xyXG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICcuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJvb3RFbmQgPSAtMTtcclxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgICAgICBjb25zdCBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgIGlmIChsZW4gPT09IDEpIHtcclxuICAgICAgICAgICAgLy8gYHBhdGhgIGNvbnRhaW5zIGp1c3QgYSBwYXRoIHNlcGFyYXRvciwgZXhpdCBlYXJseSB0byBhdm9pZFxyXG4gICAgICAgICAgICAvLyB1bm5lY2Vzc2FyeSB3b3JrIG9yIGEgZG90LlxyXG4gICAgICAgICAgICByZXR1cm4gaXNQYXRoU2VwYXJhdG9yKGNvZGUpID8gcGF0aCA6ICcuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVHJ5IHRvIG1hdGNoIGEgcm9vdFxyXG4gICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcclxuICAgICAgICAgICAgLy8gUG9zc2libGUgVU5DIHJvb3RcclxuICAgICAgICAgICAgcm9vdEVuZCA9IG9mZnNldCA9IDE7XHJcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDEpKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCBkb3VibGUgcGF0aCBzZXBhcmF0b3IgYXQgYmVnaW5uaW5nXHJcbiAgICAgICAgICAgICAgICBsZXQgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQhXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIHBhdGggc2VwYXJhdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IGxlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyByb290IG9ubHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqICE9PSBsYXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3Qgd2l0aCBsZWZ0b3ZlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9mZnNldCBieSAxIHRvIGluY2x1ZGUgdGhlIHNlcGFyYXRvciBhZnRlciB0aGUgVU5DIHJvb3QgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyZWF0IGl0IGFzIGEgXCJub3JtYWwgcm9vdFwiIG9uIHRvcCBvZiBhIChVTkMpIHJvb3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbmQgPSBvZmZzZXQgPSBqICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBQb3NzaWJsZSBkZXZpY2Ugcm9vdFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1dpbmRvd3NEZXZpY2VSb290KGNvZGUpICYmIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTikge1xyXG4gICAgICAgICAgICByb290RW5kID0gbGVuID4gMiAmJiBpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDIpKSA/IDMgOiAyO1xyXG4gICAgICAgICAgICBvZmZzZXQgPSByb290RW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZW5kID0gLTE7XHJcbiAgICAgICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IGxlbiAtIDE7IGkgPj0gb2Zmc2V0OyAtLWkpIHtcclxuICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxyXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgaWYgKHJvb3RFbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJy4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVuZCA9IHJvb3RFbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XHJcbiAgICB9LFxyXG4gICAgYmFzZW5hbWUocGF0aCwgZXh0KSB7XHJcbiAgICAgICAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlU3RyaW5nKGV4dCwgJ2V4dCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xyXG4gICAgICAgIGxldCBzdGFydCA9IDA7XHJcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xyXG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIC8vIENoZWNrIGZvciBhIGRyaXZlIGxldHRlciBwcmVmaXggc28gYXMgbm90IHRvIG1pc3Rha2UgdGhlIGZvbGxvd2luZ1xyXG4gICAgICAgIC8vIHBhdGggc2VwYXJhdG9yIGFzIGFuIGV4dHJhIHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoIHRoYXQgY2FuIGJlXHJcbiAgICAgICAgLy8gZGlzcmVnYXJkZWRcclxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPj0gMiAmJlxyXG4gICAgICAgICAgICBpc1dpbmRvd3NEZXZpY2VSb290KHBhdGguY2hhckNvZGVBdCgwKSkgJiZcclxuICAgICAgICAgICAgcGF0aC5jaGFyQ29kZUF0KDEpID09PSBDSEFSX0NPTE9OKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkICYmIGV4dC5sZW5ndGggPiAwICYmIGV4dC5sZW5ndGggPD0gcGF0aC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKGV4dCA9PT0gcGF0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBleHRJZHggPSBleHQubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgbGV0IGZpcnN0Tm9uU2xhc2hFbmQgPSAtMTtcclxuICAgICAgICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IHN0YXJ0OyAtLWkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcclxuICAgICAgICAgICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3ROb25TbGFzaEVuZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIHJlbWVtYmVyIHRoaXMgaW5kZXggaW4gY2FzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIGl0IGlmIHRoZSBleHRlbnNpb24gZW5kcyB1cCBub3QgbWF0Y2hpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9uU2xhc2hFbmQgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dElkeCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBtYXRjaCB0aGUgZXhwbGljaXQgZXh0ZW5zaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSBleHQuY2hhckNvZGVBdChleHRJZHgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1leHRJZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgZXh0ZW5zaW9uLCBzbyBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXIgcGF0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRlbnNpb24gZG9lcyBub3QgbWF0Y2gsIHNvIG91ciByZXN1bHQgaXMgdGhlIGVudGlyZSBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dElkeCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBwYXRoLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IHN0YXJ0OyAtLWkpIHtcclxuICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaSkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxyXG4gICAgICAgICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XHJcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZW5kID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxyXG4gICAgICAgICAgICAgICAgLy8gcGF0aCBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZW5kID0gaSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcclxuICAgIH0sXHJcbiAgICBleHRuYW1lKHBhdGgpIHtcclxuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xyXG4gICAgICAgIGxldCBzdGFydCA9IDA7XHJcbiAgICAgICAgbGV0IHN0YXJ0RG90ID0gLTE7XHJcbiAgICAgICAgbGV0IHN0YXJ0UGFydCA9IDA7XHJcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xyXG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xyXG4gICAgICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcclxuICAgICAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxyXG4gICAgICAgIGxldCBwcmVEb3RTdGF0ZSA9IDA7XHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGEgZHJpdmUgbGV0dGVyIHByZWZpeCBzbyBhcyBub3QgdG8gbWlzdGFrZSB0aGUgZm9sbG93aW5nXHJcbiAgICAgICAgLy8gcGF0aCBzZXBhcmF0b3IgYXMgYW4gZXh0cmEgc2VwYXJhdG9yIGF0IHRoZSBlbmQgb2YgdGhlIHBhdGggdGhhdCBjYW4gYmVcclxuICAgICAgICAvLyBkaXNyZWdhcmRlZFxyXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+PSAyICYmXHJcbiAgICAgICAgICAgIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTiAmJlxyXG4gICAgICAgICAgICBpc1dpbmRvd3NEZXZpY2VSb290KHBhdGguY2hhckNvZGVBdCgwKSkpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSBzdGFydFBhcnQgPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IHN0YXJ0OyAtLWkpIHtcclxuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcclxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXHJcbiAgICAgICAgICAgICAgICAvLyBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZW5kID0gaSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfRE9UKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydERvdCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8XHJcbiAgICAgICAgICAgIGVuZCA9PT0gLTEgfHxcclxuICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcclxuICAgICAgICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcclxuICAgICAgICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xyXG4gICAgICAgICAgICAocHJlRG90U3RhdGUgPT09IDEgJiZcclxuICAgICAgICAgICAgICAgIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmXHJcbiAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcclxuICAgIH0sXHJcbiAgICBmb3JtYXQ6IF9mb3JtYXQuYmluZChudWxsLCAnXFxcXCcpLFxyXG4gICAgcGFyc2UocGF0aCkge1xyXG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XHJcbiAgICAgICAgY29uc3QgcmV0ID0geyByb290OiAnJywgZGlyOiAnJywgYmFzZTogJycsIGV4dDogJycsIG5hbWU6ICcnIH07XHJcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxlbiA9IHBhdGgubGVuZ3RoO1xyXG4gICAgICAgIGxldCByb290RW5kID0gMDtcclxuICAgICAgICBsZXQgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcclxuICAgICAgICBpZiAobGVuID09PSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGBwYXRoYCBjb250YWlucyBqdXN0IGEgcGF0aCBzZXBhcmF0b3IsIGV4aXQgZWFybHkgdG8gYXZvaWRcclxuICAgICAgICAgICAgICAgIC8vIHVubmVjZXNzYXJ5IHdvcmtcclxuICAgICAgICAgICAgICAgIHJldC5yb290ID0gcmV0LmRpciA9IHBhdGg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggYSByb290XHJcbiAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xyXG4gICAgICAgICAgICAvLyBQb3NzaWJsZSBVTkMgcm9vdFxyXG4gICAgICAgICAgICByb290RW5kID0gMTtcclxuICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIGRvdWJsZSBwYXRoIHNlcGFyYXRvciBhdCBiZWdpbm5pbmdcclxuICAgICAgICAgICAgICAgIGxldCBqID0gMjtcclxuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gajtcclxuICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBub24tcGF0aCBzZXBhcmF0b3JzXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiAhaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCFcclxuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgcGF0aCBzZXBhcmF0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiAhaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PT0gbGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3Qgb25seVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEVuZCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaiAhPT0gbGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyByb290IHdpdGggbGVmdG92ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290RW5kID0gaiArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNXaW5kb3dzRGV2aWNlUm9vdChjb2RlKSAmJiBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04pIHtcclxuICAgICAgICAgICAgLy8gUG9zc2libGUgZGV2aWNlIHJvb3RcclxuICAgICAgICAgICAgaWYgKGxlbiA8PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBgcGF0aGAgY29udGFpbnMganVzdCBhIGRyaXZlIHJvb3QsIGV4aXQgZWFybHkgdG8gYXZvaWRcclxuICAgICAgICAgICAgICAgIC8vIHVubmVjZXNzYXJ5IHdvcmtcclxuICAgICAgICAgICAgICAgIHJldC5yb290ID0gcmV0LmRpciA9IHBhdGg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvb3RFbmQgPSAyO1xyXG4gICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgyKSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsZW4gPT09IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBgcGF0aGAgY29udGFpbnMganVzdCBhIGRyaXZlIHJvb3QsIGV4aXQgZWFybHkgdG8gYXZvaWRcclxuICAgICAgICAgICAgICAgICAgICAvLyB1bm5lY2Vzc2FyeSB3b3JrXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0LnJvb3QgPSByZXQuZGlyID0gcGF0aDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcm9vdEVuZCA9IDM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJvb3RFbmQgPiAwKSB7XHJcbiAgICAgICAgICAgIHJldC5yb290ID0gcGF0aC5zbGljZSgwLCByb290RW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHN0YXJ0RG90ID0gLTE7XHJcbiAgICAgICAgbGV0IHN0YXJ0UGFydCA9IHJvb3RFbmQ7XHJcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xyXG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xyXG4gICAgICAgIGxldCBpID0gcGF0aC5sZW5ndGggLSAxO1xyXG4gICAgICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcclxuICAgICAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxyXG4gICAgICAgIGxldCBwcmVEb3RTdGF0ZSA9IDA7XHJcbiAgICAgICAgLy8gR2V0IG5vbi1kaXIgaW5mb1xyXG4gICAgICAgIGZvciAoOyBpID49IHJvb3RFbmQ7IC0taSkge1xyXG4gICAgICAgICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxyXG4gICAgICAgICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XHJcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcclxuICAgICAgICAgICAgICAgIC8vIGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBpICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9ET1QpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RG90ID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcclxuICAgICAgICAgICAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uXHJcbiAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHxcclxuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XHJcbiAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xyXG4gICAgICAgICAgICAgICAgKHByZURvdFN0YXRlID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREb3QgPT09IGVuZCAtIDEgJiZcclxuICAgICAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkpIHtcclxuICAgICAgICAgICAgICAgIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgZW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydFBhcnQsIHN0YXJ0RG90KTtcclxuICAgICAgICAgICAgICAgIHJldC5iYXNlID0gcGF0aC5zbGljZShzdGFydFBhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgICAgICByZXQuZXh0ID0gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGUgZGlyZWN0b3J5IGlzIHRoZSByb290LCB1c2UgdGhlIGVudGlyZSByb290IGFzIHRoZSBgZGlyYCBpbmNsdWRpbmdcclxuICAgICAgICAvLyB0aGUgdHJhaWxpbmcgc2xhc2ggaWYgYW55IChgQzpcXGFiY2AgLT4gYEM6XFxgKS4gT3RoZXJ3aXNlLCBzdHJpcCBvdXQgdGhlXHJcbiAgICAgICAgLy8gdHJhaWxpbmcgc2xhc2ggKGBDOlxcYWJjXFxkZWZgIC0+IGBDOlxcYWJjYCkuXHJcbiAgICAgICAgaWYgKHN0YXJ0UGFydCA+IDAgJiYgc3RhcnRQYXJ0ICE9PSByb290RW5kKSB7XHJcbiAgICAgICAgICAgIHJldC5kaXIgPSBwYXRoLnNsaWNlKDAsIHN0YXJ0UGFydCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0LmRpciA9IHJldC5yb290O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfSxcclxuICAgIHNlcDogJ1xcXFwnLFxyXG4gICAgZGVsaW1pdGVyOiAnOycsXHJcbiAgICB3aW4zMjogbnVsbCxcclxuICAgIHBvc2l4OiBudWxsXHJcbn07XHJcbmV4cG9ydCBjb25zdCBwb3NpeCA9IHtcclxuICAgIC8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcclxuICAgIHJlc29sdmUoLi4ucGF0aFNlZ21lbnRzKSB7XHJcbiAgICAgICAgbGV0IHJlc29sdmVkUGF0aCA9ICcnO1xyXG4gICAgICAgIGxldCByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhdGhTZWdtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGkgPj0gMCA/IHBhdGhTZWdtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XHJcbiAgICAgICAgICAgIC8vIFNraXAgZW1wdHkgZW50cmllc1xyXG4gICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc29sdmVkUGF0aCA9IGAke3BhdGh9LyR7cmVzb2x2ZWRQYXRofWA7XHJcbiAgICAgICAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IENIQVJfRk9SV0FSRF9TTEFTSDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxyXG4gICAgICAgIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxyXG4gICAgICAgIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZVN0cmluZyhyZXNvbHZlZFBhdGgsICFyZXNvbHZlZEFic29sdXRlLCAnLycsIGlzUG9zaXhQYXRoU2VwYXJhdG9yKTtcclxuICAgICAgICBpZiAocmVzb2x2ZWRBYnNvbHV0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYC8ke3Jlc29sdmVkUGF0aH1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzb2x2ZWRQYXRoLmxlbmd0aCA+IDAgPyByZXNvbHZlZFBhdGggOiAnLic7XHJcbiAgICB9LFxyXG4gICAgbm9ybWFsaXplKHBhdGgpIHtcclxuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xyXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJy4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpc0Fic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSBDSEFSX0ZPUldBUkRfU0xBU0g7XHJcbiAgICAgICAgY29uc3QgdHJhaWxpbmdTZXBhcmF0b3IgPSBwYXRoLmNoYXJDb2RlQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIO1xyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxyXG4gICAgICAgIHBhdGggPSBub3JtYWxpemVTdHJpbmcocGF0aCwgIWlzQWJzb2x1dGUsICcvJywgaXNQb3NpeFBhdGhTZXBhcmF0b3IpO1xyXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoaXNBYnNvbHV0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcvJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJhaWxpbmdTZXBhcmF0b3IgPyAnLi8nIDogJy4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhaWxpbmdTZXBhcmF0b3IpIHtcclxuICAgICAgICAgICAgcGF0aCArPSAnLyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc0Fic29sdXRlID8gYC8ke3BhdGh9YCA6IHBhdGg7XHJcbiAgICB9LFxyXG4gICAgaXNBYnNvbHV0ZShwYXRoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcclxuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAwICYmIHBhdGguY2hhckNvZGVBdCgwKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIO1xyXG4gICAgfSxcclxuICAgIGpvaW4oLi4ucGF0aHMpIHtcclxuICAgICAgICBpZiAocGF0aHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBqb2luZWQ7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBhcmcgPSBwYXRoc1tpXTtcclxuICAgICAgICAgICAgdmFsaWRhdGVTdHJpbmcoYXJnLCAncGF0aCcpO1xyXG4gICAgICAgICAgICBpZiAoYXJnLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpvaW5lZCA9IGFyZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGpvaW5lZCArPSBgLyR7YXJnfWA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGpvaW5lZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb3NpeC5ub3JtYWxpemUoam9pbmVkKTtcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZShmcm9tLCB0bykge1xyXG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKGZyb20sICdmcm9tJyk7XHJcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcodG8sICd0bycpO1xyXG4gICAgICAgIGlmIChmcm9tID09PSB0bykge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRyaW0gbGVhZGluZyBmb3J3YXJkIHNsYXNoZXMuXHJcbiAgICAgICAgZnJvbSA9IHBvc2l4LnJlc29sdmUoZnJvbSk7XHJcbiAgICAgICAgdG8gPSBwb3NpeC5yZXNvbHZlKHRvKTtcclxuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmcm9tU3RhcnQgPSAxO1xyXG4gICAgICAgIGNvbnN0IGZyb21FbmQgPSBmcm9tLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBmcm9tTGVuID0gZnJvbUVuZCAtIGZyb21TdGFydDtcclxuICAgICAgICBjb25zdCB0b1N0YXJ0ID0gMTtcclxuICAgICAgICBjb25zdCB0b0xlbiA9IHRvLmxlbmd0aCAtIHRvU3RhcnQ7XHJcbiAgICAgICAgLy8gQ29tcGFyZSBwYXRocyB0byBmaW5kIHRoZSBsb25nZXN0IGNvbW1vbiBwYXRoIGZyb20gcm9vdFxyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IChmcm9tTGVuIDwgdG9MZW4gPyBmcm9tTGVuIDogdG9MZW4pO1xyXG4gICAgICAgIGxldCBsYXN0Q29tbW9uU2VwID0gLTE7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZnJvbUNvZGUgPSBmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0ICsgaSk7XHJcbiAgICAgICAgICAgIGlmIChmcm9tQ29kZSAhPT0gdG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSkpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb21Db2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpID09PSBsZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHRvTGVuID4gbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSkgPT09IENIQVJfRk9SV0FSRF9TTEFTSCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGBmcm9tYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgdG9gLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vL2Jhcic7IHRvPScvZm9vL2Jhci9iYXonXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvLnNsaWNlKHRvU3RhcnQgKyBpICsgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGBmcm9tYCBpcyB0aGUgcm9vdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvJzsgdG89Jy9mb28nXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvLnNsaWNlKHRvU3RhcnQgKyBpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tTGVuID4gbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgdG9gIGlzIHRoZSBleGFjdCBiYXNlIHBhdGggZm9yIGBmcm9tYC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvby9iYXIvYmF6JzsgdG89Jy9mb28vYmFyJ1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGB0b2AgaXMgdGhlIHJvb3QuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28vYmFyJzsgdG89Jy8nXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbW1vblNlcCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG91dCA9ICcnO1xyXG4gICAgICAgIC8vIEdlbmVyYXRlIHRoZSByZWxhdGl2ZSBwYXRoIGJhc2VkIG9uIHRoZSBwYXRoIGRpZmZlcmVuY2UgYmV0d2VlbiBgdG9gXHJcbiAgICAgICAgLy8gYW5kIGBmcm9tYC5cclxuICAgICAgICBmb3IgKGkgPSBmcm9tU3RhcnQgKyBsYXN0Q29tbW9uU2VwICsgMTsgaSA8PSBmcm9tRW5kOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKGkgPT09IGZyb21FbmQgfHwgZnJvbS5jaGFyQ29kZUF0KGkpID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgICAgIG91dCArPSBvdXQubGVuZ3RoID09PSAwID8gJy4uJyA6ICcvLi4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIExhc3RseSwgYXBwZW5kIHRoZSByZXN0IG9mIHRoZSBkZXN0aW5hdGlvbiAoYHRvYCkgcGF0aCB0aGF0IGNvbWVzIGFmdGVyXHJcbiAgICAgICAgLy8gdGhlIGNvbW1vbiBwYXRoIHBhcnRzLlxyXG4gICAgICAgIHJldHVybiBgJHtvdXR9JHt0by5zbGljZSh0b1N0YXJ0ICsgbGFzdENvbW1vblNlcCl9YDtcclxuICAgIH0sXHJcbiAgICB0b05hbWVzcGFjZWRQYXRoKHBhdGgpIHtcclxuICAgICAgICAvLyBOb24tb3Agb24gcG9zaXggc3lzdGVtc1xyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfSxcclxuICAgIGRpcm5hbWUocGF0aCkge1xyXG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XHJcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhhc1Jvb3QgPSBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IENIQVJfRk9SV0FSRF9TTEFTSDtcclxuICAgICAgICBsZXQgZW5kID0gLTE7XHJcbiAgICAgICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcclxuICAgICAgICAgICAgaWYgKHBhdGguY2hhckNvZGVBdChpKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxyXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhc1Jvb3QgPyAnLycgOiAnLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNSb290ICYmIGVuZCA9PT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJy8vJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZW5kKTtcclxuICAgIH0sXHJcbiAgICBiYXNlbmFtZShwYXRoLCBleHQpIHtcclxuICAgICAgICBpZiAoZXh0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVTdHJpbmcoZXh0LCAnZXh0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gMDtcclxuICAgICAgICBsZXQgZW5kID0gLTE7XHJcbiAgICAgICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkICYmIGV4dC5sZW5ndGggPiAwICYmIGV4dC5sZW5ndGggPD0gcGF0aC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKGV4dCA9PT0gcGF0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBleHRJZHggPSBleHQubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgbGV0IGZpcnN0Tm9uU2xhc2hFbmQgPSAtMTtcclxuICAgICAgICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdE5vblNsYXNoRW5kID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgcmVtZW1iZXIgdGhpcyBpbmRleCBpbiBjYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgaXQgaWYgdGhlIGV4dGVuc2lvbiBlbmRzIHVwIG5vdCBtYXRjaGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3ROb25TbGFzaEVuZCA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0SWR4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIG1hdGNoIHRoZSBleHBsaWNpdCBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IGV4dC5jaGFyQ29kZUF0KGV4dElkeCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWV4dElkeCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBleHRlbnNpb24sIHNvIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91ciBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dGVuc2lvbiBkb2VzIG5vdCBtYXRjaCwgc28gb3VyIHJlc3VsdCBpcyB0aGUgZW50aXJlIHBhdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0SWR4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IHBhdGgubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IENIQVJfRk9SV0FSRF9TTEFTSCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcclxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcclxuICAgICAgICAgICAgICAgIC8vIHBhdGggY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGVuZCA9IGkgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgICB9LFxyXG4gICAgZXh0bmFtZShwYXRoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcclxuICAgICAgICBsZXQgc3RhcnREb3QgPSAtMTtcclxuICAgICAgICBsZXQgc3RhcnRQYXJ0ID0gMDtcclxuICAgICAgICBsZXQgZW5kID0gLTE7XHJcbiAgICAgICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XHJcbiAgICAgICAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxyXG4gICAgICAgIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXHJcbiAgICAgICAgbGV0IHByZURvdFN0YXRlID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxyXG4gICAgICAgICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XHJcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcclxuICAgICAgICAgICAgICAgIC8vIGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBpICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9ET1QpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RG90ID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcclxuICAgICAgICAgICAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uXHJcbiAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHxcclxuICAgICAgICAgICAgZW5kID09PSAtMSB8fFxyXG4gICAgICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxyXG4gICAgICAgICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxyXG4gICAgICAgICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXHJcbiAgICAgICAgICAgIChwcmVEb3RTdGF0ZSA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgc3RhcnREb3QgPT09IGVuZCAtIDEgJiZcclxuICAgICAgICAgICAgICAgIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xyXG4gICAgfSxcclxuICAgIGZvcm1hdDogX2Zvcm1hdC5iaW5kKG51bGwsICcvJyksXHJcbiAgICBwYXJzZShwYXRoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcclxuICAgICAgICBjb25zdCByZXQgPSB7IHJvb3Q6ICcnLCBkaXI6ICcnLCBiYXNlOiAnJywgZXh0OiAnJywgbmFtZTogJycgfTtcclxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaXNBYnNvbHV0ZSA9IHBhdGguY2hhckNvZGVBdCgwKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIO1xyXG4gICAgICAgIGxldCBzdGFydDtcclxuICAgICAgICBpZiAoaXNBYnNvbHV0ZSkge1xyXG4gICAgICAgICAgICByZXQucm9vdCA9ICcvJztcclxuICAgICAgICAgICAgc3RhcnQgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3RhcnQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc3RhcnREb3QgPSAtMTtcclxuICAgICAgICBsZXQgc3RhcnRQYXJ0ID0gMDtcclxuICAgICAgICBsZXQgZW5kID0gLTE7XHJcbiAgICAgICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XHJcbiAgICAgICAgbGV0IGkgPSBwYXRoLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxyXG4gICAgICAgIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXHJcbiAgICAgICAgbGV0IHByZURvdFN0YXRlID0gMDtcclxuICAgICAgICAvLyBHZXQgbm9uLWRpciBpbmZvXHJcbiAgICAgICAgZm9yICg7IGkgPj0gc3RhcnQ7IC0taSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxyXG4gICAgICAgICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XHJcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcclxuICAgICAgICAgICAgICAgIC8vIGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBpICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9ET1QpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RG90ID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcclxuICAgICAgICAgICAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uXHJcbiAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhcnRQYXJ0ID09PSAwICYmIGlzQWJzb2x1dGUgPyAxIDogc3RhcnRQYXJ0O1xyXG4gICAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxyXG4gICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcclxuICAgICAgICAgICAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcclxuICAgICAgICAgICAgICAgIChwcmVEb3RTdGF0ZSA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpKSB7XHJcbiAgICAgICAgICAgICAgICByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydCwgc3RhcnREb3QpO1xyXG4gICAgICAgICAgICAgICAgcmV0LmJhc2UgPSBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgICAgICAgICAgcmV0LmV4dCA9IHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0UGFydCA+IDApIHtcclxuICAgICAgICAgICAgcmV0LmRpciA9IHBhdGguc2xpY2UoMCwgc3RhcnRQYXJ0IC0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzQWJzb2x1dGUpIHtcclxuICAgICAgICAgICAgcmV0LmRpciA9ICcvJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH0sXHJcbiAgICBzZXA6ICcvJyxcclxuICAgIGRlbGltaXRlcjogJzonLFxyXG4gICAgd2luMzI6IG51bGwsXHJcbiAgICBwb3NpeDogbnVsbFxyXG59O1xyXG5wb3NpeC53aW4zMiA9IHdpbjMyLndpbjMyID0gd2luMzI7XHJcbnBvc2l4LnBvc2l4ID0gd2luMzIucG9zaXggPSBwb3NpeDtcclxuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZSA9IChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gd2luMzIubm9ybWFsaXplIDogcG9zaXgubm9ybWFsaXplKTtcclxuZXhwb3J0IGNvbnN0IHJlc29sdmUgPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHdpbjMyLnJlc29sdmUgOiBwb3NpeC5yZXNvbHZlKTtcclxuZXhwb3J0IGNvbnN0IHJlbGF0aXZlID0gKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMi5yZWxhdGl2ZSA6IHBvc2l4LnJlbGF0aXZlKTtcclxuZXhwb3J0IGNvbnN0IGRpcm5hbWUgPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHdpbjMyLmRpcm5hbWUgOiBwb3NpeC5kaXJuYW1lKTtcclxuZXhwb3J0IGNvbnN0IGJhc2VuYW1lID0gKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMi5iYXNlbmFtZSA6IHBvc2l4LmJhc2VuYW1lKTtcclxuZXhwb3J0IGNvbnN0IGV4dG5hbWUgPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHdpbjMyLmV4dG5hbWUgOiBwb3NpeC5leHRuYW1lKTtcclxuZXhwb3J0IGNvbnN0IHNlcCA9IChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gd2luMzIuc2VwIDogcG9zaXguc2VwKTtcclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmNvbnN0IExBTkdVQUdFX0RFRkFVTFQgPSAnZW4nO1xyXG5sZXQgX2lzV2luZG93cyA9IGZhbHNlO1xyXG5sZXQgX2lzTWFjaW50b3NoID0gZmFsc2U7XHJcbmxldCBfaXNMaW51eCA9IGZhbHNlO1xyXG5sZXQgX2lzTmF0aXZlID0gZmFsc2U7XHJcbmxldCBfaXNXZWIgPSBmYWxzZTtcclxubGV0IF9pc0lPUyA9IGZhbHNlO1xyXG5sZXQgX2xvY2FsZSA9IHVuZGVmaW5lZDtcclxubGV0IF9sYW5ndWFnZSA9IExBTkdVQUdFX0RFRkFVTFQ7XHJcbmxldCBfdHJhbnNsYXRpb25zQ29uZmlnRmlsZSA9IHVuZGVmaW5lZDtcclxubGV0IF91c2VyQWdlbnQgPSB1bmRlZmluZWQ7XHJcbmNvbnN0IGlzRWxlY3Ryb25SZW5kZXJlciA9ICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpO1xyXG4vLyBPUyBkZXRlY3Rpb25cclxuaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmICFpc0VsZWN0cm9uUmVuZGVyZXIpIHtcclxuICAgIF91c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xyXG4gICAgX2lzV2luZG93cyA9IF91c2VyQWdlbnQuaW5kZXhPZignV2luZG93cycpID49IDA7XHJcbiAgICBfaXNNYWNpbnRvc2ggPSBfdXNlckFnZW50LmluZGV4T2YoJ01hY2ludG9zaCcpID49IDA7XHJcbiAgICBfaXNJT1MgPSAoX3VzZXJBZ2VudC5pbmRleE9mKCdNYWNpbnRvc2gnKSA+PSAwIHx8IF91c2VyQWdlbnQuaW5kZXhPZignaVBhZCcpID49IDAgfHwgX3VzZXJBZ2VudC5pbmRleE9mKCdpUGhvbmUnKSA+PSAwKSAmJiAhIW5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwO1xyXG4gICAgX2lzTGludXggPSBfdXNlckFnZW50LmluZGV4T2YoJ0xpbnV4JykgPj0gMDtcclxuICAgIF9pc1dlYiA9IHRydWU7XHJcbiAgICBfbG9jYWxlID0gbmF2aWdhdG9yLmxhbmd1YWdlO1xyXG4gICAgX2xhbmd1YWdlID0gX2xvY2FsZTtcclxufVxyXG5lbHNlIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcpIHtcclxuICAgIF9pc1dpbmRvd3MgPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XHJcbiAgICBfaXNNYWNpbnRvc2ggPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xyXG4gICAgX2lzTGludXggPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4Jyk7XHJcbiAgICBfbG9jYWxlID0gTEFOR1VBR0VfREVGQVVMVDtcclxuICAgIF9sYW5ndWFnZSA9IExBTkdVQUdFX0RFRkFVTFQ7XHJcbiAgICBjb25zdCByYXdObHNDb25maWcgPSBwcm9jZXNzLmVudlsnVlNDT0RFX05MU19DT05GSUcnXTtcclxuICAgIGlmIChyYXdObHNDb25maWcpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBubHNDb25maWcgPSBKU09OLnBhcnNlKHJhd05sc0NvbmZpZyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gbmxzQ29uZmlnLmF2YWlsYWJsZUxhbmd1YWdlc1snKiddO1xyXG4gICAgICAgICAgICBfbG9jYWxlID0gbmxzQ29uZmlnLmxvY2FsZTtcclxuICAgICAgICAgICAgLy8gVlNDb2RlJ3MgZGVmYXVsdCBsYW5ndWFnZSBpcyAnZW4nXHJcbiAgICAgICAgICAgIF9sYW5ndWFnZSA9IHJlc29sdmVkID8gcmVzb2x2ZWQgOiBMQU5HVUFHRV9ERUZBVUxUO1xyXG4gICAgICAgICAgICBfdHJhbnNsYXRpb25zQ29uZmlnRmlsZSA9IG5sc0NvbmZpZy5fdHJhbnNsYXRpb25zQ29uZmlnRmlsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaXNOYXRpdmUgPSB0cnVlO1xyXG59XHJcbmxldCBfcGxhdGZvcm0gPSAwIC8qIFdlYiAqLztcclxuaWYgKF9pc01hY2ludG9zaCkge1xyXG4gICAgX3BsYXRmb3JtID0gMSAvKiBNYWMgKi87XHJcbn1cclxuZWxzZSBpZiAoX2lzV2luZG93cykge1xyXG4gICAgX3BsYXRmb3JtID0gMyAvKiBXaW5kb3dzICovO1xyXG59XHJcbmVsc2UgaWYgKF9pc0xpbnV4KSB7XHJcbiAgICBfcGxhdGZvcm0gPSAyIC8qIExpbnV4ICovO1xyXG59XHJcbmV4cG9ydCBjb25zdCBpc1dpbmRvd3MgPSBfaXNXaW5kb3dzO1xyXG5leHBvcnQgY29uc3QgaXNNYWNpbnRvc2ggPSBfaXNNYWNpbnRvc2g7XHJcbmV4cG9ydCBjb25zdCBpc0xpbnV4ID0gX2lzTGludXg7XHJcbmV4cG9ydCBjb25zdCBpc05hdGl2ZSA9IF9pc05hdGl2ZTtcclxuZXhwb3J0IGNvbnN0IGlzV2ViID0gX2lzV2ViO1xyXG5leHBvcnQgY29uc3QgaXNJT1MgPSBfaXNJT1M7XHJcbmNvbnN0IF9nbG9iYWxzID0gKHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyA/IHNlbGYgOiB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyA/IGdsb2JhbCA6IHt9KTtcclxuZXhwb3J0IGNvbnN0IGdsb2JhbHMgPSBfZ2xvYmFscztcclxuZXhwb3J0IGNvbnN0IHNldEltbWVkaWF0ZSA9IChmdW5jdGlvbiBkZWZpbmVTZXRJbW1lZGlhdGUoKSB7XHJcbiAgICBpZiAoZ2xvYmFscy5zZXRJbW1lZGlhdGUpIHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFscy5zZXRJbW1lZGlhdGUuYmluZChnbG9iYWxzKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFscy5wb3N0TWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFscy5pbXBvcnRTY3JpcHRzKSB7XHJcbiAgICAgICAgbGV0IHBlbmRpbmcgPSBbXTtcclxuICAgICAgICBnbG9iYWxzLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5kYXRhICYmIGUuZGF0YS52c2NvZGVTZXRJbW1lZGlhdGVJZCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBlbmRpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBwZW5kaW5nW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUuaWQgPT09IGUuZGF0YS52c2NvZGVTZXRJbW1lZGlhdGVJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlLmNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgbGFzdElkID0gMDtcclxuICAgICAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG15SWQgPSArK2xhc3RJZDtcclxuICAgICAgICAgICAgcGVuZGluZy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGlkOiBteUlkLFxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBnbG9iYWxzLnBvc3RNZXNzYWdlKHsgdnNjb2RlU2V0SW1tZWRpYXRlSWQ6IG15SWQgfSwgJyonKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2Vzcy5uZXh0VGljayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrLmJpbmQocHJvY2Vzcyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBfcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgcmV0dXJuIChjYWxsYmFjaykgPT4gX3Byb21pc2UudGhlbihjYWxsYmFjayk7XHJcbn0pKCk7XHJcbmV4cG9ydCBjb25zdCBPUyA9IChfaXNNYWNpbnRvc2ggfHwgX2lzSU9TID8gMiAvKiBNYWNpbnRvc2ggKi8gOiAoX2lzV2luZG93cyA/IDEgLyogV2luZG93cyAqLyA6IDMgLyogTGludXggKi8pKTtcclxubGV0IF9pc0xpdHRsZUVuZGlhbiA9IHRydWU7XHJcbmxldCBfaXNMaXR0bGVFbmRpYW5Db21wdXRlZCA9IGZhbHNlO1xyXG5leHBvcnQgZnVuY3Rpb24gaXNMaXR0bGVFbmRpYW4oKSB7XHJcbiAgICBpZiAoIV9pc0xpdHRsZUVuZGlhbkNvbXB1dGVkKSB7XHJcbiAgICAgICAgX2lzTGl0dGxlRW5kaWFuQ29tcHV0ZWQgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IHRlc3QgPSBuZXcgVWludDhBcnJheSgyKTtcclxuICAgICAgICB0ZXN0WzBdID0gMTtcclxuICAgICAgICB0ZXN0WzFdID0gMjtcclxuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQxNkFycmF5KHRlc3QuYnVmZmVyKTtcclxuICAgICAgICBfaXNMaXR0bGVFbmRpYW4gPSAodmlld1swXSA9PT0gKDIgPDwgOCkgKyAxKTtcclxuICAgIH1cclxuICAgIHJldHVybiBfaXNMaXR0bGVFbmRpYW47XHJcbn1cclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IGlzV2luZG93cywgaXNNYWNpbnRvc2gsIHNldEltbWVkaWF0ZSB9IGZyb20gJy4vcGxhdGZvcm0uanMnO1xyXG5jb25zdCBzYWZlUHJvY2VzcyA9ICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpID8ge1xyXG4gICAgY3dkKCkgeyByZXR1cm4gJy8nOyB9LFxyXG4gICAgZW52OiBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgZ2V0IHBsYXRmb3JtKCkgeyByZXR1cm4gaXNXaW5kb3dzID8gJ3dpbjMyJyA6IGlzTWFjaW50b3NoID8gJ2RhcndpbicgOiAnbGludXgnOyB9LFxyXG4gICAgbmV4dFRpY2soY2FsbGJhY2spIHsgcmV0dXJuIHNldEltbWVkaWF0ZShjYWxsYmFjayk7IH1cclxufSA6IHByb2Nlc3M7XHJcbmV4cG9ydCBjb25zdCBjd2QgPSBzYWZlUHJvY2Vzcy5jd2Q7XHJcbmV4cG9ydCBjb25zdCBlbnYgPSBzYWZlUHJvY2Vzcy5lbnY7XHJcbmV4cG9ydCBjb25zdCBwbGF0Zm9ybSA9IHNhZmVQcm9jZXNzLnBsYXRmb3JtO1xyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmFsc3lPcldoaXRlc3BhY2Uoc3RyKSB7XHJcbiAgICBpZiAoIXN0ciB8fCB0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0ci50cmltKCkubGVuZ3RoID09PSAwO1xyXG59XHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZCBFUzY6IHVzZSBgU3RyaW5nLnBhZFN0YXJ0YFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhZChuLCBsLCBjaGFyID0gJzAnKSB7XHJcbiAgICBjb25zdCBzdHIgPSAnJyArIG47XHJcbiAgICBjb25zdCByID0gW3N0cl07XHJcbiAgICBmb3IgKGxldCBpID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHIucHVzaChjaGFyKTtcclxuICAgIH1cclxuICAgIHJldHVybiByLnJldmVyc2UoKS5qb2luKCcnKTtcclxufVxyXG5jb25zdCBfZm9ybWF0UmVnZXhwID0gL3soXFxkKyl9L2c7XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gcHJvZHVjZSBhIHN0cmluZyB3aXRoIGEgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cy4gSW5zZXJ0IHZhcmlhYmxlIHNlZ21lbnRzXHJcbiAqIGludG8gdGhlIHN0cmluZyB1c2luZyB0aGUge259IG5vdGF0aW9uIHdoZXJlIE4gaXMgdGhlIGluZGV4IG9mIHRoZSBhcmd1bWVudCBmb2xsb3dpbmcgdGhlIHN0cmluZy5cclxuICogQHBhcmFtIHZhbHVlIHN0cmluZyB0byB3aGljaCBmb3JtYXR0aW5nIGlzIGFwcGxpZWRcclxuICogQHBhcmFtIGFyZ3MgcmVwbGFjZW1lbnRzIGZvciB7bn0tZW50cmllc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSwgLi4uYXJncykge1xyXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoX2Zvcm1hdFJlZ2V4cCwgZnVuY3Rpb24gKG1hdGNoLCBncm91cCkge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHBhcnNlSW50KGdyb3VwLCAxMCk7XHJcbiAgICAgICAgcmV0dXJuIGlzTmFOKGlkeCkgfHwgaWR4IDwgMCB8fCBpZHggPj0gYXJncy5sZW5ndGggP1xyXG4gICAgICAgICAgICBtYXRjaCA6XHJcbiAgICAgICAgICAgIGFyZ3NbaWR4XTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBIVE1MIGNoYXJhY3RlcnMgaW5zaWRlIHRoZSBzdHJpbmcgdG8gdXNlIGVudGl0aWVzIGluc3RlYWQuIE1ha2VzIHRoZSBzdHJpbmcgc2FmZSBmcm9tXHJcbiAqIGJlaW5nIHVzZWQgZS5nLiBpbiBIVE1MRWxlbWVudC5pbm5lckhUTUwuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlKGh0bWwpIHtcclxuICAgIHJldHVybiBodG1sLnJlcGxhY2UoL1s8PiZdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgIHN3aXRjaCAobWF0Y2gpIHtcclxuICAgICAgICAgICAgY2FzZSAnPCc6IHJldHVybiAnJmx0Oyc7XHJcbiAgICAgICAgICAgIGNhc2UgJz4nOiByZXR1cm4gJyZndDsnO1xyXG4gICAgICAgICAgICBjYXNlICcmJzogcmV0dXJuICcmYW1wOyc7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBtYXRjaDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogRXNjYXBlcyByZWd1bGFyIGV4cHJlc3Npb24gY2hhcmFjdGVycyBpbiBhIGdpdmVuIHN0cmluZ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cENoYXJhY3RlcnModmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bXFxcXFxce1xcfVxcKlxcK1xcP1xcfFxcXlxcJFxcLlxcW1xcXVxcKFxcKV0vZywgJ1xcXFwkJicpO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFsbCBvY2N1cnJlbmNlcyBvZiBuZWVkbGUgZnJvbSB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgaGF5c3RhY2suXHJcbiAqIEBwYXJhbSBoYXlzdGFjayBzdHJpbmcgdG8gdHJpbVxyXG4gKiBAcGFyYW0gbmVlZGxlIHRoZSB0aGluZyB0byB0cmltIChkZWZhdWx0IGlzIGEgYmxhbmspXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdHJpbShoYXlzdGFjaywgbmVlZGxlID0gJyAnKSB7XHJcbiAgICBjb25zdCB0cmltbWVkID0gbHRyaW0oaGF5c3RhY2ssIG5lZWRsZSk7XHJcbiAgICByZXR1cm4gcnRyaW0odHJpbW1lZCwgbmVlZGxlKTtcclxufVxyXG4vKipcclxuICogUmVtb3ZlcyBhbGwgb2NjdXJyZW5jZXMgb2YgbmVlZGxlIGZyb20gdGhlIGJlZ2lubmluZyBvZiBoYXlzdGFjay5cclxuICogQHBhcmFtIGhheXN0YWNrIHN0cmluZyB0byB0cmltXHJcbiAqIEBwYXJhbSBuZWVkbGUgdGhlIHRoaW5nIHRvIHRyaW1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBsdHJpbShoYXlzdGFjaywgbmVlZGxlKSB7XHJcbiAgICBpZiAoIWhheXN0YWNrIHx8ICFuZWVkbGUpIHtcclxuICAgICAgICByZXR1cm4gaGF5c3RhY2s7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZWVkbGVMZW4gPSBuZWVkbGUubGVuZ3RoO1xyXG4gICAgaWYgKG5lZWRsZUxlbiA9PT0gMCB8fCBoYXlzdGFjay5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gaGF5c3RhY2s7XHJcbiAgICB9XHJcbiAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgIHdoaWxlIChoYXlzdGFjay5pbmRleE9mKG5lZWRsZSwgb2Zmc2V0KSA9PT0gb2Zmc2V0KSB7XHJcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgbmVlZGxlTGVuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhheXN0YWNrLnN1YnN0cmluZyhvZmZzZXQpO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFsbCBvY2N1cnJlbmNlcyBvZiBuZWVkbGUgZnJvbSB0aGUgZW5kIG9mIGhheXN0YWNrLlxyXG4gKiBAcGFyYW0gaGF5c3RhY2sgc3RyaW5nIHRvIHRyaW1cclxuICogQHBhcmFtIG5lZWRsZSB0aGUgdGhpbmcgdG8gdHJpbVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJ0cmltKGhheXN0YWNrLCBuZWVkbGUpIHtcclxuICAgIGlmICghaGF5c3RhY2sgfHwgIW5lZWRsZSkge1xyXG4gICAgICAgIHJldHVybiBoYXlzdGFjaztcclxuICAgIH1cclxuICAgIGNvbnN0IG5lZWRsZUxlbiA9IG5lZWRsZS5sZW5ndGgsIGhheXN0YWNrTGVuID0gaGF5c3RhY2subGVuZ3RoO1xyXG4gICAgaWYgKG5lZWRsZUxlbiA9PT0gMCB8fCBoYXlzdGFja0xlbiA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBoYXlzdGFjaztcclxuICAgIH1cclxuICAgIGxldCBvZmZzZXQgPSBoYXlzdGFja0xlbiwgaWR4ID0gLTE7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGlkeCA9IGhheXN0YWNrLmxhc3RJbmRleE9mKG5lZWRsZSwgb2Zmc2V0IC0gMSk7XHJcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEgfHwgaWR4ICsgbmVlZGxlTGVuICE9PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpZHggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgPSBpZHg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGF5c3RhY2suc3Vic3RyaW5nKDAsIG9mZnNldCk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRTaW1wbGUyUmVnRXhwUGF0dGVybihwYXR0ZXJuKSB7XHJcbiAgICByZXR1cm4gcGF0dGVybi5yZXBsYWNlKC9bXFwtXFxcXFxce1xcfVxcK1xcP1xcfFxcXlxcJFxcLlxcLFxcW1xcXVxcKFxcKVxcI1xcc10vZywgJ1xcXFwkJicpLnJlcGxhY2UoL1tcXCpdL2csICcuKicpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFdpbGRjYXJkcyhwYXR0ZXJuKSB7XHJcbiAgICByZXR1cm4gcGF0dGVybi5yZXBsYWNlKC9cXCovZywgJycpO1xyXG59XHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZCBFUzY6IHVzZSBgU3RyaW5nLnN0YXJ0c1dpdGhgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRzV2l0aChoYXlzdGFjaywgbmVlZGxlKSB7XHJcbiAgICBpZiAoaGF5c3RhY2subGVuZ3RoIDwgbmVlZGxlLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChoYXlzdGFjayA9PT0gbmVlZGxlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRsZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChoYXlzdGFja1tpXSAhPT0gbmVlZGxlW2ldKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogQGRlcHJlY2F0ZWQgRVM2OiB1c2UgYFN0cmluZy5lbmRzV2l0aGBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlbmRzV2l0aChoYXlzdGFjaywgbmVlZGxlKSB7XHJcbiAgICBjb25zdCBkaWZmID0gaGF5c3RhY2subGVuZ3RoIC0gbmVlZGxlLmxlbmd0aDtcclxuICAgIGlmIChkaWZmID4gMCkge1xyXG4gICAgICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSwgZGlmZikgPT09IGRpZmY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkaWZmID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGhheXN0YWNrID09PSBuZWVkbGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZ0V4cChzZWFyY2hTdHJpbmcsIGlzUmVnZXgsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgaWYgKCFzZWFyY2hTdHJpbmcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgcmVnZXggZnJvbSBlbXB0eSBzdHJpbmcnKTtcclxuICAgIH1cclxuICAgIGlmICghaXNSZWdleCkge1xyXG4gICAgICAgIHNlYXJjaFN0cmluZyA9IGVzY2FwZVJlZ0V4cENoYXJhY3RlcnMoc2VhcmNoU3RyaW5nKTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLndob2xlV29yZCkge1xyXG4gICAgICAgIGlmICghL1xcQi8udGVzdChzZWFyY2hTdHJpbmcuY2hhckF0KDApKSkge1xyXG4gICAgICAgICAgICBzZWFyY2hTdHJpbmcgPSAnXFxcXGInICsgc2VhcmNoU3RyaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIS9cXEIvLnRlc3Qoc2VhcmNoU3RyaW5nLmNoYXJBdChzZWFyY2hTdHJpbmcubGVuZ3RoIC0gMSkpKSB7XHJcbiAgICAgICAgICAgIHNlYXJjaFN0cmluZyA9IHNlYXJjaFN0cmluZyArICdcXFxcYic7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IG1vZGlmaWVycyA9ICcnO1xyXG4gICAgaWYgKG9wdGlvbnMuZ2xvYmFsKSB7XHJcbiAgICAgICAgbW9kaWZpZXJzICs9ICdnJztcclxuICAgIH1cclxuICAgIGlmICghb3B0aW9ucy5tYXRjaENhc2UpIHtcclxuICAgICAgICBtb2RpZmllcnMgKz0gJ2knO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMubXVsdGlsaW5lKSB7XHJcbiAgICAgICAgbW9kaWZpZXJzICs9ICdtJztcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLnVuaWNvZGUpIHtcclxuICAgICAgICBtb2RpZmllcnMgKz0gJ3UnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc2VhcmNoU3RyaW5nLCBtb2RpZmllcnMpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiByZWdFeHBMZWFkc1RvRW5kbGVzc0xvb3AocmVnZXhwKSB7XHJcbiAgICAvLyBFeGl0IGVhcmx5IGlmIGl0J3Mgb25lIG9mIHRoZXNlIHNwZWNpYWwgY2FzZXMgd2hpY2ggYXJlIG1lYW50IHRvIG1hdGNoXHJcbiAgICAvLyBhZ2FpbnN0IGFuIGVtcHR5IHN0cmluZ1xyXG4gICAgaWYgKHJlZ2V4cC5zb3VyY2UgPT09ICdeJyB8fCByZWdleHAuc291cmNlID09PSAnXiQnIHx8IHJlZ2V4cC5zb3VyY2UgPT09ICckJyB8fCByZWdleHAuc291cmNlID09PSAnXlxcXFxzKiQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gV2UgY2hlY2sgYWdhaW5zdCBhbiBlbXB0eSBzdHJpbmcuIElmIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gZG9lc24ndCBhZHZhbmNlXHJcbiAgICAvLyAoZS5nLiBlbmRzIGluIGFuIGVuZGxlc3MgbG9vcCkgaXQgd2lsbCBtYXRjaCBhbiBlbXB0eSBzdHJpbmcuXHJcbiAgICBjb25zdCBtYXRjaCA9IHJlZ2V4cC5leGVjKCcnKTtcclxuICAgIHJldHVybiAhIShtYXRjaCAmJiByZWdleHAubGFzdEluZGV4ID09PSAwKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcmVnRXhwRmxhZ3MocmVnZXhwKSB7XHJcbiAgICByZXR1cm4gKHJlZ2V4cC5nbG9iYWwgPyAnZycgOiAnJylcclxuICAgICAgICArIChyZWdleHAuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKVxyXG4gICAgICAgICsgKHJlZ2V4cC5tdWx0aWxpbmUgPyAnbScgOiAnJylcclxuICAgICAgICArIChyZWdleHAgLyogc3RhbmRhbG9uZSBlZGl0b3IgY29tcGlsYXRpb24gKi8udW5pY29kZSA/ICd1JyA6ICcnKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBmaXJzdCBpbmRleCBvZiB0aGUgc3RyaW5nIHRoYXQgaXMgbm90IHdoaXRlc3BhY2UuXHJcbiAqIElmIHN0cmluZyBpcyBlbXB0eSBvciBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VzLCByZXR1cm5zIC0xXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmlyc3ROb25XaGl0ZXNwYWNlSW5kZXgoc3RyKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hDb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGNoQ29kZSAhPT0gMzIgLyogU3BhY2UgKi8gJiYgY2hDb2RlICE9PSA5IC8qIFRhYiAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGxlYWRpbmcgd2hpdGVzcGFjZSBvZiB0aGUgc3RyaW5nLlxyXG4gKiBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZXMsIHJldHVybnMgZW50aXJlIHN0cmluZ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldExlYWRpbmdXaGl0ZXNwYWNlKHN0ciwgc3RhcnQgPSAwLCBlbmQgPSBzdHIubGVuZ3RoKSB7XHJcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjaENvZGUgIT09IDMyIC8qIFNwYWNlICovICYmIGNoQ29kZSAhPT0gOSAvKiBUYWIgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoc3RhcnQsIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGxhc3QgaW5kZXggb2YgdGhlIHN0cmluZyB0aGF0IGlzIG5vdCB3aGl0ZXNwYWNlLlxyXG4gKiBJZiBzdHJpbmcgaXMgZW1wdHkgb3IgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlcywgcmV0dXJucyAtMVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxhc3ROb25XaGl0ZXNwYWNlSW5kZXgoc3RyLCBzdGFydEluZGV4ID0gc3RyLmxlbmd0aCAtIDEpIHtcclxuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGNvbnN0IGNoQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjaENvZGUgIT09IDMyIC8qIFNwYWNlICovICYmIGNoQ29kZSAhPT0gOSAvKiBUYWIgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcclxuICAgIGlmIChhIDwgYikge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGEgPiBiKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZVN1YnN0cmluZyhhLCBiLCBhU3RhcnQgPSAwLCBhRW5kID0gYS5sZW5ndGgsIGJTdGFydCA9IDAsIGJFbmQgPSBiLmxlbmd0aCkge1xyXG4gICAgZm9yICg7IGFTdGFydCA8IGFFbmQgJiYgYlN0YXJ0IDwgYkVuZDsgYVN0YXJ0KyssIGJTdGFydCsrKSB7XHJcbiAgICAgICAgbGV0IGNvZGVBID0gYS5jaGFyQ29kZUF0KGFTdGFydCk7XHJcbiAgICAgICAgbGV0IGNvZGVCID0gYi5jaGFyQ29kZUF0KGJTdGFydCk7XHJcbiAgICAgICAgaWYgKGNvZGVBIDwgY29kZUIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb2RlQSA+IGNvZGVCKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGFMZW4gPSBhRW5kIC0gYVN0YXJ0O1xyXG4gICAgY29uc3QgYkxlbiA9IGJFbmQgLSBiU3RhcnQ7XHJcbiAgICBpZiAoYUxlbiA8IGJMZW4pIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhTGVuID4gYkxlbikge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVJZ25vcmVDYXNlKGEsIGIpIHtcclxuICAgIHJldHVybiBjb21wYXJlU3Vic3RyaW5nSWdub3JlQ2FzZShhLCBiLCAwLCBhLmxlbmd0aCwgMCwgYi5sZW5ndGgpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlU3Vic3RyaW5nSWdub3JlQ2FzZShhLCBiLCBhU3RhcnQgPSAwLCBhRW5kID0gYS5sZW5ndGgsIGJTdGFydCA9IDAsIGJFbmQgPSBiLmxlbmd0aCkge1xyXG4gICAgZm9yICg7IGFTdGFydCA8IGFFbmQgJiYgYlN0YXJ0IDwgYkVuZDsgYVN0YXJ0KyssIGJTdGFydCsrKSB7XHJcbiAgICAgICAgbGV0IGNvZGVBID0gYS5jaGFyQ29kZUF0KGFTdGFydCk7XHJcbiAgICAgICAgbGV0IGNvZGVCID0gYi5jaGFyQ29kZUF0KGJTdGFydCk7XHJcbiAgICAgICAgaWYgKGNvZGVBID09PSBjb2RlQikge1xyXG4gICAgICAgICAgICAvLyBlcXVhbFxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGlmZiA9IGNvZGVBIC0gY29kZUI7XHJcbiAgICAgICAgaWYgKGRpZmYgPT09IDMyICYmIGlzVXBwZXJBc2NpaUxldHRlcihjb2RlQikpIHsgLy9jb2RlQiA9WzY1LTkwXSAmJiBjb2RlQSA9Wzk3LTEyMl1cclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRpZmYgPT09IC0zMiAmJiBpc1VwcGVyQXNjaWlMZXR0ZXIoY29kZUEpKSB7IC8vY29kZUIgPVs5Ny0xMjJdICYmIGNvZGVBID1bNjUtOTBdXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNMb3dlckFzY2lpTGV0dGVyKGNvZGVBKSAmJiBpc0xvd2VyQXNjaWlMZXR0ZXIoY29kZUIpKSB7XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVTdWJzdHJpbmcoYS50b0xvd2VyQ2FzZSgpLCBiLnRvTG93ZXJDYXNlKCksIGFTdGFydCwgYUVuZCwgYlN0YXJ0LCBiRW5kKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBhTGVuID0gYUVuZCAtIGFTdGFydDtcclxuICAgIGNvbnN0IGJMZW4gPSBiRW5kIC0gYlN0YXJ0O1xyXG4gICAgaWYgKGFMZW4gPCBiTGVuKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYUxlbiA+IGJMZW4pIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpc0xvd2VyQXNjaWlMZXR0ZXIoY29kZSkge1xyXG4gICAgcmV0dXJuIGNvZGUgPj0gOTcgLyogYSAqLyAmJiBjb2RlIDw9IDEyMiAvKiB6ICovO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpc1VwcGVyQXNjaWlMZXR0ZXIoY29kZSkge1xyXG4gICAgcmV0dXJuIGNvZGUgPj0gNjUgLyogQSAqLyAmJiBjb2RlIDw9IDkwIC8qIFogKi87XHJcbn1cclxuZnVuY3Rpb24gaXNBc2NpaUxldHRlcihjb2RlKSB7XHJcbiAgICByZXR1cm4gaXNMb3dlckFzY2lpTGV0dGVyKGNvZGUpIHx8IGlzVXBwZXJBc2NpaUxldHRlcihjb2RlKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzSWdub3JlQ2FzZShhLCBiKSB7XHJcbiAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGRvRXF1YWxzSWdub3JlQ2FzZShhLCBiKTtcclxufVxyXG5mdW5jdGlvbiBkb0VxdWFsc0lnbm9yZUNhc2UoYSwgYiwgc3RvcEF0ID0gYS5sZW5ndGgpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RvcEF0OyBpKyspIHtcclxuICAgICAgICBjb25zdCBjb2RlQSA9IGEuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBjb25zdCBjb2RlQiA9IGIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoY29kZUEgPT09IGNvZGVCKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhLXogQS1aXHJcbiAgICAgICAgaWYgKGlzQXNjaWlMZXR0ZXIoY29kZUEpICYmIGlzQXNjaWlMZXR0ZXIoY29kZUIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBNYXRoLmFicyhjb2RlQSAtIGNvZGVCKTtcclxuICAgICAgICAgICAgaWYgKGRpZmYgIT09IDAgJiYgZGlmZiAhPT0gMzIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBbnkgb3RoZXIgY2hhcmNvZGVcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZUEpLnRvTG93ZXJDYXNlKCkgIT09IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZUIpLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBzdGFydHNXaXRoSWdub3JlQ2FzZShzdHIsIGNhbmRpZGF0ZSkge1xyXG4gICAgY29uc3QgY2FuZGlkYXRlTGVuZ3RoID0gY2FuZGlkYXRlLmxlbmd0aDtcclxuICAgIGlmIChjYW5kaWRhdGUubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBkb0VxdWFsc0lnbm9yZUNhc2Uoc3RyLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZUxlbmd0aCk7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGNvbW1vbiBwcmVmaXggb2YgdGhlIHR3byBzdHJpbmdzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1vblByZWZpeExlbmd0aChhLCBiKSB7XHJcbiAgICBsZXQgaSwgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmIChhLmNoYXJDb2RlQXQoaSkgIT09IGIuY2hhckNvZGVBdChpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVuO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBjb21tb24gc3VmZml4IG9mIHRoZSB0d28gc3RyaW5ncy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21tb25TdWZmaXhMZW5ndGgoYSwgYikge1xyXG4gICAgbGV0IGksIGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XHJcbiAgICBjb25zdCBhTGFzdEluZGV4ID0gYS5sZW5ndGggLSAxO1xyXG4gICAgY29uc3QgYkxhc3RJbmRleCA9IGIubGVuZ3RoIC0gMTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmIChhLmNoYXJDb2RlQXQoYUxhc3RJbmRleCAtIGkpICE9PSBiLmNoYXJDb2RlQXQoYkxhc3RJbmRleCAtIGkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBsZW47XHJcbn1cclxuLyoqXHJcbiAqIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1cnJvZ2F0ZV9wYWlyXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlKSB7XHJcbiAgICByZXR1cm4gKDB4RDgwMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAweERCRkYpO1xyXG59XHJcbi8qKlxyXG4gKiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdXJyb2dhdGVfcGFpclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTG93U3Vycm9nYXRlKGNoYXJDb2RlKSB7XHJcbiAgICByZXR1cm4gKDB4REMwMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAweERGRkYpO1xyXG59XHJcbi8qKlxyXG4gKiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdXJyb2dhdGVfcGFpclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVDb2RlUG9pbnQoaGlnaFN1cnJvZ2F0ZSwgbG93U3Vycm9nYXRlKSB7XHJcbiAgICByZXR1cm4gKChoaWdoU3Vycm9nYXRlIC0gMHhEODAwKSA8PCAxMCkgKyAobG93U3Vycm9nYXRlIC0gMHhEQzAwKSArIDB4MTAwMDA7XHJcbn1cclxuLyoqXHJcbiAqIGdldCB0aGUgY29kZSBwb2ludCB0aGF0IGJlZ2lucyBhdCBvZmZzZXQgYG9mZnNldGBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXROZXh0Q29kZVBvaW50KHN0ciwgbGVuLCBvZmZzZXQpIHtcclxuICAgIGNvbnN0IGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQob2Zmc2V0KTtcclxuICAgIGlmIChpc0hpZ2hTdXJyb2dhdGUoY2hhckNvZGUpICYmIG9mZnNldCArIDEgPCBsZW4pIHtcclxuICAgICAgICBjb25zdCBuZXh0Q2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChvZmZzZXQgKyAxKTtcclxuICAgICAgICBpZiAoaXNMb3dTdXJyb2dhdGUobmV4dENoYXJDb2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcHV0ZUNvZGVQb2ludChjaGFyQ29kZSwgbmV4dENoYXJDb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hhckNvZGU7XHJcbn1cclxuLyoqXHJcbiAqIGdldCB0aGUgY29kZSBwb2ludCB0aGF0IGVuZHMgcmlnaHQgYmVmb3JlIG9mZnNldCBgb2Zmc2V0YFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UHJldkNvZGVQb2ludChzdHIsIG9mZnNldCkge1xyXG4gICAgY29uc3QgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChvZmZzZXQgLSAxKTtcclxuICAgIGlmIChpc0xvd1N1cnJvZ2F0ZShjaGFyQ29kZSkgJiYgb2Zmc2V0ID4gMSkge1xyXG4gICAgICAgIGNvbnN0IHByZXZDaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KG9mZnNldCAtIDIpO1xyXG4gICAgICAgIGlmIChpc0hpZ2hTdXJyb2dhdGUocHJldkNoYXJDb2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcHV0ZUNvZGVQb2ludChwcmV2Q2hhckNvZGUsIGNoYXJDb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hhckNvZGU7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIG5leHRDaGFyTGVuZ3RoKHN0ciwgb2Zmc2V0KSB7XHJcbiAgICBjb25zdCBncmFwaGVtZUJyZWFrVHJlZSA9IEdyYXBoZW1lQnJlYWtUcmVlLmdldEluc3RhbmNlKCk7XHJcbiAgICBjb25zdCBpbml0aWFsT2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcclxuICAgIGNvbnN0IGluaXRpYWxDb2RlUG9pbnQgPSBnZXROZXh0Q29kZVBvaW50KHN0ciwgbGVuLCBvZmZzZXQpO1xyXG4gICAgb2Zmc2V0ICs9IChpbml0aWFsQ29kZVBvaW50ID49IDY1NTM2IC8qIFVOSUNPREVfU1VQUExFTUVOVEFSWV9QTEFORV9CRUdJTiAqLyA/IDIgOiAxKTtcclxuICAgIGxldCBncmFwaGVtZUJyZWFrVHlwZSA9IGdyYXBoZW1lQnJlYWtUcmVlLmdldEdyYXBoZW1lQnJlYWtUeXBlKGluaXRpYWxDb2RlUG9pbnQpO1xyXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbikge1xyXG4gICAgICAgIGNvbnN0IG5leHRDb2RlUG9pbnQgPSBnZXROZXh0Q29kZVBvaW50KHN0ciwgbGVuLCBvZmZzZXQpO1xyXG4gICAgICAgIGNvbnN0IG5leHRHcmFwaGVtZUJyZWFrVHlwZSA9IGdyYXBoZW1lQnJlYWtUcmVlLmdldEdyYXBoZW1lQnJlYWtUeXBlKG5leHRDb2RlUG9pbnQpO1xyXG4gICAgICAgIGlmIChicmVha0JldHdlZW5HcmFwaGVtZUJyZWFrVHlwZShncmFwaGVtZUJyZWFrVHlwZSwgbmV4dEdyYXBoZW1lQnJlYWtUeXBlKSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IChuZXh0Q29kZVBvaW50ID49IDY1NTM2IC8qIFVOSUNPREVfU1VQUExFTUVOVEFSWV9QTEFORV9CRUdJTiAqLyA/IDIgOiAxKTtcclxuICAgICAgICBncmFwaGVtZUJyZWFrVHlwZSA9IG5leHRHcmFwaGVtZUJyZWFrVHlwZTtcclxuICAgIH1cclxuICAgIHJldHVybiAob2Zmc2V0IC0gaW5pdGlhbE9mZnNldCk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHByZXZDaGFyTGVuZ3RoKHN0ciwgb2Zmc2V0KSB7XHJcbiAgICBjb25zdCBncmFwaGVtZUJyZWFrVHJlZSA9IEdyYXBoZW1lQnJlYWtUcmVlLmdldEluc3RhbmNlKCk7XHJcbiAgICBjb25zdCBpbml0aWFsT2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgY29uc3QgaW5pdGlhbENvZGVQb2ludCA9IGdldFByZXZDb2RlUG9pbnQoc3RyLCBvZmZzZXQpO1xyXG4gICAgb2Zmc2V0IC09IChpbml0aWFsQ29kZVBvaW50ID49IDY1NTM2IC8qIFVOSUNPREVfU1VQUExFTUVOVEFSWV9QTEFORV9CRUdJTiAqLyA/IDIgOiAxKTtcclxuICAgIGxldCBncmFwaGVtZUJyZWFrVHlwZSA9IGdyYXBoZW1lQnJlYWtUcmVlLmdldEdyYXBoZW1lQnJlYWtUeXBlKGluaXRpYWxDb2RlUG9pbnQpO1xyXG4gICAgd2hpbGUgKG9mZnNldCA+IDApIHtcclxuICAgICAgICBjb25zdCBwcmV2Q29kZVBvaW50ID0gZ2V0UHJldkNvZGVQb2ludChzdHIsIG9mZnNldCk7XHJcbiAgICAgICAgY29uc3QgcHJldkdyYXBoZW1lQnJlYWtUeXBlID0gZ3JhcGhlbWVCcmVha1RyZWUuZ2V0R3JhcGhlbWVCcmVha1R5cGUocHJldkNvZGVQb2ludCk7XHJcbiAgICAgICAgaWYgKGJyZWFrQmV0d2VlbkdyYXBoZW1lQnJlYWtUeXBlKHByZXZHcmFwaGVtZUJyZWFrVHlwZSwgZ3JhcGhlbWVCcmVha1R5cGUpKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgLT0gKHByZXZDb2RlUG9pbnQgPj0gNjU1MzYgLyogVU5JQ09ERV9TVVBQTEVNRU5UQVJZX1BMQU5FX0JFR0lOICovID8gMiA6IDEpO1xyXG4gICAgICAgIGdyYXBoZW1lQnJlYWtUeXBlID0gcHJldkdyYXBoZW1lQnJlYWtUeXBlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChpbml0aWFsT2Zmc2V0IC0gb2Zmc2V0KTtcclxufVxyXG4vKipcclxuICogQSBtYW51YWwgZGVjb2Rpbmcgb2YgYSBVVEY4IHN0cmluZy5cclxuICogVXNlIG9ubHkgaW4gZW52aXJvbm1lbnRzIHdoaWNoIGRvIG5vdCBvZmZlciBuYXRpdmUgY29udmVyc2lvbiBtZXRob2RzIVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVVURjgoYnVmZmVyKSB7XHJcbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOFxyXG4gICAgY29uc3QgbGVuID0gYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbikge1xyXG4gICAgICAgIGNvbnN0IHYwID0gYnVmZmVyW29mZnNldF07XHJcbiAgICAgICAgbGV0IGNvZGVQb2ludDtcclxuICAgICAgICBpZiAodjAgPj0gMGIxMTExMDAwMCAmJiBvZmZzZXQgKyAzIDwgbGVuKSB7XHJcbiAgICAgICAgICAgIC8vIDQgYnl0ZXNcclxuICAgICAgICAgICAgY29kZVBvaW50ID0gKCgoKGJ1ZmZlcltvZmZzZXQrK10gJiAwYjAwMDAwMTExKSA8PCAxOCkgPj4+IDApXHJcbiAgICAgICAgICAgICAgICB8ICgoKGJ1ZmZlcltvZmZzZXQrK10gJiAwYjAwMTExMTExKSA8PCAxMikgPj4+IDApXHJcbiAgICAgICAgICAgICAgICB8ICgoKGJ1ZmZlcltvZmZzZXQrK10gJiAwYjAwMTExMTExKSA8PCA2KSA+Pj4gMClcclxuICAgICAgICAgICAgICAgIHwgKCgoYnVmZmVyW29mZnNldCsrXSAmIDBiMDAxMTExMTEpIDw8IDApID4+PiAwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHYwID49IDBiMTExMDAwMDAgJiYgb2Zmc2V0ICsgMiA8IGxlbikge1xyXG4gICAgICAgICAgICAvLyAzIGJ5dGVzXHJcbiAgICAgICAgICAgIGNvZGVQb2ludCA9ICgoKChidWZmZXJbb2Zmc2V0KytdICYgMGIwMDAwMTExMSkgPDwgMTIpID4+PiAwKVxyXG4gICAgICAgICAgICAgICAgfCAoKChidWZmZXJbb2Zmc2V0KytdICYgMGIwMDExMTExMSkgPDwgNikgPj4+IDApXHJcbiAgICAgICAgICAgICAgICB8ICgoKGJ1ZmZlcltvZmZzZXQrK10gJiAwYjAwMTExMTExKSA8PCAwKSA+Pj4gMCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2MCA+PSAwYjExMDAwMDAwICYmIG9mZnNldCArIDEgPCBsZW4pIHtcclxuICAgICAgICAgICAgLy8gMiBieXRlc1xyXG4gICAgICAgICAgICBjb2RlUG9pbnQgPSAoKCgoYnVmZmVyW29mZnNldCsrXSAmIDBiMDAwMTExMTEpIDw8IDYpID4+PiAwKVxyXG4gICAgICAgICAgICAgICAgfCAoKChidWZmZXJbb2Zmc2V0KytdICYgMGIwMDExMTExMSkgPDwgMCkgPj4+IDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIDEgYnl0ZVxyXG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBidWZmZXJbb2Zmc2V0KytdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKGNvZGVQb2ludCA+PSAwICYmIGNvZGVQb2ludCA8PSAweEQ3RkYpIHx8IChjb2RlUG9pbnQgPj0gMHhFMDAwICYmIGNvZGVQb2ludCA8PSAweEZGRkYpKSB7XHJcbiAgICAgICAgICAgIC8vIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZVxyXG4gICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XHJcbiAgICAgICAgICAgIC8vIFN1cHBsZW1lbnRhcnkgUGxhbmVzXHJcbiAgICAgICAgICAgIGNvbnN0IHVQcmltZSA9IGNvZGVQb2ludCAtIDB4MTAwMDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHcxID0gMHhEODAwICsgKCh1UHJpbWUgJiAwYjExMTExMTExMTEwMDAwMDAwMDAwKSA+Pj4gMTApO1xyXG4gICAgICAgICAgICBjb25zdCB3MiA9IDB4REMwMCArICgodVByaW1lICYgMGIwMDAwMDAwMDAwMTExMTExMTExMSkgPj4+IDApO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHcxKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUodzIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGlsbGVnYWwgY29kZSBwb2ludFxyXG4gICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XHJcbn1cclxuLyoqXHJcbiAqIEdlbmVyYXRlZCB1c2luZyBodHRwczovL2dpdGh1Yi5jb20vYWxleGFuZHJ1ZGltYS91bmljb2RlLXV0aWxzL2Jsb2IvbWFzdGVyL2dlbmVyYXRlLXJ0bC10ZXN0LmpzXHJcbiAqL1xyXG5jb25zdCBDT05UQUlOU19SVEwgPSAvKD86W1xcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUQwLVxcdTA1RjRcXHUwNjA4XFx1MDYwQlxcdTA2MERcXHUwNjFCLVxcdTA2NEFcXHUwNjZELVxcdTA2NkZcXHUwNjcxLVxcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODMwLVxcdTA4NThcXHUwODVFLVxcdTA4QkRcXHUyMDBGXFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkQzRFxcdUZENTAtXFx1RkRGQ1xcdUZFNzAtXFx1RkVGQ118XFx1RDgwMltcXHVEQzAwLVxcdUREMUJcXHVERDIwLVxcdURFMDBcXHVERTEwLVxcdURFMzNcXHVERTQwLVxcdURFRTRcXHVERUVCLVxcdURGMzVcXHVERjQwLVxcdURGRkZdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQ0ZGXXxcXHVEODNBW1xcdURDMDAtXFx1RENDRlxcdUREMDAtXFx1REQ0M1xcdURENTAtXFx1REZGRl18XFx1RDgzQltcXHVEQzAwLVxcdURFQkJdKS87XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgYHN0cmAgY29udGFpbnMgYW55IFVuaWNvZGUgY2hhcmFjdGVyIHRoYXQgaXMgY2xhc3NpZmllZCBhcyBcIlJcIiBvciBcIkFMXCIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNSVEwoc3RyKSB7XHJcbiAgICByZXR1cm4gQ09OVEFJTlNfUlRMLnRlc3Qoc3RyKTtcclxufVxyXG4vKipcclxuICogR2VuZXJhdGVkIHVzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGV4YW5kcnVkaW1hL3VuaWNvZGUtdXRpbHMvYmxvYi9tYXN0ZXIvZ2VuZXJhdGUtZW1vamktdGVzdC5qc1xyXG4gKi9cclxuY29uc3QgQ09OVEFJTlNfRU1PSkkgPSAvKD86W1xcdTIzMUFcXHUyMzFCXFx1MjNGMFxcdTIzRjNcXHUyNjAwLVxcdTI3QkZcXHUyQjUwXFx1MkI1NV18XFx1RDgzQ1tcXHVEREU2LVxcdURERkZcXHVERjAwLVxcdURGRkZdfFxcdUQ4M0RbXFx1REMwMC1cXHVERTRGXFx1REU4MC1cXHVERUZDXFx1REZFMC1cXHVERkVCXXxcXHVEODNFW1xcdUREMDAtXFx1RERGRlxcdURFNzAtXFx1REU3M1xcdURFNzgtXFx1REU4MlxcdURFOTAtXFx1REU5NV0pLztcclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zRW1vamkoc3RyKSB7XHJcbiAgICByZXR1cm4gQ09OVEFJTlNfRU1PSkkudGVzdChzdHIpO1xyXG59XHJcbmNvbnN0IElTX0JBU0lDX0FTQ0lJID0gL15bXFx0XFxuXFxyXFx4MjAtXFx4N0VdKiQvO1xyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGBzdHJgIGNvbnRhaW5zIG9ubHkgYmFzaWMgQVNDSUkgY2hhcmFjdGVycyBpbiB0aGUgcmFuZ2UgMzIgLSAxMjYgKGluY2x1ZGluZyAzMiBhbmQgMTI2KSBvciBcXG4sIFxcciwgXFx0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNCYXNpY0FTQ0lJKHN0cikge1xyXG4gICAgcmV0dXJuIElTX0JBU0lDX0FTQ0lJLnRlc3Qoc3RyKTtcclxufVxyXG5leHBvcnQgY29uc3QgVU5VU1VBTF9MSU5FX1RFUk1JTkFUT1JTID0gL1tcXHUyMDI4XFx1MjAyOV0vOyAvLyBMSU5FIFNFUEFSQVRPUiAoTFMpIG9yIFBBUkFHUkFQSCBTRVBBUkFUT1IgKFBTKVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGBzdHJgIGNvbnRhaW5zIHVudXN1YWwgbGluZSB0ZXJtaW5hdG9ycywgbGlrZSBMUyBvciBQU1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zVW51c3VhbExpbmVUZXJtaW5hdG9ycyhzdHIpIHtcclxuICAgIHJldHVybiBVTlVTVUFMX0xJTkVfVEVSTUlOQVRPUlMudGVzdChzdHIpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc0Z1bGxXaWR0aENoYXJhY3RlcihzdHIpIHtcclxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZiAoaXNGdWxsV2lkdGhDaGFyYWN0ZXIoc3RyLmNoYXJDb2RlQXQoaSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaXNGdWxsV2lkdGhDaGFyYWN0ZXIoY2hhckNvZGUpIHtcclxuICAgIC8vIERvIGEgY2hlYXAgdHJpY2sgdG8gYmV0dGVyIHN1cHBvcnQgd3JhcHBpbmcgb2Ygd2lkZSBjaGFyYWN0ZXJzLCB0cmVhdCB0aGVtIGFzIDIgY29sdW1uc1xyXG4gICAgLy8gaHR0cDovL2pyZ3JhcGhpeC5uZXQvcmVzZWFyY2gvdW5pY29kZV9ibG9ja3MucGhwXHJcbiAgICAvLyAgICAgICAgICAyRTgwIOKAlCAyRUZGICAgQ0pLIFJhZGljYWxzIFN1cHBsZW1lbnRcclxuICAgIC8vICAgICAgICAgIDJGMDAg4oCUIDJGREYgICBLYW5neGkgUmFkaWNhbHNcclxuICAgIC8vICAgICAgICAgIDJGRjAg4oCUIDJGRkYgICBJZGVvZ3JhcGhpYyBEZXNjcmlwdGlvbiBDaGFyYWN0ZXJzXHJcbiAgICAvLyAgICAgICAgICAzMDAwIOKAlCAzMDNGICAgQ0pLIFN5bWJvbHMgYW5kIFB1bmN0dWF0aW9uXHJcbiAgICAvLyAgICAgICAgICAzMDQwIOKAlCAzMDlGICAgSGlyYWdhbmFcclxuICAgIC8vICAgICAgICAgIDMwQTAg4oCUIDMwRkYgICBLYXRha2FuYVxyXG4gICAgLy8gICAgICAgICAgMzEwMCDigJQgMzEyRiAgIEJvcG9tb2ZvXHJcbiAgICAvLyAgICAgICAgICAzMTMwIOKAlCAzMThGICAgSGFuZ3VsIENvbXBhdGliaWxpdHkgSmFtb1xyXG4gICAgLy8gICAgICAgICAgMzE5MCDigJQgMzE5RiAgIEthbmJ1blxyXG4gICAgLy8gICAgICAgICAgMzFBMCDigJQgMzFCRiAgIEJvcG9tb2ZvIEV4dGVuZGVkXHJcbiAgICAvLyAgICAgICAgICAzMUYwIOKAlCAzMUZGICAgS2F0YWthbmEgUGhvbmV0aWMgRXh0ZW5zaW9uc1xyXG4gICAgLy8gICAgICAgICAgMzIwMCDigJQgMzJGRiAgIEVuY2xvc2VkIENKSyBMZXR0ZXJzIGFuZCBNb250aHNcclxuICAgIC8vICAgICAgICAgIDMzMDAg4oCUIDMzRkYgICBDSksgQ29tcGF0aWJpbGl0eVxyXG4gICAgLy8gICAgICAgICAgMzQwMCDigJQgNERCRiAgIENKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEFcclxuICAgIC8vICAgICAgICAgIDREQzAg4oCUIDRERkYgICBZaWppbmcgSGV4YWdyYW0gU3ltYm9sc1xyXG4gICAgLy8gICAgICAgICAgNEUwMCDigJQgOUZGRiAgIENKSyBVbmlmaWVkIElkZW9ncmFwaHNcclxuICAgIC8vICAgICAgICAgIEEwMDAg4oCUIEE0OEYgICBZaSBTeWxsYWJsZXNcclxuICAgIC8vICAgICAgICAgIEE0OTAg4oCUIEE0Q0YgICBZaSBSYWRpY2Fsc1xyXG4gICAgLy8gICAgICAgICAgQUMwMCDigJQgRDdBRiAgIEhhbmd1bCBTeWxsYWJsZXNcclxuICAgIC8vIFtJR05PUkVdIEQ4MDAg4oCUIERCN0YgICBIaWdoIFN1cnJvZ2F0ZXNcclxuICAgIC8vIFtJR05PUkVdIERCODAg4oCUIERCRkYgICBIaWdoIFByaXZhdGUgVXNlIFN1cnJvZ2F0ZXNcclxuICAgIC8vIFtJR05PUkVdIERDMDAg4oCUIERGRkYgICBMb3cgU3Vycm9nYXRlc1xyXG4gICAgLy8gW0lHTk9SRV0gRTAwMCDigJQgRjhGRiAgIFByaXZhdGUgVXNlIEFyZWFcclxuICAgIC8vICAgICAgICAgIEY5MDAg4oCUIEZBRkYgICBDSksgQ29tcGF0aWJpbGl0eSBJZGVvZ3JhcGhzXHJcbiAgICAvLyBbSUdOT1JFXSBGQjAwIOKAlCBGQjRGICAgQWxwaGFiZXRpYyBQcmVzZW50YXRpb24gRm9ybXNcclxuICAgIC8vIFtJR05PUkVdIEZCNTAg4oCUIEZERkYgICBBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUFcclxuICAgIC8vIFtJR05PUkVdIEZFMDAg4oCUIEZFMEYgICBWYXJpYXRpb24gU2VsZWN0b3JzXHJcbiAgICAvLyBbSUdOT1JFXSBGRTIwIOKAlCBGRTJGICAgQ29tYmluaW5nIEhhbGYgTWFya3NcclxuICAgIC8vIFtJR05PUkVdIEZFMzAg4oCUIEZFNEYgICBDSksgQ29tcGF0aWJpbGl0eSBGb3Jtc1xyXG4gICAgLy8gW0lHTk9SRV0gRkU1MCDigJQgRkU2RiAgIFNtYWxsIEZvcm0gVmFyaWFudHNcclxuICAgIC8vIFtJR05PUkVdIEZFNzAg4oCUIEZFRkYgICBBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUJcclxuICAgIC8vICAgICAgICAgIEZGMDAg4oCUIEZGRUYgICBIYWxmd2lkdGggYW5kIEZ1bGx3aWR0aCBGb3Jtc1xyXG4gICAgLy8gICAgICAgICAgICAgICBbaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGFsZndpZHRoX2FuZF9mdWxsd2lkdGhfZm9ybXNdXHJcbiAgICAvLyAgICAgICAgICAgICAgIG9mIHdoaWNoIEZGMDEgLSBGRjVFIGZ1bGx3aWR0aCBBU0NJSSBvZiAyMSB0byA3RVxyXG4gICAgLy8gW0lHTk9SRV0gICAgYW5kIEZGNjUgLSBGRkRDIGhhbGZ3aWR0aCBvZiBLYXRha2FuYSBhbmQgSGFuZ3VsXHJcbiAgICAvLyBbSUdOT1JFXSBGRkYwIOKAlCBGRkZGICAgU3BlY2lhbHNcclxuICAgIGNoYXJDb2RlID0gK2NoYXJDb2RlOyAvLyBAcGVyZlxyXG4gICAgcmV0dXJuICgoY2hhckNvZGUgPj0gMHgyRTgwICYmIGNoYXJDb2RlIDw9IDB4RDdBRilcclxuICAgICAgICB8fCAoY2hhckNvZGUgPj0gMHhGOTAwICYmIGNoYXJDb2RlIDw9IDB4RkFGRilcclxuICAgICAgICB8fCAoY2hhckNvZGUgPj0gMHhGRjAxICYmIGNoYXJDb2RlIDw9IDB4RkY1RSkpO1xyXG59XHJcbi8qKlxyXG4gKiBBIGZhc3QgZnVuY3Rpb24gKHRoZXJlZm9yZSBpbXByZWNpc2UpIHRvIGNoZWNrIGlmIGNvZGUgcG9pbnRzIGFyZSBlbW9qaXMuXHJcbiAqIEdlbmVyYXRlZCB1c2luZyBodHRwczovL2dpdGh1Yi5jb20vYWxleGFuZHJ1ZGltYS91bmljb2RlLXV0aWxzL2Jsb2IvbWFzdGVyL2dlbmVyYXRlLWVtb2ppLXRlc3QuanNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0Vtb2ppSW1wcmVjaXNlKHgpIHtcclxuICAgIHJldHVybiAoKHggPj0gMHgxRjFFNiAmJiB4IDw9IDB4MUYxRkYpIHx8ICh4ID49IDk3MjggJiYgeCA8PSAxMDE3NSkgfHwgKHggPj0gMTI3NzQ0ICYmIHggPD0gMTI4NTkxKVxyXG4gICAgICAgIHx8ICh4ID49IDEyODY0MCAmJiB4IDw9IDEyODc2NCkgfHwgKHggPj0gMTI4OTkyICYmIHggPD0gMTI5MDAzKSB8fCAoeCA+PSAxMjkyODAgJiYgeCA8PSAxMjk1MzUpXHJcbiAgICAgICAgfHwgKHggPj0gMTI5NjQ4ICYmIHggPD0gMTI5NjUxKSB8fCAoeCA+PSAxMjk2NTYgJiYgeCA8PSAxMjk2NjYpIHx8ICh4ID49IDEyOTY4MCAmJiB4IDw9IDEyOTY4NSkpO1xyXG59XHJcbi8vIC0tIFVURi04IEJPTVxyXG5leHBvcnQgY29uc3QgVVRGOF9CT01fQ0hBUkFDVEVSID0gU3RyaW5nLmZyb21DaGFyQ29kZSg2NTI3OSAvKiBVVEY4X0JPTSAqLyk7XHJcbmV4cG9ydCBmdW5jdGlvbiBzdGFydHNXaXRoVVRGOEJPTShzdHIpIHtcclxuICAgIHJldHVybiAhIShzdHIgJiYgc3RyLmxlbmd0aCA+IDAgJiYgc3RyLmNoYXJDb2RlQXQoMCkgPT09IDY1Mjc5IC8qIFVURjhfQk9NICovKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNVcHBlcmNhc2VDaGFyYWN0ZXIodGFyZ2V0LCBpZ25vcmVFc2NhcGVkQ2hhcnMgPSBmYWxzZSkge1xyXG4gICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoaWdub3JlRXNjYXBlZENoYXJzKSB7XHJcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnJlcGxhY2UoL1xcXFwuL2csICcnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQudG9Mb3dlckNhc2UoKSAhPT0gdGFyZ2V0O1xyXG59XHJcbi8qKlxyXG4gKiBQcm9kdWNlcyAnYSctJ3onLCBmb2xsb3dlZCBieSAnQSctJ1onLi4uIGZvbGxvd2VkIGJ5ICdhJy0neicsIGV0Yy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzaW5nbGVMZXR0ZXJIYXNoKG4pIHtcclxuICAgIGNvbnN0IExFVFRFUlNfQ05UID0gKDkwIC8qIFogKi8gLSA2NSAvKiBBICovICsgMSk7XHJcbiAgICBuID0gbiAlICgyICogTEVUVEVSU19DTlQpO1xyXG4gICAgaWYgKG4gPCBMRVRURVJTX0NOVCkge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDk3IC8qIGEgKi8gKyBuKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1IC8qIEEgKi8gKyBuIC0gTEVUVEVSU19DTlQpO1xyXG59XHJcbi8vI3JlZ2lvbiBVbmljb2RlIEdyYXBoZW1lIEJyZWFrXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRHcmFwaGVtZUJyZWFrVHlwZShjb2RlUG9pbnQpIHtcclxuICAgIGNvbnN0IGdyYXBoZW1lQnJlYWtUcmVlID0gR3JhcGhlbWVCcmVha1RyZWUuZ2V0SW5zdGFuY2UoKTtcclxuICAgIHJldHVybiBncmFwaGVtZUJyZWFrVHJlZS5nZXRHcmFwaGVtZUJyZWFrVHlwZShjb2RlUG9pbnQpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBicmVha0JldHdlZW5HcmFwaGVtZUJyZWFrVHlwZShicmVha1R5cGVBLCBicmVha1R5cGVCKSB7XHJcbiAgICAvLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIyOS8jR3JhcGhlbWVfQ2x1c3Rlcl9Cb3VuZGFyeV9SdWxlc1xyXG4gICAgLy8gISEhIExldCdzIG1ha2UgdGhlIGNvbW1vbiBjYXNlIGEgYml0IGZhc3RlclxyXG4gICAgaWYgKGJyZWFrVHlwZUEgPT09IDAgLyogT3RoZXIgKi8pIHtcclxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljLzEzLjAuMC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtUZXN0LTEzLjAuMGQxMC5odG1sI3RhYmxlXHJcbiAgICAgICAgcmV0dXJuIChicmVha1R5cGVCICE9PSA1IC8qIEV4dGVuZCAqLyAmJiBicmVha1R5cGVCICE9PSA3IC8qIFNwYWNpbmdNYXJrICovKTtcclxuICAgIH1cclxuICAgIC8vIERvIG5vdCBicmVhayBiZXR3ZWVuIGEgQ1IgYW5kIExGLiBPdGhlcndpc2UsIGJyZWFrIGJlZm9yZSBhbmQgYWZ0ZXIgY29udHJvbHMuXHJcbiAgICAvLyBHQjMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ1Igw5cgTEZcclxuICAgIC8vIEdCNCAgICAgICAgICAgICAgICAgICAgICAgKENvbnRyb2wgfCBDUiB8IExGKSDDt1xyXG4gICAgLy8gR0I1ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIMO3IChDb250cm9sIHwgQ1IgfCBMRilcclxuICAgIGlmIChicmVha1R5cGVBID09PSAyIC8qIENSICovKSB7XHJcbiAgICAgICAgaWYgKGJyZWFrVHlwZUIgPT09IDMgLyogTEYgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjNcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYnJlYWtUeXBlQSA9PT0gNCAvKiBDb250cm9sICovIHx8IGJyZWFrVHlwZUEgPT09IDIgLyogQ1IgKi8gfHwgYnJlYWtUeXBlQSA9PT0gMyAvKiBMRiAqLykge1xyXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBHQjRcclxuICAgIH1cclxuICAgIGlmIChicmVha1R5cGVCID09PSA0IC8qIENvbnRyb2wgKi8gfHwgYnJlYWtUeXBlQiA9PT0gMiAvKiBDUiAqLyB8fCBicmVha1R5cGVCID09PSAzIC8qIExGICovKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEdCNVxyXG4gICAgfVxyXG4gICAgLy8gRG8gbm90IGJyZWFrIEhhbmd1bCBzeWxsYWJsZSBzZXF1ZW5jZXMuXHJcbiAgICAvLyBHQjYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEwgw5cgKEwgfCBWIHwgTFYgfCBMVlQpXHJcbiAgICAvLyBHQjcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKExWIHwgVikgw5cgKFYgfCBUKVxyXG4gICAgLy8gR0I4ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKExWVCB8IFQpIMOXIFRcclxuICAgIGlmIChicmVha1R5cGVBID09PSA4IC8qIEwgKi8pIHtcclxuICAgICAgICBpZiAoYnJlYWtUeXBlQiA9PT0gOCAvKiBMICovIHx8IGJyZWFrVHlwZUIgPT09IDkgLyogViAqLyB8fCBicmVha1R5cGVCID09PSAxMSAvKiBMViAqLyB8fCBicmVha1R5cGVCID09PSAxMiAvKiBMVlQgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjZcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYnJlYWtUeXBlQSA9PT0gMTEgLyogTFYgKi8gfHwgYnJlYWtUeXBlQSA9PT0gOSAvKiBWICovKSB7XHJcbiAgICAgICAgaWYgKGJyZWFrVHlwZUIgPT09IDkgLyogViAqLyB8fCBicmVha1R5cGVCID09PSAxMCAvKiBUICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0I3XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGJyZWFrVHlwZUEgPT09IDEyIC8qIExWVCAqLyB8fCBicmVha1R5cGVBID09PSAxMCAvKiBUICovKSB7XHJcbiAgICAgICAgaWYgKGJyZWFrVHlwZUIgPT09IDEwIC8qIFQgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjhcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBEbyBub3QgYnJlYWsgYmVmb3JlIGV4dGVuZGluZyBjaGFyYWN0ZXJzIG9yIFpXSi5cclxuICAgIC8vIEdCOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDDlyAoRXh0ZW5kIHwgWldKKVxyXG4gICAgaWYgKGJyZWFrVHlwZUIgPT09IDUgLyogRXh0ZW5kICovIHx8IGJyZWFrVHlwZUIgPT09IDEzIC8qIFpXSiAqLykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0I5XHJcbiAgICB9XHJcbiAgICAvLyBUaGUgR0I5YSBhbmQgR0I5YiBydWxlcyBvbmx5IGFwcGx5IHRvIGV4dGVuZGVkIGdyYXBoZW1lIGNsdXN0ZXJzOlxyXG4gICAgLy8gRG8gbm90IGJyZWFrIGJlZm9yZSBTcGFjaW5nTWFya3MsIG9yIGFmdGVyIFByZXBlbmQgY2hhcmFjdGVycy5cclxuICAgIC8vIEdCOWEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDDlyBTcGFjaW5nTWFya1xyXG4gICAgLy8gR0I5YiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcmVwZW5kIMOXXHJcbiAgICBpZiAoYnJlYWtUeXBlQiA9PT0gNyAvKiBTcGFjaW5nTWFyayAqLykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0I5YVxyXG4gICAgfVxyXG4gICAgaWYgKGJyZWFrVHlwZUEgPT09IDEgLyogUHJlcGVuZCAqLykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0I5YlxyXG4gICAgfVxyXG4gICAgLy8gRG8gbm90IGJyZWFrIHdpdGhpbiBlbW9qaSBtb2RpZmllciBzZXF1ZW5jZXMgb3IgZW1vamkgendqIHNlcXVlbmNlcy5cclxuICAgIC8vIEdCMTEgICAgXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY30gRXh0ZW5kKiBaV0ogw5cgXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY31cclxuICAgIGlmIChicmVha1R5cGVBID09PSAxMyAvKiBaV0ogKi8gJiYgYnJlYWtUeXBlQiA9PT0gMTQgLyogRXh0ZW5kZWRfUGljdG9ncmFwaGljICovKSB7XHJcbiAgICAgICAgLy8gTm90ZTogd2UgYXJlIG5vdCBpbXBsZW1lbnRpbmcgdGhlIHJ1bGUgZW50aXJlbHkgaGVyZSB0byBhdm9pZCBpbnRyb2R1Y2luZyBzdGF0ZXNcclxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEdCMTFcclxuICAgIH1cclxuICAgIC8vIEdCMTIgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdCAoUkkgUkkpKiBSSSDDlyBSSVxyXG4gICAgLy8gR0IxMyAgICAgICAgICAgICAgICAgICAgICAgIFteUkldIChSSSBSSSkqIFJJIMOXIFJJXHJcbiAgICBpZiAoYnJlYWtUeXBlQSA9PT0gNiAvKiBSZWdpb25hbF9JbmRpY2F0b3IgKi8gJiYgYnJlYWtUeXBlQiA9PT0gNiAvKiBSZWdpb25hbF9JbmRpY2F0b3IgKi8pIHtcclxuICAgICAgICAvLyBOb3RlOiB3ZSBhcmUgbm90IGltcGxlbWVudGluZyB0aGUgcnVsZSBlbnRpcmVseSBoZXJlIHRvIGF2b2lkIGludHJvZHVjaW5nIHN0YXRlc1xyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0IxMiAmIEdCMTNcclxuICAgIH1cclxuICAgIC8vIEdCOTk5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFueSDDtyBBbnlcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmNsYXNzIEdyYXBoZW1lQnJlYWtUcmVlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBnZXRHcmFwaGVtZUJyZWFrUmF3RGF0YSgpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCkge1xyXG4gICAgICAgIGlmICghR3JhcGhlbWVCcmVha1RyZWUuX0lOU1RBTkNFKSB7XHJcbiAgICAgICAgICAgIEdyYXBoZW1lQnJlYWtUcmVlLl9JTlNUQU5DRSA9IG5ldyBHcmFwaGVtZUJyZWFrVHJlZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gR3JhcGhlbWVCcmVha1RyZWUuX0lOU1RBTkNFO1xyXG4gICAgfVxyXG4gICAgZ2V0R3JhcGhlbWVCcmVha1R5cGUoY29kZVBvaW50KSB7XHJcbiAgICAgICAgLy8gISEhIExldCdzIG1ha2UgN2JpdCBBU0NJSSBhIGJpdCBmYXN0ZXI6IDAuLjMxXHJcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDMyKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPT09IDEwIC8qIExpbmVGZWVkICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMyAvKiBMRiAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29kZVBvaW50ID09PSAxMyAvKiBDYXJyaWFnZVJldHVybiAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogQ1IgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDQgLyogQ29udHJvbCAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gISEhIExldCdzIG1ha2UgN2JpdCBBU0NJSSBhIGJpdCBmYXN0ZXI6IDMyLi4xMjZcclxuICAgICAgICBpZiAoY29kZVBvaW50IDwgMTI3KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwIC8qIE90aGVyICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcclxuICAgICAgICBjb25zdCBub2RlQ291bnQgPSBkYXRhLmxlbmd0aCAvIDM7XHJcbiAgICAgICAgbGV0IG5vZGVJbmRleCA9IDE7XHJcbiAgICAgICAgd2hpbGUgKG5vZGVJbmRleCA8PSBub2RlQ291bnQpIHtcclxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8IGRhdGFbMyAqIG5vZGVJbmRleF0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGdvIGxlZnRcclxuICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IDIgKiBub2RlSW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50ID4gZGF0YVszICogbm9kZUluZGV4ICsgMV0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGdvIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICBub2RlSW5kZXggPSAyICogbm9kZUluZGV4ICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGhpdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFbMyAqIG5vZGVJbmRleCArIDJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwIC8qIE90aGVyICovO1xyXG4gICAgfVxyXG59XHJcbkdyYXBoZW1lQnJlYWtUcmVlLl9JTlNUQU5DRSA9IG51bGw7XHJcbmZ1bmN0aW9uIGdldEdyYXBoZW1lQnJlYWtSYXdEYXRhKCkge1xyXG4gICAgLy8gZ2VuZXJhdGVkIHVzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGV4YW5kcnVkaW1hL3VuaWNvZGUtdXRpbHMvYmxvYi9tYXN0ZXIvZ2VuZXJhdGUtZ3JhcGhlbWUtYnJlYWsuanNcclxuICAgIHJldHVybiBKU09OLnBhcnNlKCdbMCwwLDAsNTE1OTIsNTE1OTIsMTEsNDQ0MjQsNDQ0MjQsMTEsNzIyNTEsNzIyNTQsNSw3MTUwLDcxNTAsNyw0ODAwOCw0ODAwOCwxMSw1NTE3Niw1NTE3NiwxMSwxMjg0MjAsMTI4NDIwLDE0LDMyNzYsMzI3Nyw1LDk5NzksOTk4MCwxNCw0NjIxNiw0NjIxNiwxMSw0OTgwMCw0OTgwMCwxMSw1MzM4NCw1MzM4NCwxMSw3MDcyNiw3MDcyNiw1LDEyMjkxNSwxMjI5MTYsNSwxMjkzMjAsMTI5MzI3LDE0LDI1NTgsMjU1OCw1LDU5MDYsNTkwOCw1LDk3NjIsOTc2MywxNCw0MzM2MCw0MzM4OCw4LDQ1MzIwLDQ1MzIwLDExLDQ3MTEyLDQ3MTEyLDExLDQ4OTA0LDQ4OTA0LDExLDUwNjk2LDUwNjk2LDExLDUyNDg4LDUyNDg4LDExLDU0MjgwLDU0MjgwLDExLDcwMDgyLDcwMDgzLDEsNzEzNTAsNzEzNTAsNyw3MzExMSw3MzExMSw1LDEyNzg5MiwxMjc4OTMsMTQsMTI4NzI2LDEyODcyNywxNCwxMjk0NzMsMTI5NDc0LDE0LDIwMjcsMjAzNSw1LDI5MDEsMjkwMiw1LDM3ODQsMzc4OSw1LDY3NTQsNjc1NCw1LDg0MTgsODQyMCw1LDk4NzcsOTg3NywxNCwxMTA4OCwxMTA4OCwxNCw0NDAwOCw0NDAwOCw1LDQ0ODcyLDQ0ODcyLDExLDQ1NzY4LDQ1NzY4LDExLDQ2NjY0LDQ2NjY0LDExLDQ3NTYwLDQ3NTYwLDExLDQ4NDU2LDQ4NDU2LDExLDQ5MzUyLDQ5MzUyLDExLDUwMjQ4LDUwMjQ4LDExLDUxMTQ0LDUxMTQ0LDExLDUyMDQwLDUyMDQwLDExLDUyOTM2LDUyOTM2LDExLDUzODMyLDUzODMyLDExLDU0NzI4LDU0NzI4LDExLDY5ODExLDY5ODE0LDUsNzA0NTksNzA0NjAsNSw3MTA5Niw3MTA5OSw3LDcxOTk4LDcxOTk4LDUsNzI4NzQsNzI4ODAsNSwxMTkxNDksMTE5MTQ5LDcsMTI3Mzc0LDEyNzM3NCwxNCwxMjgzMzUsMTI4MzM1LDE0LDEyODQ4MiwxMjg0ODIsMTQsMTI4NzY1LDEyODc2NywxNCwxMjkzOTksMTI5NDAwLDE0LDEyOTY4MCwxMjk2ODUsMTQsMTQ3NiwxNDc3LDUsMjM3NywyMzgwLDcsMjc1OSwyNzYwLDUsMzEzNywzMTQwLDcsMzQ1OCwzNDU5LDcsNDE1Myw0MTU0LDUsNjQzMiw2NDM0LDUsNjk3OCw2OTc4LDUsNzY3NSw3Njc5LDUsOTcyMyw5NzI2LDE0LDk4MjMsOTgyMywxNCw5OTE5LDk5MjMsMTQsMTAwMzUsMTAwMzYsMTQsNDI3MzYsNDI3MzcsNSw0MzU5Niw0MzU5Niw1LDQ0MjAwLDQ0MjAwLDExLDQ0NjQ4LDQ0NjQ4LDExLDQ1MDk2LDQ1MDk2LDExLDQ1NTQ0LDQ1NTQ0LDExLDQ1OTkyLDQ1OTkyLDExLDQ2NDQwLDQ2NDQwLDExLDQ2ODg4LDQ2ODg4LDExLDQ3MzM2LDQ3MzM2LDExLDQ3Nzg0LDQ3Nzg0LDExLDQ4MjMyLDQ4MjMyLDExLDQ4NjgwLDQ4NjgwLDExLDQ5MTI4LDQ5MTI4LDExLDQ5NTc2LDQ5NTc2LDExLDUwMDI0LDUwMDI0LDExLDUwNDcyLDUwNDcyLDExLDUwOTIwLDUwOTIwLDExLDUxMzY4LDUxMzY4LDExLDUxODE2LDUxODE2LDExLDUyMjY0LDUyMjY0LDExLDUyNzEyLDUyNzEyLDExLDUzMTYwLDUzMTYwLDExLDUzNjA4LDUzNjA4LDExLDU0MDU2LDU0MDU2LDExLDU0NTA0LDU0NTA0LDExLDU0OTUyLDU0OTUyLDExLDY4MTA4LDY4MTExLDUsNjk5MzMsNjk5NDAsNSw3MDE5Nyw3MDE5Nyw3LDcwNDk4LDcwNDk5LDcsNzA4NDUsNzA4NDUsNSw3MTIyOSw3MTIyOSw1LDcxNzI3LDcxNzM1LDUsNzIxNTQsNzIxNTUsNSw3MjM0NCw3MjM0NSw1LDczMDIzLDczMDI5LDUsOTQwOTUsOTQwOTgsNSwxMjE0MDMsMTIxNDUyLDUsMTI2OTgxLDEyNzE4MiwxNCwxMjc1MzgsMTI3NTQ2LDE0LDEyNzk5MCwxMjc5OTAsMTQsMTI4MzkxLDEyODM5MSwxNCwxMjg0NDUsMTI4NDQ5LDE0LDEyODUwMCwxMjg1MDUsMTQsMTI4NzUyLDEyODc1MiwxNCwxMjkxNjAsMTI5MTY3LDE0LDEyOTM1NiwxMjkzNTYsMTQsMTI5NDMyLDEyOTQ0MiwxNCwxMjk2NDgsMTI5NjUxLDE0LDEyOTc1MSwxMzEwNjksMTQsMTczLDE3Myw0LDE3NTcsMTc1NywxLDIyNzQsMjI3NCwxLDI0OTQsMjQ5NCw1LDI2NDEsMjY0MSw1LDI4NzYsMjg3Niw1LDMwMTQsMzAxNiw3LDMyNjIsMzI2Miw3LDMzOTMsMzM5Niw1LDM1NzAsMzU3MSw3LDM5NjgsMzk3Miw1LDQyMjgsNDIyOCw3LDYwODYsNjA4Niw1LDY2NzksNjY4MCw1LDY5MTIsNjkxNSw1LDcwODAsNzA4MSw1LDczODAsNzM5Miw1LDgyNTIsODI1MiwxNCw5MDk2LDkwOTYsMTQsOTc0OCw5NzQ5LDE0LDk3ODQsOTc4NiwxNCw5ODMzLDk4NTAsMTQsOTg5MCw5ODk0LDE0LDk5MzgsOTkzOCwxNCw5OTk5LDk5OTksMTQsMTAwODUsMTAwODcsMTQsMTIzNDksMTIzNDksMTQsNDMxMzYsNDMxMzcsNyw0MzQ1NCw0MzQ1Niw3LDQzNzU1LDQzNzU1LDcsNDQwODgsNDQwODgsMTEsNDQzMTIsNDQzMTIsMTEsNDQ1MzYsNDQ1MzYsMTEsNDQ3NjAsNDQ3NjAsMTEsNDQ5ODQsNDQ5ODQsMTEsNDUyMDgsNDUyMDgsMTEsNDU0MzIsNDU0MzIsMTEsNDU2NTYsNDU2NTYsMTEsNDU4ODAsNDU4ODAsMTEsNDYxMDQsNDYxMDQsMTEsNDYzMjgsNDYzMjgsMTEsNDY1NTIsNDY1NTIsMTEsNDY3NzYsNDY3NzYsMTEsNDcwMDAsNDcwMDAsMTEsNDcyMjQsNDcyMjQsMTEsNDc0NDgsNDc0NDgsMTEsNDc2NzIsNDc2NzIsMTEsNDc4OTYsNDc4OTYsMTEsNDgxMjAsNDgxMjAsMTEsNDgzNDQsNDgzNDQsMTEsNDg1NjgsNDg1NjgsMTEsNDg3OTIsNDg3OTIsMTEsNDkwMTYsNDkwMTYsMTEsNDkyNDAsNDkyNDAsMTEsNDk0NjQsNDk0NjQsMTEsNDk2ODgsNDk2ODgsMTEsNDk5MTIsNDk5MTIsMTEsNTAxMzYsNTAxMzYsMTEsNTAzNjAsNTAzNjAsMTEsNTA1ODQsNTA1ODQsMTEsNTA4MDgsNTA4MDgsMTEsNTEwMzIsNTEwMzIsMTEsNTEyNTYsNTEyNTYsMTEsNTE0ODAsNTE0ODAsMTEsNTE3MDQsNTE3MDQsMTEsNTE5MjgsNTE5MjgsMTEsNTIxNTIsNTIxNTIsMTEsNTIzNzYsNTIzNzYsMTEsNTI2MDAsNTI2MDAsMTEsNTI4MjQsNTI4MjQsMTEsNTMwNDgsNTMwNDgsMTEsNTMyNzIsNTMyNzIsMTEsNTM0OTYsNTM0OTYsMTEsNTM3MjAsNTM3MjAsMTEsNTM5NDQsNTM5NDQsMTEsNTQxNjgsNTQxNjgsMTEsNTQzOTIsNTQzOTIsMTEsNTQ2MTYsNTQ2MTYsMTEsNTQ4NDAsNTQ4NDAsMTEsNTUwNjQsNTUwNjQsMTEsNjU0MzgsNjU0MzksNSw2OTYzMyw2OTYzMyw1LDY5ODM3LDY5ODM3LDEsNzAwMTgsNzAwMTgsNyw3MDE4OCw3MDE5MCw3LDcwMzY4LDcwMzcwLDcsNzA0NjUsNzA0NjgsNyw3MDcxMiw3MDcxOSw1LDcwODM1LDcwODQwLDUsNzA4NTAsNzA4NTEsNSw3MTEzMiw3MTEzMyw1LDcxMzQwLDcxMzQwLDcsNzE0NTgsNzE0NjEsNSw3MTk4NSw3MTk4OSw3LDcyMDAyLDcyMDAyLDcsNzIxOTMsNzIyMDIsNSw3MjI4MSw3MjI4Myw1LDcyNzY2LDcyNzY2LDcsNzI4ODUsNzI4ODYsNSw3MzEwNCw3MzEwNSw1LDkyOTEyLDkyOTE2LDUsMTEzODI0LDExMzgyNyw0LDExOTE3MywxMTkxNzksNSwxMjE1MDUsMTIxNTE5LDUsMTI1MTM2LDEyNTE0Miw1LDEyNzI3OSwxMjcyNzksMTQsMTI3NDg5LDEyNzQ5MCwxNCwxMjc1NzAsMTI3NzQzLDE0LDEyNzkwMCwxMjc5MDEsMTQsMTI4MjU0LDEyODI1NCwxNCwxMjgzNjksMTI4MzcwLDE0LDEyODQwMCwxMjg0MDAsMTQsMTI4NDI1LDEyODQzMiwxNCwxMjg0NjgsMTI4NDc1LDE0LDEyODQ4OSwxMjg0OTQsMTQsMTI4NzE1LDEyODcyMCwxNCwxMjg3NDUsMTI4NzQ1LDE0LDEyODc1OSwxMjg3NjAsMTQsMTI5MDA0LDEyOTAyMywxNCwxMjkyOTYsMTI5MzA0LDE0LDEyOTM0MCwxMjkzNDIsMTQsMTI5Mzg4LDEyOTM5MiwxNCwxMjk0MDQsMTI5NDA3LDE0LDEyOTQ1NCwxMjk0NTUsMTQsMTI5NDg1LDEyOTQ4NywxNCwxMjk2NTksMTI5NjYzLDE0LDEyOTcxOSwxMjk3MjcsMTQsOTE3NTM2LDkxNzYzMSw1LDEzLDEzLDIsMTE2MCwxMTYxLDUsMTU2NCwxNTY0LDQsMTgwNywxODA3LDEsMjA4NSwyMDg3LDUsMjM2MywyMzYzLDcsMjQwMiwyNDAzLDUsMjUwNywyNTA4LDcsMjYyMiwyNjI0LDcsMjY5MSwyNjkxLDcsMjc4NiwyNzg3LDUsMjg4MSwyODg0LDUsMzAwNiwzMDA2LDUsMzA3MiwzMDcyLDUsMzE3MCwzMTcxLDUsMzI2NywzMjY4LDcsMzMzMCwzMzMxLDcsMzQwNiwzNDA2LDEsMzUzOCwzNTQwLDUsMzY1NSwzNjYyLDUsMzg5NywzODk3LDUsNDAzOCw0MDM4LDUsNDE4NCw0MTg1LDUsNDM1Miw0NDQ3LDgsNjA2OCw2MDY5LDUsNjE1NSw2MTU3LDUsNjQ0OCw2NDQ5LDcsNjc0Miw2NzQyLDUsNjc4Myw2NzgzLDUsNjk2Niw2OTcwLDUsNzA0Miw3MDQyLDcsNzE0Myw3MTQzLDcsNzIxMiw3MjE5LDUsNzQxMiw3NDEyLDUsODIwNiw4MjA3LDQsODI5NCw4MzAzLDQsODU5Niw4NjAxLDE0LDk0MTAsOTQxMCwxNCw5NzQyLDk3NDIsMTQsOTc1Nyw5NzU3LDE0LDk3NzAsOTc3MCwxNCw5Nzk0LDk3OTQsMTQsOTgyOCw5ODI4LDE0LDk4NTUsOTg1NSwxNCw5ODgyLDk4ODIsMTQsOTkwMCw5OTAzLDE0LDk5MjksOTkzMywxNCw5OTYzLDk5NjcsMTQsOTk4Nyw5OTg4LDE0LDEwMDA2LDEwMDA2LDE0LDEwMDYyLDEwMDYyLDE0LDEwMTc1LDEwMTc1LDE0LDExNzQ0LDExNzc1LDUsNDI2MDcsNDI2MDcsNSw0MzA0Myw0MzA0NCw3LDQzMjYzLDQzMjYzLDUsNDM0NDQsNDM0NDUsNyw0MzU2OSw0MzU3MCw1LDQzNjk4LDQzNzAwLDUsNDM3NjYsNDM3NjYsNSw0NDAzMiw0NDAzMiwxMSw0NDE0NCw0NDE0NCwxMSw0NDI1Niw0NDI1NiwxMSw0NDM2OCw0NDM2OCwxMSw0NDQ4MCw0NDQ4MCwxMSw0NDU5Miw0NDU5MiwxMSw0NDcwNCw0NDcwNCwxMSw0NDgxNiw0NDgxNiwxMSw0NDkyOCw0NDkyOCwxMSw0NTA0MCw0NTA0MCwxMSw0NTE1Miw0NTE1MiwxMSw0NTI2NCw0NTI2NCwxMSw0NTM3Niw0NTM3NiwxMSw0NTQ4OCw0NTQ4OCwxMSw0NTYwMCw0NTYwMCwxMSw0NTcxMiw0NTcxMiwxMSw0NTgyNCw0NTgyNCwxMSw0NTkzNiw0NTkzNiwxMSw0NjA0OCw0NjA0OCwxMSw0NjE2MCw0NjE2MCwxMSw0NjI3Miw0NjI3MiwxMSw0NjM4NCw0NjM4NCwxMSw0NjQ5Niw0NjQ5NiwxMSw0NjYwOCw0NjYwOCwxMSw0NjcyMCw0NjcyMCwxMSw0NjgzMiw0NjgzMiwxMSw0Njk0NCw0Njk0NCwxMSw0NzA1Niw0NzA1NiwxMSw0NzE2OCw0NzE2OCwxMSw0NzI4MCw0NzI4MCwxMSw0NzM5Miw0NzM5MiwxMSw0NzUwNCw0NzUwNCwxMSw0NzYxNiw0NzYxNiwxMSw0NzcyOCw0NzcyOCwxMSw0Nzg0MCw0Nzg0MCwxMSw0Nzk1Miw0Nzk1MiwxMSw0ODA2NCw0ODA2NCwxMSw0ODE3Niw0ODE3NiwxMSw0ODI4OCw0ODI4OCwxMSw0ODQwMCw0ODQwMCwxMSw0ODUxMiw0ODUxMiwxMSw0ODYyNCw0ODYyNCwxMSw0ODczNiw0ODczNiwxMSw0ODg0OCw0ODg0OCwxMSw0ODk2MCw0ODk2MCwxMSw0OTA3Miw0OTA3MiwxMSw0OTE4NCw0OTE4NCwxMSw0OTI5Niw0OTI5NiwxMSw0OTQwOCw0OTQwOCwxMSw0OTUyMCw0OTUyMCwxMSw0OTYzMiw0OTYzMiwxMSw0OTc0NCw0OTc0NCwxMSw0OTg1Niw0OTg1NiwxMSw0OTk2OCw0OTk2OCwxMSw1MDA4MCw1MDA4MCwxMSw1MDE5Miw1MDE5MiwxMSw1MDMwNCw1MDMwNCwxMSw1MDQxNiw1MDQxNiwxMSw1MDUyOCw1MDUyOCwxMSw1MDY0MCw1MDY0MCwxMSw1MDc1Miw1MDc1MiwxMSw1MDg2NCw1MDg2NCwxMSw1MDk3Niw1MDk3NiwxMSw1MTA4OCw1MTA4OCwxMSw1MTIwMCw1MTIwMCwxMSw1MTMxMiw1MTMxMiwxMSw1MTQyNCw1MTQyNCwxMSw1MTUzNiw1MTUzNiwxMSw1MTY0OCw1MTY0OCwxMSw1MTc2MCw1MTc2MCwxMSw1MTg3Miw1MTg3MiwxMSw1MTk4NCw1MTk4NCwxMSw1MjA5Niw1MjA5NiwxMSw1MjIwOCw1MjIwOCwxMSw1MjMyMCw1MjMyMCwxMSw1MjQzMiw1MjQzMiwxMSw1MjU0NCw1MjU0NCwxMSw1MjY1Niw1MjY1NiwxMSw1Mjc2OCw1Mjc2OCwxMSw1Mjg4MCw1Mjg4MCwxMSw1Mjk5Miw1Mjk5MiwxMSw1MzEwNCw1MzEwNCwxMSw1MzIxNiw1MzIxNiwxMSw1MzMyOCw1MzMyOCwxMSw1MzQ0MCw1MzQ0MCwxMSw1MzU1Miw1MzU1MiwxMSw1MzY2NCw1MzY2NCwxMSw1Mzc3Niw1Mzc3NiwxMSw1Mzg4OCw1Mzg4OCwxMSw1NDAwMCw1NDAwMCwxMSw1NDExMiw1NDExMiwxMSw1NDIyNCw1NDIyNCwxMSw1NDMzNiw1NDMzNiwxMSw1NDQ0OCw1NDQ0OCwxMSw1NDU2MCw1NDU2MCwxMSw1NDY3Miw1NDY3MiwxMSw1NDc4NCw1NDc4NCwxMSw1NDg5Niw1NDg5NiwxMSw1NTAwOCw1NTAwOCwxMSw1NTEyMCw1NTEyMCwxMSw2NDI4Niw2NDI4Niw1LDY2MjcyLDY2MjcyLDUsNjg5MDAsNjg5MDMsNSw2OTc2Miw2OTc2Miw3LDY5ODE3LDY5ODE4LDUsNjk5MjcsNjk5MzEsNSw3MDAwMyw3MDAwMyw1LDcwMDcwLDcwMDc4LDUsNzAwOTQsNzAwOTQsNyw3MDE5NCw3MDE5NSw3LDcwMjA2LDcwMjA2LDUsNzA0MDAsNzA0MDEsNSw3MDQ2Myw3MDQ2Myw3LDcwNDc1LDcwNDc3LDcsNzA1MTIsNzA1MTYsNSw3MDcyMiw3MDcyNCw1LDcwODMyLDcwODMyLDUsNzA4NDIsNzA4NDIsNSw3MDg0Nyw3MDg0OCw1LDcxMDg4LDcxMDg5LDcsNzExMDIsNzExMDIsNyw3MTIxOSw3MTIyNiw1LDcxMjMxLDcxMjMyLDUsNzEzNDIsNzEzNDMsNyw3MTQ1Myw3MTQ1NSw1LDcxNDYzLDcxNDY3LDUsNzE3MzcsNzE3MzgsNSw3MTk5NSw3MTk5Niw1LDcyMDAwLDcyMDAwLDcsNzIxNDUsNzIxNDcsNyw3MjE2MCw3MjE2MCw1LDcyMjQ5LDcyMjQ5LDcsNzIyNzMsNzIyNzgsNSw3MjMzMCw3MjM0Miw1LDcyNzUyLDcyNzU4LDUsNzI4NTAsNzI4NzEsNSw3Mjg4Miw3Mjg4Myw1LDczMDE4LDczMDE4LDUsNzMwMzEsNzMwMzEsNSw3MzEwOSw3MzEwOSw1LDczNDYxLDczNDYyLDcsOTQwMzEsOTQwMzEsNSw5NDE5Miw5NDE5Myw3LDExOTE0MiwxMTkxNDIsNywxMTkxNTUsMTE5MTYyLDQsMTE5MzYyLDExOTM2NCw1LDEyMTQ3NiwxMjE0NzYsNSwxMjI4ODgsMTIyOTA0LDUsMTIzMTg0LDEyMzE5MCw1LDEyNjk3NiwxMjY5NzksMTQsMTI3MTg0LDEyNzIzMSwxNCwxMjczNDQsMTI3MzQ1LDE0LDEyNzQwNSwxMjc0NjEsMTQsMTI3NTE0LDEyNzUxNCwxNCwxMjc1NjEsMTI3NTY3LDE0LDEyNzc3OCwxMjc3NzksMTQsMTI3ODk2LDEyNzg5NiwxNCwxMjc5ODUsMTI3OTg2LDE0LDEyNzk5NSwxMjc5OTksNSwxMjgzMjYsMTI4MzI4LDE0LDEyODM2MCwxMjgzNjYsMTQsMTI4Mzc4LDEyODM3OCwxNCwxMjgzOTQsMTI4Mzk3LDE0LDEyODQwNSwxMjg0MDYsMTQsMTI4NDIyLDEyODQyMywxNCwxMjg0MzUsMTI4NDQzLDE0LDEyODQ1MywxMjg0NjQsMTQsMTI4NDc5LDEyODQ4MCwxNCwxMjg0ODQsMTI4NDg3LDE0LDEyODQ5NiwxMjg0OTgsMTQsMTI4NjQwLDEyODcwOSwxNCwxMjg3MjMsMTI4NzI0LDE0LDEyODczNiwxMjg3NDEsMTQsMTI4NzQ3LDEyODc0OCwxNCwxMjg3NTUsMTI4NzU1LDE0LDEyODc2MiwxMjg3NjIsMTQsMTI4OTgxLDEyODk5MSwxNCwxMjkwOTYsMTI5MTAzLDE0LDEyOTI5MiwxMjkyOTIsMTQsMTI5MzExLDEyOTMxMSwxNCwxMjkzMjksMTI5MzMwLDE0LDEyOTM0NCwxMjkzNDksMTQsMTI5MzYwLDEyOTM3NCwxNCwxMjkzOTQsMTI5Mzk0LDE0LDEyOTQwMiwxMjk0MDIsMTQsMTI5NDEzLDEyOTQyNSwxNCwxMjk0NDUsMTI5NDUwLDE0LDEyOTQ2NiwxMjk0NzEsMTQsMTI5NDgzLDEyOTQ4MywxNCwxMjk1MTEsMTI5NTM1LDE0LDEyOTY1MywxMjk2NTUsMTQsMTI5NjY3LDEyOTY3MCwxNCwxMjk3MDUsMTI5NzExLDE0LDEyOTczMSwxMjk3NDMsMTQsOTE3NTA1LDkxNzUwNSw0LDkxNzc2MCw5MTc5OTksNSwxMCwxMCwzLDEyNywxNTksNCw3NjgsODc5LDUsMTQ3MSwxNDcxLDUsMTUzNiwxNTQxLDEsMTY0OCwxNjQ4LDUsMTc2NywxNzY4LDUsMTg0MCwxODY2LDUsMjA3MCwyMDczLDUsMjEzNywyMTM5LDUsMjMwNywyMzA3LDcsMjM2NiwyMzY4LDcsMjM4MiwyMzgzLDcsMjQzNCwyNDM1LDcsMjQ5NywyNTAwLDUsMjUxOSwyNTE5LDUsMjU2MywyNTYzLDcsMjYzMSwyNjMyLDUsMjY3NywyNjc3LDUsMjc1MCwyNzUyLDcsMjc2MywyNzY0LDcsMjgxNywyODE3LDUsMjg3OSwyODc5LDUsMjg5MSwyODkyLDcsMjkxNCwyOTE1LDUsMzAwOCwzMDA4LDUsMzAyMSwzMDIxLDUsMzA3NiwzMDc2LDUsMzE0NiwzMTQ5LDUsMzIwMiwzMjAzLDcsMzI2NCwzMjY1LDcsMzI3MSwzMjcyLDcsMzI5OCwzMjk5LDUsMzM5MCwzMzkwLDUsMzQwMiwzNDA0LDcsMzQyNiwzNDI3LDUsMzUzNSwzNTM1LDUsMzU0NCwzNTUwLDcsMzYzNSwzNjM1LDcsMzc2MywzNzYzLDcsMzg5MywzODkzLDUsMzk1MywzOTY2LDUsMzk4MSwzOTkxLDUsNDE0NSw0MTQ1LDcsNDE1Nyw0MTU4LDUsNDIwOSw0MjEyLDUsNDIzNyw0MjM3LDUsNDUyMCw0NjA3LDEwLDU5NzAsNTk3MSw1LDYwNzEsNjA3Nyw1LDYwODksNjA5OSw1LDYyNzcsNjI3OCw1LDY0MzksNjQ0MCw1LDY0NTEsNjQ1Niw3LDY2ODMsNjY4Myw1LDY3NDQsNjc1MCw1LDY3NjUsNjc3MCw3LDY4NDYsNjg0Niw1LDY5NjQsNjk2NCw1LDY5NzIsNjk3Miw1LDcwMTksNzAyNyw1LDcwNzQsNzA3Nyw1LDcwODMsNzA4NSw1LDcxNDYsNzE0OCw3LDcxNTQsNzE1NSw3LDcyMjIsNzIyMyw1LDczOTQsNzQwMCw1LDc0MTYsNzQxNyw1LDgyMDQsODIwNCw1LDgyMzMsODIzMyw0LDgyODgsODI5Miw0LDg0MTMsODQxNiw1LDg0ODIsODQ4MiwxNCw4OTg2LDg5ODcsMTQsOTE5Myw5MjAzLDE0LDk2NTQsOTY1NCwxNCw5NzMzLDk3MzMsMTQsOTc0NSw5NzQ1LDE0LDk3NTIsOTc1MiwxNCw5NzYwLDk3NjAsMTQsOTc2Niw5NzY2LDE0LDk3NzQsOTc3NSwxNCw5NzkyLDk3OTIsMTQsOTgwMCw5ODExLDE0LDk4MjUsOTgyNiwxNCw5ODMxLDk4MzEsMTQsOTg1Miw5ODUzLDE0LDk4NzIsOTg3MywxNCw5ODgwLDk4ODAsMTQsOTg4NSw5ODg3LDE0LDk4OTYsOTg5NywxNCw5OTA2LDk5MTYsMTQsOTkyNiw5OTI3LDE0LDk5MzYsOTkzNiwxNCw5OTQxLDk5NjAsMTQsOTk3NCw5OTc0LDE0LDk5ODIsOTk4NSwxNCw5OTkyLDk5OTcsMTQsMTAwMDIsMTAwMDIsMTQsMTAwMTcsMTAwMTcsMTQsMTAwNTUsMTAwNTUsMTQsMTAwNzEsMTAwNzEsMTQsMTAxNDUsMTAxNDUsMTQsMTEwMTMsMTEwMTUsMTQsMTE1MDMsMTE1MDUsNSwxMjMzNCwxMjMzNSw1LDEyOTUxLDEyOTUxLDE0LDQyNjEyLDQyNjIxLDUsNDMwMTQsNDMwMTQsNSw0MzA0Nyw0MzA0Nyw3LDQzMjA0LDQzMjA1LDUsNDMzMzUsNDMzNDUsNSw0MzM5NSw0MzM5NSw3LDQzNDUwLDQzNDUxLDcsNDM1NjEsNDM1NjYsNSw0MzU3Myw0MzU3NCw1LDQzNjQ0LDQzNjQ0LDUsNDM3MTAsNDM3MTEsNSw0Mzc1OCw0Mzc1OSw3LDQ0MDA1LDQ0MDA1LDUsNDQwMTIsNDQwMTIsNyw0NDA2MCw0NDA2MCwxMSw0NDExNiw0NDExNiwxMSw0NDE3Miw0NDE3MiwxMSw0NDIyOCw0NDIyOCwxMSw0NDI4NCw0NDI4NCwxMSw0NDM0MCw0NDM0MCwxMSw0NDM5Niw0NDM5NiwxMSw0NDQ1Miw0NDQ1MiwxMSw0NDUwOCw0NDUwOCwxMSw0NDU2NCw0NDU2NCwxMSw0NDYyMCw0NDYyMCwxMSw0NDY3Niw0NDY3NiwxMSw0NDczMiw0NDczMiwxMSw0NDc4OCw0NDc4OCwxMSw0NDg0NCw0NDg0NCwxMSw0NDkwMCw0NDkwMCwxMSw0NDk1Niw0NDk1NiwxMSw0NTAxMiw0NTAxMiwxMSw0NTA2OCw0NTA2OCwxMSw0NTEyNCw0NTEyNCwxMSw0NTE4MCw0NTE4MCwxMSw0NTIzNiw0NTIzNiwxMSw0NTI5Miw0NTI5MiwxMSw0NTM0OCw0NTM0OCwxMSw0NTQwNCw0NTQwNCwxMSw0NTQ2MCw0NTQ2MCwxMSw0NTUxNiw0NTUxNiwxMSw0NTU3Miw0NTU3MiwxMSw0NTYyOCw0NTYyOCwxMSw0NTY4NCw0NTY4NCwxMSw0NTc0MCw0NTc0MCwxMSw0NTc5Niw0NTc5NiwxMSw0NTg1Miw0NTg1MiwxMSw0NTkwOCw0NTkwOCwxMSw0NTk2NCw0NTk2NCwxMSw0NjAyMCw0NjAyMCwxMSw0NjA3Niw0NjA3NiwxMSw0NjEzMiw0NjEzMiwxMSw0NjE4OCw0NjE4OCwxMSw0NjI0NCw0NjI0NCwxMSw0NjMwMCw0NjMwMCwxMSw0NjM1Niw0NjM1NiwxMSw0NjQxMiw0NjQxMiwxMSw0NjQ2OCw0NjQ2OCwxMSw0NjUyNCw0NjUyNCwxMSw0NjU4MCw0NjU4MCwxMSw0NjYzNiw0NjYzNiwxMSw0NjY5Miw0NjY5MiwxMSw0Njc0OCw0Njc0OCwxMSw0NjgwNCw0NjgwNCwxMSw0Njg2MCw0Njg2MCwxMSw0NjkxNiw0NjkxNiwxMSw0Njk3Miw0Njk3MiwxMSw0NzAyOCw0NzAyOCwxMSw0NzA4NCw0NzA4NCwxMSw0NzE0MCw0NzE0MCwxMSw0NzE5Niw0NzE5NiwxMSw0NzI1Miw0NzI1MiwxMSw0NzMwOCw0NzMwOCwxMSw0NzM2NCw0NzM2NCwxMSw0NzQyMCw0NzQyMCwxMSw0NzQ3Niw0NzQ3NiwxMSw0NzUzMiw0NzUzMiwxMSw0NzU4OCw0NzU4OCwxMSw0NzY0NCw0NzY0NCwxMSw0NzcwMCw0NzcwMCwxMSw0Nzc1Niw0Nzc1NiwxMSw0NzgxMiw0NzgxMiwxMSw0Nzg2OCw0Nzg2OCwxMSw0NzkyNCw0NzkyNCwxMSw0Nzk4MCw0Nzk4MCwxMSw0ODAzNiw0ODAzNiwxMSw0ODA5Miw0ODA5MiwxMSw0ODE0OCw0ODE0OCwxMSw0ODIwNCw0ODIwNCwxMSw0ODI2MCw0ODI2MCwxMSw0ODMxNiw0ODMxNiwxMSw0ODM3Miw0ODM3MiwxMSw0ODQyOCw0ODQyOCwxMSw0ODQ4NCw0ODQ4NCwxMSw0ODU0MCw0ODU0MCwxMSw0ODU5Niw0ODU5NiwxMSw0ODY1Miw0ODY1MiwxMSw0ODcwOCw0ODcwOCwxMSw0ODc2NCw0ODc2NCwxMSw0ODgyMCw0ODgyMCwxMSw0ODg3Niw0ODg3NiwxMSw0ODkzMiw0ODkzMiwxMSw0ODk4OCw0ODk4OCwxMSw0OTA0NCw0OTA0NCwxMSw0OTEwMCw0OTEwMCwxMSw0OTE1Niw0OTE1NiwxMSw0OTIxMiw0OTIxMiwxMSw0OTI2OCw0OTI2OCwxMSw0OTMyNCw0OTMyNCwxMSw0OTM4MCw0OTM4MCwxMSw0OTQzNiw0OTQzNiwxMSw0OTQ5Miw0OTQ5MiwxMSw0OTU0OCw0OTU0OCwxMSw0OTYwNCw0OTYwNCwxMSw0OTY2MCw0OTY2MCwxMSw0OTcxNiw0OTcxNiwxMSw0OTc3Miw0OTc3MiwxMSw0OTgyOCw0OTgyOCwxMSw0OTg4NCw0OTg4NCwxMSw0OTk0MCw0OTk0MCwxMSw0OTk5Niw0OTk5NiwxMSw1MDA1Miw1MDA1MiwxMSw1MDEwOCw1MDEwOCwxMSw1MDE2NCw1MDE2NCwxMSw1MDIyMCw1MDIyMCwxMSw1MDI3Niw1MDI3NiwxMSw1MDMzMiw1MDMzMiwxMSw1MDM4OCw1MDM4OCwxMSw1MDQ0NCw1MDQ0NCwxMSw1MDUwMCw1MDUwMCwxMSw1MDU1Niw1MDU1NiwxMSw1MDYxMiw1MDYxMiwxMSw1MDY2OCw1MDY2OCwxMSw1MDcyNCw1MDcyNCwxMSw1MDc4MCw1MDc4MCwxMSw1MDgzNiw1MDgzNiwxMSw1MDg5Miw1MDg5MiwxMSw1MDk0OCw1MDk0OCwxMSw1MTAwNCw1MTAwNCwxMSw1MTA2MCw1MTA2MCwxMSw1MTExNiw1MTExNiwxMSw1MTE3Miw1MTE3MiwxMSw1MTIyOCw1MTIyOCwxMSw1MTI4NCw1MTI4NCwxMSw1MTM0MCw1MTM0MCwxMSw1MTM5Niw1MTM5NiwxMSw1MTQ1Miw1MTQ1MiwxMSw1MTUwOCw1MTUwOCwxMSw1MTU2NCw1MTU2NCwxMSw1MTYyMCw1MTYyMCwxMSw1MTY3Niw1MTY3NiwxMSw1MTczMiw1MTczMiwxMSw1MTc4OCw1MTc4OCwxMSw1MTg0NCw1MTg0NCwxMSw1MTkwMCw1MTkwMCwxMSw1MTk1Niw1MTk1NiwxMSw1MjAxMiw1MjAxMiwxMSw1MjA2OCw1MjA2OCwxMSw1MjEyNCw1MjEyNCwxMSw1MjE4MCw1MjE4MCwxMSw1MjIzNiw1MjIzNiwxMSw1MjI5Miw1MjI5MiwxMSw1MjM0OCw1MjM0OCwxMSw1MjQwNCw1MjQwNCwxMSw1MjQ2MCw1MjQ2MCwxMSw1MjUxNiw1MjUxNiwxMSw1MjU3Miw1MjU3MiwxMSw1MjYyOCw1MjYyOCwxMSw1MjY4NCw1MjY4NCwxMSw1Mjc0MCw1Mjc0MCwxMSw1Mjc5Niw1Mjc5NiwxMSw1Mjg1Miw1Mjg1MiwxMSw1MjkwOCw1MjkwOCwxMSw1Mjk2NCw1Mjk2NCwxMSw1MzAyMCw1MzAyMCwxMSw1MzA3Niw1MzA3NiwxMSw1MzEzMiw1MzEzMiwxMSw1MzE4OCw1MzE4OCwxMSw1MzI0NCw1MzI0NCwxMSw1MzMwMCw1MzMwMCwxMSw1MzM1Niw1MzM1NiwxMSw1MzQxMiw1MzQxMiwxMSw1MzQ2OCw1MzQ2OCwxMSw1MzUyNCw1MzUyNCwxMSw1MzU4MCw1MzU4MCwxMSw1MzYzNiw1MzYzNiwxMSw1MzY5Miw1MzY5MiwxMSw1Mzc0OCw1Mzc0OCwxMSw1MzgwNCw1MzgwNCwxMSw1Mzg2MCw1Mzg2MCwxMSw1MzkxNiw1MzkxNiwxMSw1Mzk3Miw1Mzk3MiwxMSw1NDAyOCw1NDAyOCwxMSw1NDA4NCw1NDA4NCwxMSw1NDE0MCw1NDE0MCwxMSw1NDE5Niw1NDE5NiwxMSw1NDI1Miw1NDI1MiwxMSw1NDMwOCw1NDMwOCwxMSw1NDM2NCw1NDM2NCwxMSw1NDQyMCw1NDQyMCwxMSw1NDQ3Niw1NDQ3NiwxMSw1NDUzMiw1NDUzMiwxMSw1NDU4OCw1NDU4OCwxMSw1NDY0NCw1NDY0NCwxMSw1NDcwMCw1NDcwMCwxMSw1NDc1Niw1NDc1NiwxMSw1NDgxMiw1NDgxMiwxMSw1NDg2OCw1NDg2OCwxMSw1NDkyNCw1NDkyNCwxMSw1NDk4MCw1NDk4MCwxMSw1NTAzNiw1NTAzNiwxMSw1NTA5Miw1NTA5MiwxMSw1NTE0OCw1NTE0OCwxMSw1NTIxNiw1NTIzOCw5LDY1MDU2LDY1MDcxLDUsNjU1MjksNjU1MzEsNCw2ODA5Nyw2ODA5OSw1LDY4MTU5LDY4MTU5LDUsNjk0NDYsNjk0NTYsNSw2OTY4OCw2OTcwMiw1LDY5ODA4LDY5ODEwLDcsNjk4MTUsNjk4MTYsNyw2OTgyMSw2OTgyMSwxLDY5ODg4LDY5ODkwLDUsNjk5MzIsNjk5MzIsNyw2OTk1Nyw2OTk1OCw3LDcwMDE2LDcwMDE3LDUsNzAwNjcsNzAwNjksNyw3MDA3OSw3MDA4MCw3LDcwMDg5LDcwMDkyLDUsNzAwOTUsNzAwOTUsNSw3MDE5MSw3MDE5Myw1LDcwMTk2LDcwMTk2LDUsNzAxOTgsNzAxOTksNSw3MDM2Nyw3MDM2Nyw1LDcwMzcxLDcwMzc4LDUsNzA0MDIsNzA0MDMsNyw3MDQ2Miw3MDQ2Miw1LDcwNDY0LDcwNDY0LDUsNzA0NzEsNzA0NzIsNyw3MDQ4Nyw3MDQ4Nyw1LDcwNTAyLDcwNTA4LDUsNzA3MDksNzA3MTEsNyw3MDcyMCw3MDcyMSw3LDcwNzI1LDcwNzI1LDcsNzA3NTAsNzA3NTAsNSw3MDgzMyw3MDgzNCw3LDcwODQxLDcwODQxLDcsNzA4NDMsNzA4NDQsNyw3MDg0Niw3MDg0Niw3LDcwODQ5LDcwODQ5LDcsNzEwODcsNzEwODcsNSw3MTA5MCw3MTA5Myw1LDcxMTAwLDcxMTAxLDUsNzExMDMsNzExMDQsNSw3MTIxNiw3MTIxOCw3LDcxMjI3LDcxMjI4LDcsNzEyMzAsNzEyMzAsNyw3MTMzOSw3MTMzOSw1LDcxMzQxLDcxMzQxLDUsNzEzNDQsNzEzNDksNSw3MTM1MSw3MTM1MSw1LDcxNDU2LDcxNDU3LDcsNzE0NjIsNzE0NjIsNyw3MTcyNCw3MTcyNiw3LDcxNzM2LDcxNzM2LDcsNzE5ODQsNzE5ODQsNSw3MTk5MSw3MTk5Miw3LDcxOTk3LDcxOTk3LDcsNzE5OTksNzE5OTksMSw3MjAwMSw3MjAwMSwxLDcyMDAzLDcyMDAzLDUsNzIxNDgsNzIxNTEsNSw3MjE1Niw3MjE1OSw3LDcyMTY0LDcyMTY0LDcsNzIyNDMsNzIyNDgsNSw3MjI1MCw3MjI1MCwxLDcyMjYzLDcyMjYzLDUsNzIyNzksNzIyODAsNyw3MjMyNCw3MjMyOSwxLDcyMzQzLDcyMzQzLDcsNzI3NTEsNzI3NTEsNyw3Mjc2MCw3Mjc2NSw1LDcyNzY3LDcyNzY3LDUsNzI4NzMsNzI4NzMsNyw3Mjg4MSw3Mjg4MSw3LDcyODg0LDcyODg0LDcsNzMwMDksNzMwMTQsNSw3MzAyMCw3MzAyMSw1LDczMDMwLDczMDMwLDEsNzMwOTgsNzMxMDIsNyw3MzEwNyw3MzEwOCw3LDczMTEwLDczMTEwLDcsNzM0NTksNzM0NjAsNSw3ODg5Niw3ODkwNCw0LDkyOTc2LDkyOTgyLDUsOTQwMzMsOTQwODcsNyw5NDE4MCw5NDE4MCw1LDExMzgyMSwxMTM4MjIsNSwxMTkxNDEsMTE5MTQxLDUsMTE5MTQzLDExOTE0NSw1LDExOTE1MCwxMTkxNTQsNSwxMTkxNjMsMTE5MTcwLDUsMTE5MjEwLDExOTIxMyw1LDEyMTM0NCwxMjEzOTgsNSwxMjE0NjEsMTIxNDYxLDUsMTIxNDk5LDEyMTUwMyw1LDEyMjg4MCwxMjI4ODYsNSwxMjI5MDcsMTIyOTEzLDUsMTIyOTE4LDEyMjkyMiw1LDEyMzYyOCwxMjM2MzEsNSwxMjUyNTIsMTI1MjU4LDUsMTI2OTgwLDEyNjk4MCwxNCwxMjcxODMsMTI3MTgzLDE0LDEyNzI0NSwxMjcyNDcsMTQsMTI3MzQwLDEyNzM0MywxNCwxMjczNTgsMTI3MzU5LDE0LDEyNzM3NywxMjczODYsMTQsMTI3NDYyLDEyNzQ4Nyw2LDEyNzQ5MSwxMjc1MDMsMTQsMTI3NTM1LDEyNzUzNSwxNCwxMjc1NDgsMTI3NTUxLDE0LDEyNzU2OCwxMjc1NjksMTQsMTI3NzQ0LDEyNzc3NywxNCwxMjc3ODAsMTI3ODkxLDE0LDEyNzg5NCwxMjc4OTUsMTQsMTI3ODk3LDEyNzg5OSwxNCwxMjc5MDIsMTI3OTg0LDE0LDEyNzk4NywxMjc5ODksMTQsMTI3OTkxLDEyNzk5NCwxNCwxMjgwMDAsMTI4MjUzLDE0LDEyODI1NSwxMjgzMTcsMTQsMTI4MzI5LDEyODMzNCwxNCwxMjgzMzYsMTI4MzU5LDE0LDEyODM2NywxMjgzNjgsMTQsMTI4MzcxLDEyODM3NywxNCwxMjgzNzksMTI4MzkwLDE0LDEyODM5MiwxMjgzOTMsMTQsMTI4Mzk4LDEyODM5OSwxNCwxMjg0MDEsMTI4NDA0LDE0LDEyODQwNywxMjg0MTksMTQsMTI4NDIxLDEyODQyMSwxNCwxMjg0MjQsMTI4NDI0LDE0LDEyODQzMywxMjg0MzQsMTQsMTI4NDQ0LDEyODQ0NCwxNCwxMjg0NTAsMTI4NDUyLDE0LDEyODQ2NSwxMjg0NjcsMTQsMTI4NDc2LDEyODQ3OCwxNCwxMjg0ODEsMTI4NDgxLDE0LDEyODQ4MywxMjg0ODMsMTQsMTI4NDg4LDEyODQ4OCwxNCwxMjg0OTUsMTI4NDk1LDE0LDEyODQ5OSwxMjg0OTksMTQsMTI4NTA2LDEyODU5MSwxNCwxMjg3MTAsMTI4NzE0LDE0LDEyODcyMSwxMjg3MjIsMTQsMTI4NzI1LDEyODcyNSwxNCwxMjg3MjgsMTI4NzM1LDE0LDEyODc0MiwxMjg3NDQsMTQsMTI4NzQ2LDEyODc0NiwxNCwxMjg3NDksMTI4NzUxLDE0LDEyODc1MywxMjg3NTQsMTQsMTI4NzU2LDEyODc1OCwxNCwxMjg3NjEsMTI4NzYxLDE0LDEyODc2MywxMjg3NjQsMTQsMTI4ODg0LDEyODg5NSwxNCwxMjg5OTIsMTI5MDAzLDE0LDEyOTAzNiwxMjkwMzksMTQsMTI5MTE0LDEyOTExOSwxNCwxMjkxOTgsMTI5Mjc5LDE0LDEyOTI5MywxMjkyOTUsMTQsMTI5MzA1LDEyOTMxMCwxNCwxMjkzMTIsMTI5MzE5LDE0LDEyOTMyOCwxMjkzMjgsMTQsMTI5MzMxLDEyOTMzOCwxNCwxMjkzNDMsMTI5MzQzLDE0LDEyOTM1MSwxMjkzNTUsMTQsMTI5MzU3LDEyOTM1OSwxNCwxMjkzNzUsMTI5Mzg3LDE0LDEyOTM5MywxMjkzOTMsMTQsMTI5Mzk1LDEyOTM5OCwxNCwxMjk0MDEsMTI5NDAxLDE0LDEyOTQwMywxMjk0MDMsMTQsMTI5NDA4LDEyOTQxMiwxNCwxMjk0MjYsMTI5NDMxLDE0LDEyOTQ0MywxMjk0NDQsMTQsMTI5NDUxLDEyOTQ1MywxNCwxMjk0NTYsMTI5NDY1LDE0LDEyOTQ3MiwxMjk0NzIsMTQsMTI5NDc1LDEyOTQ4MiwxNCwxMjk0ODQsMTI5NDg0LDE0LDEyOTQ4OCwxMjk1MTAsMTQsMTI5NTM2LDEyOTY0NywxNCwxMjk2NTIsMTI5NjUyLDE0LDEyOTY1NiwxMjk2NTgsMTQsMTI5NjY0LDEyOTY2NiwxNCwxMjk2NzEsMTI5Njc5LDE0LDEyOTY4NiwxMjk3MDQsMTQsMTI5NzEyLDEyOTcxOCwxNCwxMjk3MjgsMTI5NzMwLDE0LDEyOTc0NCwxMjk3NTAsMTQsOTE3NTA0LDkxNzUwNCw0LDkxNzUwNiw5MTc1MzUsNCw5MTc2MzIsOTE3NzU5LDQsOTE4MDAwLDkyMTU5OSw0LDAsOSw0LDExLDEyLDQsMTQsMzEsNCwxNjksMTY5LDE0LDE3NCwxNzQsMTQsMTE1NSwxMTU5LDUsMTQyNSwxNDY5LDUsMTQ3MywxNDc0LDUsMTQ3OSwxNDc5LDUsMTU1MiwxNTYyLDUsMTYxMSwxNjMxLDUsMTc1MCwxNzU2LDUsMTc1OSwxNzY0LDUsMTc3MCwxNzczLDUsMTgwOSwxODA5LDUsMTk1OCwxOTY4LDUsMjA0NSwyMDQ1LDUsMjA3NSwyMDgzLDUsMjA4OSwyMDkzLDUsMjI1OSwyMjczLDUsMjI3NSwyMzA2LDUsMjM2MiwyMzYyLDUsMjM2NCwyMzY0LDUsMjM2OSwyMzc2LDUsMjM4MSwyMzgxLDUsMjM4NSwyMzkxLDUsMjQzMywyNDMzLDUsMjQ5MiwyNDkyLDUsMjQ5NSwyNDk2LDcsMjUwMywyNTA0LDcsMjUwOSwyNTA5LDUsMjUzMCwyNTMxLDUsMjU2MSwyNTYyLDUsMjYyMCwyNjIwLDUsMjYyNSwyNjI2LDUsMjYzNSwyNjM3LDUsMjY3MiwyNjczLDUsMjY4OSwyNjkwLDUsMjc0OCwyNzQ4LDUsMjc1MywyNzU3LDUsMjc2MSwyNzYxLDcsMjc2NSwyNzY1LDUsMjgxMCwyODE1LDUsMjgxOCwyODE5LDcsMjg3OCwyODc4LDUsMjg4MCwyODgwLDcsMjg4NywyODg4LDcsMjg5MywyODkzLDUsMjkwMywyOTAzLDUsMjk0NiwyOTQ2LDUsMzAwNywzMDA3LDcsMzAwOSwzMDEwLDcsMzAxOCwzMDIwLDcsMzAzMSwzMDMxLDUsMzA3MywzMDc1LDcsMzEzNCwzMTM2LDUsMzE0MiwzMTQ0LDUsMzE1NywzMTU4LDUsMzIwMSwzMjAxLDUsMzI2MCwzMjYwLDUsMzI2MywzMjYzLDUsMzI2NiwzMjY2LDUsMzI3MCwzMjcwLDUsMzI3NCwzMjc1LDcsMzI4NSwzMjg2LDUsMzMyOCwzMzI5LDUsMzM4NywzMzg4LDUsMzM5MSwzMzkyLDcsMzM5OCwzNDAwLDcsMzQwNSwzNDA1LDUsMzQxNSwzNDE1LDUsMzQ1NywzNDU3LDUsMzUzMCwzNTMwLDUsMzUzNiwzNTM3LDcsMzU0MiwzNTQyLDUsMzU1MSwzNTUxLDUsMzYzMywzNjMzLDUsMzYzNiwzNjQyLDUsMzc2MSwzNzYxLDUsMzc2NCwzNzcyLDUsMzg2NCwzODY1LDUsMzg5NSwzODk1LDUsMzkwMiwzOTAzLDcsMzk2NywzOTY3LDcsMzk3NCwzOTc1LDUsMzk5Myw0MDI4LDUsNDE0MSw0MTQ0LDUsNDE0Niw0MTUxLDUsNDE1NSw0MTU2LDcsNDE4Miw0MTgzLDcsNDE5MCw0MTkyLDUsNDIyNiw0MjI2LDUsNDIyOSw0MjMwLDUsNDI1Myw0MjUzLDUsNDQ0OCw0NTE5LDksNDk1Nyw0OTU5LDUsNTkzOCw1OTQwLDUsNjAwMiw2MDAzLDUsNjA3MCw2MDcwLDcsNjA3OCw2MDg1LDcsNjA4Nyw2MDg4LDcsNjEwOSw2MTA5LDUsNjE1OCw2MTU4LDQsNjMxMyw2MzEzLDUsNjQzNSw2NDM4LDcsNjQ0MSw2NDQzLDcsNjQ1MCw2NDUwLDUsNjQ1Nyw2NDU5LDUsNjY4MSw2NjgyLDcsNjc0MSw2NzQxLDcsNjc0Myw2NzQzLDcsNjc1Miw2NzUyLDUsNjc1Nyw2NzY0LDUsNjc3MSw2NzgwLDUsNjgzMiw2ODQ1LDUsNjg0Nyw2ODQ4LDUsNjkxNiw2OTE2LDcsNjk2NSw2OTY1LDUsNjk3MSw2OTcxLDcsNjk3Myw2OTc3LDcsNjk3OSw2OTgwLDcsNzA0MCw3MDQxLDUsNzA3Myw3MDczLDcsNzA3OCw3MDc5LDcsNzA4Miw3MDgyLDcsNzE0Miw3MTQyLDUsNzE0NCw3MTQ1LDUsNzE0OSw3MTQ5LDUsNzE1MSw3MTUzLDUsNzIwNCw3MjExLDcsNzIyMCw3MjIxLDcsNzM3Niw3Mzc4LDUsNzM5Myw3MzkzLDcsNzQwNSw3NDA1LDUsNzQxNSw3NDE1LDcsNzYxNiw3NjczLDUsODIwMyw4MjAzLDQsODIwNSw4MjA1LDEzLDgyMzIsODIzMiw0LDgyMzQsODIzOCw0LDgyNjUsODI2NSwxNCw4MjkzLDgyOTMsNCw4NDAwLDg0MTIsNSw4NDE3LDg0MTcsNSw4NDIxLDg0MzIsNSw4NTA1LDg1MDUsMTQsODYxNyw4NjE4LDE0LDkwMDAsOTAwMCwxNCw5MTY3LDkxNjcsMTQsOTIwOCw5MjEwLDE0LDk2NDIsOTY0MywxNCw5NjY0LDk2NjQsMTQsOTcyOCw5NzMyLDE0LDk3MzUsOTc0MSwxNCw5NzQzLDk3NDQsMTQsOTc0Niw5NzQ2LDE0LDk3NTAsOTc1MSwxNCw5NzUzLDk3NTYsMTQsOTc1OCw5NzU5LDE0LDk3NjEsOTc2MSwxNCw5NzY0LDk3NjUsMTQsOTc2Nyw5NzY5LDE0LDk3NzEsOTc3MywxNCw5Nzc2LDk3ODMsMTQsOTc4Nyw5NzkxLDE0LDk3OTMsOTc5MywxNCw5Nzk1LDk3OTksMTQsOTgxMiw5ODIyLDE0LDk4MjQsOTgyNCwxNCw5ODI3LDk4MjcsMTQsOTgyOSw5ODMwLDE0LDk4MzIsOTgzMiwxNCw5ODUxLDk4NTEsMTQsOTg1NCw5ODU0LDE0LDk4NTYsOTg2MSwxNCw5ODc0LDk4NzYsMTQsOTg3OCw5ODc5LDE0LDk4ODEsOTg4MSwxNCw5ODgzLDk4ODQsMTQsOTg4OCw5ODg5LDE0LDk4OTUsOTg5NSwxNCw5ODk4LDk4OTksMTQsOTkwNCw5OTA1LDE0LDk5MTcsOTkxOCwxNCw5OTI0LDk5MjUsMTQsOTkyOCw5OTI4LDE0LDk5MzQsOTkzNSwxNCw5OTM3LDk5MzcsMTQsOTkzOSw5OTQwLDE0LDk5NjEsOTk2MiwxNCw5OTY4LDk5NzMsMTQsOTk3NSw5OTc4LDE0LDk5ODEsOTk4MSwxNCw5OTg2LDk5ODYsMTQsOTk4OSw5OTg5LDE0LDk5OTgsOTk5OCwxNCwxMDAwMCwxMDAwMSwxNCwxMDAwNCwxMDAwNCwxNCwxMDAxMywxMDAxMywxNCwxMDAyNCwxMDAyNCwxNCwxMDA1MiwxMDA1MiwxNCwxMDA2MCwxMDA2MCwxNCwxMDA2NywxMDA2OSwxNCwxMDA4MywxMDA4NCwxNCwxMDEzMywxMDEzNSwxNCwxMDE2MCwxMDE2MCwxNCwxMDU0OCwxMDU0OSwxNCwxMTAzNSwxMTAzNiwxNCwxMTA5MywxMTA5MywxNCwxMTY0NywxMTY0Nyw1LDEyMzMwLDEyMzMzLDUsMTIzMzYsMTIzMzYsMTQsMTI0NDEsMTI0NDIsNSwxMjk1MywxMjk1MywxNCw0MjYwOCw0MjYxMCw1LDQyNjU0LDQyNjU1LDUsNDMwMTAsNDMwMTAsNSw0MzAxOSw0MzAxOSw1LDQzMDQ1LDQzMDQ2LDUsNDMwNTIsNDMwNTIsNSw0MzE4OCw0MzIwMyw3LDQzMjMyLDQzMjQ5LDUsNDMzMDIsNDMzMDksNSw0MzM0Niw0MzM0Nyw3LDQzMzkyLDQzMzk0LDUsNDM0NDMsNDM0NDMsNSw0MzQ0Niw0MzQ0OSw1LDQzNDUyLDQzNDUzLDUsNDM0OTMsNDM0OTMsNSw0MzU2Nyw0MzU2OCw3LDQzNTcxLDQzNTcyLDcsNDM1ODcsNDM1ODcsNSw0MzU5Nyw0MzU5Nyw3LDQzNjk2LDQzNjk2LDUsNDM3MDMsNDM3MDQsNSw0MzcxMyw0MzcxMyw1LDQzNzU2LDQzNzU3LDUsNDM3NjUsNDM3NjUsNyw0NDAwMyw0NDAwNCw3LDQ0MDA2LDQ0MDA3LDcsNDQwMDksNDQwMTAsNyw0NDAxMyw0NDAxMyw1LDQ0MDMzLDQ0MDU5LDEyLDQ0MDYxLDQ0MDg3LDEyLDQ0MDg5LDQ0MTE1LDEyLDQ0MTE3LDQ0MTQzLDEyLDQ0MTQ1LDQ0MTcxLDEyLDQ0MTczLDQ0MTk5LDEyLDQ0MjAxLDQ0MjI3LDEyLDQ0MjI5LDQ0MjU1LDEyLDQ0MjU3LDQ0MjgzLDEyLDQ0Mjg1LDQ0MzExLDEyLDQ0MzEzLDQ0MzM5LDEyLDQ0MzQxLDQ0MzY3LDEyLDQ0MzY5LDQ0Mzk1LDEyLDQ0Mzk3LDQ0NDIzLDEyLDQ0NDI1LDQ0NDUxLDEyLDQ0NDUzLDQ0NDc5LDEyLDQ0NDgxLDQ0NTA3LDEyLDQ0NTA5LDQ0NTM1LDEyLDQ0NTM3LDQ0NTYzLDEyLDQ0NTY1LDQ0NTkxLDEyLDQ0NTkzLDQ0NjE5LDEyLDQ0NjIxLDQ0NjQ3LDEyLDQ0NjQ5LDQ0Njc1LDEyLDQ0Njc3LDQ0NzAzLDEyLDQ0NzA1LDQ0NzMxLDEyLDQ0NzMzLDQ0NzU5LDEyLDQ0NzYxLDQ0Nzg3LDEyLDQ0Nzg5LDQ0ODE1LDEyLDQ0ODE3LDQ0ODQzLDEyLDQ0ODQ1LDQ0ODcxLDEyLDQ0ODczLDQ0ODk5LDEyLDQ0OTAxLDQ0OTI3LDEyLDQ0OTI5LDQ0OTU1LDEyLDQ0OTU3LDQ0OTgzLDEyLDQ0OTg1LDQ1MDExLDEyLDQ1MDEzLDQ1MDM5LDEyLDQ1MDQxLDQ1MDY3LDEyLDQ1MDY5LDQ1MDk1LDEyLDQ1MDk3LDQ1MTIzLDEyLDQ1MTI1LDQ1MTUxLDEyLDQ1MTUzLDQ1MTc5LDEyLDQ1MTgxLDQ1MjA3LDEyLDQ1MjA5LDQ1MjM1LDEyLDQ1MjM3LDQ1MjYzLDEyLDQ1MjY1LDQ1MjkxLDEyLDQ1MjkzLDQ1MzE5LDEyLDQ1MzIxLDQ1MzQ3LDEyLDQ1MzQ5LDQ1Mzc1LDEyLDQ1Mzc3LDQ1NDAzLDEyLDQ1NDA1LDQ1NDMxLDEyLDQ1NDMzLDQ1NDU5LDEyLDQ1NDYxLDQ1NDg3LDEyLDQ1NDg5LDQ1NTE1LDEyLDQ1NTE3LDQ1NTQzLDEyLDQ1NTQ1LDQ1NTcxLDEyLDQ1NTczLDQ1NTk5LDEyLDQ1NjAxLDQ1NjI3LDEyLDQ1NjI5LDQ1NjU1LDEyLDQ1NjU3LDQ1NjgzLDEyLDQ1Njg1LDQ1NzExLDEyLDQ1NzEzLDQ1NzM5LDEyLDQ1NzQxLDQ1NzY3LDEyLDQ1NzY5LDQ1Nzk1LDEyLDQ1Nzk3LDQ1ODIzLDEyLDQ1ODI1LDQ1ODUxLDEyLDQ1ODUzLDQ1ODc5LDEyLDQ1ODgxLDQ1OTA3LDEyLDQ1OTA5LDQ1OTM1LDEyLDQ1OTM3LDQ1OTYzLDEyLDQ1OTY1LDQ1OTkxLDEyLDQ1OTkzLDQ2MDE5LDEyLDQ2MDIxLDQ2MDQ3LDEyLDQ2MDQ5LDQ2MDc1LDEyLDQ2MDc3LDQ2MTAzLDEyLDQ2MTA1LDQ2MTMxLDEyLDQ2MTMzLDQ2MTU5LDEyLDQ2MTYxLDQ2MTg3LDEyLDQ2MTg5LDQ2MjE1LDEyLDQ2MjE3LDQ2MjQzLDEyLDQ2MjQ1LDQ2MjcxLDEyLDQ2MjczLDQ2Mjk5LDEyLDQ2MzAxLDQ2MzI3LDEyLDQ2MzI5LDQ2MzU1LDEyLDQ2MzU3LDQ2MzgzLDEyLDQ2Mzg1LDQ2NDExLDEyLDQ2NDEzLDQ2NDM5LDEyLDQ2NDQxLDQ2NDY3LDEyLDQ2NDY5LDQ2NDk1LDEyLDQ2NDk3LDQ2NTIzLDEyLDQ2NTI1LDQ2NTUxLDEyLDQ2NTUzLDQ2NTc5LDEyLDQ2NTgxLDQ2NjA3LDEyLDQ2NjA5LDQ2NjM1LDEyLDQ2NjM3LDQ2NjYzLDEyLDQ2NjY1LDQ2NjkxLDEyLDQ2NjkzLDQ2NzE5LDEyLDQ2NzIxLDQ2NzQ3LDEyLDQ2NzQ5LDQ2Nzc1LDEyLDQ2Nzc3LDQ2ODAzLDEyLDQ2ODA1LDQ2ODMxLDEyLDQ2ODMzLDQ2ODU5LDEyLDQ2ODYxLDQ2ODg3LDEyLDQ2ODg5LDQ2OTE1LDEyLDQ2OTE3LDQ2OTQzLDEyLDQ2OTQ1LDQ2OTcxLDEyLDQ2OTczLDQ2OTk5LDEyLDQ3MDAxLDQ3MDI3LDEyLDQ3MDI5LDQ3MDU1LDEyLDQ3MDU3LDQ3MDgzLDEyLDQ3MDg1LDQ3MTExLDEyLDQ3MTEzLDQ3MTM5LDEyLDQ3MTQxLDQ3MTY3LDEyLDQ3MTY5LDQ3MTk1LDEyLDQ3MTk3LDQ3MjIzLDEyLDQ3MjI1LDQ3MjUxLDEyLDQ3MjUzLDQ3Mjc5LDEyLDQ3MjgxLDQ3MzA3LDEyLDQ3MzA5LDQ3MzM1LDEyLDQ3MzM3LDQ3MzYzLDEyLDQ3MzY1LDQ3MzkxLDEyLDQ3MzkzLDQ3NDE5LDEyLDQ3NDIxLDQ3NDQ3LDEyLDQ3NDQ5LDQ3NDc1LDEyLDQ3NDc3LDQ3NTAzLDEyLDQ3NTA1LDQ3NTMxLDEyLDQ3NTMzLDQ3NTU5LDEyLDQ3NTYxLDQ3NTg3LDEyLDQ3NTg5LDQ3NjE1LDEyLDQ3NjE3LDQ3NjQzLDEyLDQ3NjQ1LDQ3NjcxLDEyLDQ3NjczLDQ3Njk5LDEyLDQ3NzAxLDQ3NzI3LDEyLDQ3NzI5LDQ3NzU1LDEyLDQ3NzU3LDQ3NzgzLDEyLDQ3Nzg1LDQ3ODExLDEyLDQ3ODEzLDQ3ODM5LDEyLDQ3ODQxLDQ3ODY3LDEyLDQ3ODY5LDQ3ODk1LDEyLDQ3ODk3LDQ3OTIzLDEyLDQ3OTI1LDQ3OTUxLDEyLDQ3OTUzLDQ3OTc5LDEyLDQ3OTgxLDQ4MDA3LDEyLDQ4MDA5LDQ4MDM1LDEyLDQ4MDM3LDQ4MDYzLDEyLDQ4MDY1LDQ4MDkxLDEyLDQ4MDkzLDQ4MTE5LDEyLDQ4MTIxLDQ4MTQ3LDEyLDQ4MTQ5LDQ4MTc1LDEyLDQ4MTc3LDQ4MjAzLDEyLDQ4MjA1LDQ4MjMxLDEyLDQ4MjMzLDQ4MjU5LDEyLDQ4MjYxLDQ4Mjg3LDEyLDQ4Mjg5LDQ4MzE1LDEyLDQ4MzE3LDQ4MzQzLDEyLDQ4MzQ1LDQ4MzcxLDEyLDQ4MzczLDQ4Mzk5LDEyLDQ4NDAxLDQ4NDI3LDEyLDQ4NDI5LDQ4NDU1LDEyLDQ4NDU3LDQ4NDgzLDEyLDQ4NDg1LDQ4NTExLDEyLDQ4NTEzLDQ4NTM5LDEyLDQ4NTQxLDQ4NTY3LDEyLDQ4NTY5LDQ4NTk1LDEyLDQ4NTk3LDQ4NjIzLDEyLDQ4NjI1LDQ4NjUxLDEyLDQ4NjUzLDQ4Njc5LDEyLDQ4NjgxLDQ4NzA3LDEyLDQ4NzA5LDQ4NzM1LDEyLDQ4NzM3LDQ4NzYzLDEyLDQ4NzY1LDQ4NzkxLDEyLDQ4NzkzLDQ4ODE5LDEyLDQ4ODIxLDQ4ODQ3LDEyLDQ4ODQ5LDQ4ODc1LDEyLDQ4ODc3LDQ4OTAzLDEyLDQ4OTA1LDQ4OTMxLDEyLDQ4OTMzLDQ4OTU5LDEyLDQ4OTYxLDQ4OTg3LDEyLDQ4OTg5LDQ5MDE1LDEyLDQ5MDE3LDQ5MDQzLDEyLDQ5MDQ1LDQ5MDcxLDEyLDQ5MDczLDQ5MDk5LDEyLDQ5MTAxLDQ5MTI3LDEyLDQ5MTI5LDQ5MTU1LDEyLDQ5MTU3LDQ5MTgzLDEyLDQ5MTg1LDQ5MjExLDEyLDQ5MjEzLDQ5MjM5LDEyLDQ5MjQxLDQ5MjY3LDEyLDQ5MjY5LDQ5Mjk1LDEyLDQ5Mjk3LDQ5MzIzLDEyLDQ5MzI1LDQ5MzUxLDEyLDQ5MzUzLDQ5Mzc5LDEyLDQ5MzgxLDQ5NDA3LDEyLDQ5NDA5LDQ5NDM1LDEyLDQ5NDM3LDQ5NDYzLDEyLDQ5NDY1LDQ5NDkxLDEyLDQ5NDkzLDQ5NTE5LDEyLDQ5NTIxLDQ5NTQ3LDEyLDQ5NTQ5LDQ5NTc1LDEyLDQ5NTc3LDQ5NjAzLDEyLDQ5NjA1LDQ5NjMxLDEyLDQ5NjMzLDQ5NjU5LDEyLDQ5NjYxLDQ5Njg3LDEyLDQ5Njg5LDQ5NzE1LDEyLDQ5NzE3LDQ5NzQzLDEyLDQ5NzQ1LDQ5NzcxLDEyLDQ5NzczLDQ5Nzk5LDEyLDQ5ODAxLDQ5ODI3LDEyLDQ5ODI5LDQ5ODU1LDEyLDQ5ODU3LDQ5ODgzLDEyLDQ5ODg1LDQ5OTExLDEyLDQ5OTEzLDQ5OTM5LDEyLDQ5OTQxLDQ5OTY3LDEyLDQ5OTY5LDQ5OTk1LDEyLDQ5OTk3LDUwMDIzLDEyLDUwMDI1LDUwMDUxLDEyLDUwMDUzLDUwMDc5LDEyLDUwMDgxLDUwMTA3LDEyLDUwMTA5LDUwMTM1LDEyLDUwMTM3LDUwMTYzLDEyLDUwMTY1LDUwMTkxLDEyLDUwMTkzLDUwMjE5LDEyLDUwMjIxLDUwMjQ3LDEyLDUwMjQ5LDUwMjc1LDEyLDUwMjc3LDUwMzAzLDEyLDUwMzA1LDUwMzMxLDEyLDUwMzMzLDUwMzU5LDEyLDUwMzYxLDUwMzg3LDEyLDUwMzg5LDUwNDE1LDEyLDUwNDE3LDUwNDQzLDEyLDUwNDQ1LDUwNDcxLDEyLDUwNDczLDUwNDk5LDEyLDUwNTAxLDUwNTI3LDEyLDUwNTI5LDUwNTU1LDEyLDUwNTU3LDUwNTgzLDEyLDUwNTg1LDUwNjExLDEyLDUwNjEzLDUwNjM5LDEyLDUwNjQxLDUwNjY3LDEyLDUwNjY5LDUwNjk1LDEyLDUwNjk3LDUwNzIzLDEyLDUwNzI1LDUwNzUxLDEyLDUwNzUzLDUwNzc5LDEyLDUwNzgxLDUwODA3LDEyLDUwODA5LDUwODM1LDEyLDUwODM3LDUwODYzLDEyLDUwODY1LDUwODkxLDEyLDUwODkzLDUwOTE5LDEyLDUwOTIxLDUwOTQ3LDEyLDUwOTQ5LDUwOTc1LDEyLDUwOTc3LDUxMDAzLDEyLDUxMDA1LDUxMDMxLDEyLDUxMDMzLDUxMDU5LDEyLDUxMDYxLDUxMDg3LDEyLDUxMDg5LDUxMTE1LDEyLDUxMTE3LDUxMTQzLDEyLDUxMTQ1LDUxMTcxLDEyLDUxMTczLDUxMTk5LDEyLDUxMjAxLDUxMjI3LDEyLDUxMjI5LDUxMjU1LDEyLDUxMjU3LDUxMjgzLDEyLDUxMjg1LDUxMzExLDEyLDUxMzEzLDUxMzM5LDEyLDUxMzQxLDUxMzY3LDEyLDUxMzY5LDUxMzk1LDEyLDUxMzk3LDUxNDIzLDEyLDUxNDI1LDUxNDUxLDEyLDUxNDUzLDUxNDc5LDEyLDUxNDgxLDUxNTA3LDEyLDUxNTA5LDUxNTM1LDEyLDUxNTM3LDUxNTYzLDEyLDUxNTY1LDUxNTkxLDEyLDUxNTkzLDUxNjE5LDEyLDUxNjIxLDUxNjQ3LDEyLDUxNjQ5LDUxNjc1LDEyLDUxNjc3LDUxNzAzLDEyLDUxNzA1LDUxNzMxLDEyLDUxNzMzLDUxNzU5LDEyLDUxNzYxLDUxNzg3LDEyLDUxNzg5LDUxODE1LDEyLDUxODE3LDUxODQzLDEyLDUxODQ1LDUxODcxLDEyLDUxODczLDUxODk5LDEyLDUxOTAxLDUxOTI3LDEyLDUxOTI5LDUxOTU1LDEyLDUxOTU3LDUxOTgzLDEyLDUxOTg1LDUyMDExLDEyLDUyMDEzLDUyMDM5LDEyLDUyMDQxLDUyMDY3LDEyLDUyMDY5LDUyMDk1LDEyLDUyMDk3LDUyMTIzLDEyLDUyMTI1LDUyMTUxLDEyLDUyMTUzLDUyMTc5LDEyLDUyMTgxLDUyMjA3LDEyLDUyMjA5LDUyMjM1LDEyLDUyMjM3LDUyMjYzLDEyLDUyMjY1LDUyMjkxLDEyLDUyMjkzLDUyMzE5LDEyLDUyMzIxLDUyMzQ3LDEyLDUyMzQ5LDUyMzc1LDEyLDUyMzc3LDUyNDAzLDEyLDUyNDA1LDUyNDMxLDEyLDUyNDMzLDUyNDU5LDEyLDUyNDYxLDUyNDg3LDEyLDUyNDg5LDUyNTE1LDEyLDUyNTE3LDUyNTQzLDEyLDUyNTQ1LDUyNTcxLDEyLDUyNTczLDUyNTk5LDEyLDUyNjAxLDUyNjI3LDEyLDUyNjI5LDUyNjU1LDEyLDUyNjU3LDUyNjgzLDEyLDUyNjg1LDUyNzExLDEyLDUyNzEzLDUyNzM5LDEyLDUyNzQxLDUyNzY3LDEyLDUyNzY5LDUyNzk1LDEyLDUyNzk3LDUyODIzLDEyLDUyODI1LDUyODUxLDEyLDUyODUzLDUyODc5LDEyLDUyODgxLDUyOTA3LDEyLDUyOTA5LDUyOTM1LDEyLDUyOTM3LDUyOTYzLDEyLDUyOTY1LDUyOTkxLDEyLDUyOTkzLDUzMDE5LDEyLDUzMDIxLDUzMDQ3LDEyLDUzMDQ5LDUzMDc1LDEyLDUzMDc3LDUzMTAzLDEyLDUzMTA1LDUzMTMxLDEyLDUzMTMzLDUzMTU5LDEyLDUzMTYxLDUzMTg3LDEyLDUzMTg5LDUzMjE1LDEyLDUzMjE3LDUzMjQzLDEyLDUzMjQ1LDUzMjcxLDEyLDUzMjczLDUzMjk5LDEyLDUzMzAxLDUzMzI3LDEyLDUzMzI5LDUzMzU1LDEyLDUzMzU3LDUzMzgzLDEyLDUzMzg1LDUzNDExLDEyLDUzNDEzLDUzNDM5LDEyLDUzNDQxLDUzNDY3LDEyLDUzNDY5LDUzNDk1LDEyLDUzNDk3LDUzNTIzLDEyLDUzNTI1LDUzNTUxLDEyLDUzNTUzLDUzNTc5LDEyLDUzNTgxLDUzNjA3LDEyLDUzNjA5LDUzNjM1LDEyLDUzNjM3LDUzNjYzLDEyLDUzNjY1LDUzNjkxLDEyLDUzNjkzLDUzNzE5LDEyLDUzNzIxLDUzNzQ3LDEyLDUzNzQ5LDUzNzc1LDEyLDUzNzc3LDUzODAzLDEyLDUzODA1LDUzODMxLDEyLDUzODMzLDUzODU5LDEyLDUzODYxLDUzODg3LDEyLDUzODg5LDUzOTE1LDEyLDUzOTE3LDUzOTQzLDEyLDUzOTQ1LDUzOTcxLDEyLDUzOTczLDUzOTk5LDEyLDU0MDAxLDU0MDI3LDEyLDU0MDI5LDU0MDU1LDEyLDU0MDU3LDU0MDgzLDEyLDU0MDg1LDU0MTExLDEyLDU0MTEzLDU0MTM5LDEyLDU0MTQxLDU0MTY3LDEyLDU0MTY5LDU0MTk1LDEyLDU0MTk3LDU0MjIzLDEyLDU0MjI1LDU0MjUxLDEyLDU0MjUzLDU0Mjc5LDEyLDU0MjgxLDU0MzA3LDEyLDU0MzA5LDU0MzM1LDEyLDU0MzM3LDU0MzYzLDEyLDU0MzY1LDU0MzkxLDEyLDU0MzkzLDU0NDE5LDEyLDU0NDIxLDU0NDQ3LDEyLDU0NDQ5LDU0NDc1LDEyLDU0NDc3LDU0NTAzLDEyLDU0NTA1LDU0NTMxLDEyLDU0NTMzLDU0NTU5LDEyLDU0NTYxLDU0NTg3LDEyLDU0NTg5LDU0NjE1LDEyLDU0NjE3LDU0NjQzLDEyLDU0NjQ1LDU0NjcxLDEyLDU0NjczLDU0Njk5LDEyLDU0NzAxLDU0NzI3LDEyLDU0NzI5LDU0NzU1LDEyLDU0NzU3LDU0NzgzLDEyLDU0Nzg1LDU0ODExLDEyLDU0ODEzLDU0ODM5LDEyLDU0ODQxLDU0ODY3LDEyLDU0ODY5LDU0ODk1LDEyLDU0ODk3LDU0OTIzLDEyLDU0OTI1LDU0OTUxLDEyLDU0OTUzLDU0OTc5LDEyLDU0OTgxLDU1MDA3LDEyLDU1MDA5LDU1MDM1LDEyLDU1MDM3LDU1MDYzLDEyLDU1MDY1LDU1MDkxLDEyLDU1MDkzLDU1MTE5LDEyLDU1MTIxLDU1MTQ3LDEyLDU1MTQ5LDU1MTc1LDEyLDU1MTc3LDU1MjAzLDEyLDU1MjQzLDU1MjkxLDEwLDY1MDI0LDY1MDM5LDUsNjUyNzksNjUyNzksNCw2NTUyMCw2NTUyOCw0LDY2MDQ1LDY2MDQ1LDUsNjY0MjIsNjY0MjYsNSw2ODEwMSw2ODEwMiw1LDY4MTUyLDY4MTU0LDUsNjgzMjUsNjgzMjYsNSw2OTI5MSw2OTI5Miw1LDY5NjMyLDY5NjMyLDcsNjk2MzQsNjk2MzQsNyw2OTc1OSw2OTc2MSw1XScpO1xyXG59XHJcbi8vI2VuZHJlZ2lvblxyXG4iLCIvKipcclxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIGEgSmF2YVNjcmlwdCBBcnJheSBvciBub3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheShhcnJheSkge1xyXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyYXkpO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgYSBKYXZhU2NyaXB0IFN0cmluZyBvciBub3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcoc3RyKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKTtcclxufVxyXG4vKipcclxuICpcclxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgYG9iamVjdGAgYnV0ICoqbm90KipcclxuICpcdGBudWxsYCwgYW4gYGFycmF5YCwgYSBgcmVnZXhwYCwgbm9yIGEgYGRhdGVgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xyXG4gICAgLy8gVGhlIG1ldGhvZCBjYW4ndCBkbyBhIHR5cGUgY2FzdCBzaW5jZSB0aGVyZSBhcmUgdHlwZSAobGlrZSBzdHJpbmdzKSB3aGljaFxyXG4gICAgLy8gYXJlIHN1YmNsYXNzZXMgb2YgYW55IHB1dCBub3QgcG9zaXR2ZWx5IG1hdGNoZWQgYnkgdGhlIGZ1bmN0aW9uLiBIZW5jZSB0eXBlXHJcbiAgICAvLyBuYXJyb3dpbmcgcmVzdWx0cyBpbiB3cm9uZyByZXN1bHRzLlxyXG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXHJcbiAgICAgICAgJiYgb2JqICE9PSBudWxsXHJcbiAgICAgICAgJiYgIUFycmF5LmlzQXJyYXkob2JqKVxyXG4gICAgICAgICYmICEob2JqIGluc3RhbmNlb2YgUmVnRXhwKVxyXG4gICAgICAgICYmICEob2JqIGluc3RhbmNlb2YgRGF0ZSk7XHJcbn1cclxuLyoqXHJcbiAqIEluICoqY29udHJhc3QqKiB0byBqdXN0IGNoZWNraW5nIGB0eXBlb2ZgIHRoaXMgd2lsbCByZXR1cm4gYGZhbHNlYCBmb3IgYE5hTmAuXHJcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyBhIEphdmFTY3JpcHQgTnVtYmVyIG9yIG5vdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcihvYmopIHtcclxuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicgJiYgIWlzTmFOKG9iaikpO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgYSBKYXZhU2NyaXB0IEJvb2xlYW4gb3Igbm90LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbihvYmopIHtcclxuICAgIHJldHVybiAob2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UpO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xyXG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyk7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyB1bmRlZmluZWQgb3IgbnVsbC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbChvYmopIHtcclxuICAgIHJldHVybiAoaXNVbmRlZmluZWQob2JqKSB8fCBvYmogPT09IG51bGwpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRUeXBlKGNvbmRpdGlvbiwgdHlwZSkge1xyXG4gICAgaWYgKCFjb25kaXRpb24pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodHlwZSA/IGBVbmV4cGVjdGVkIHR5cGUsIGV4cGVjdGVkICcke3R5cGV9J2AgOiAnVW5leHBlY3RlZCB0eXBlJyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFzc2VydHMgdGhhdCB0aGUgYXJndW1lbnQgcGFzc2VkIGluIGlzIG5laXRoZXIgdW5kZWZpbmVkIG5vciBudWxsLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydElzRGVmaW5lZChhcmcpIHtcclxuICAgIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhcmcpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBc3NlcnRpb24gRmFpbGVkOiBhcmd1bWVudCBpcyB1bmRlZmluZWQgb3IgbnVsbCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyZztcclxufVxyXG4vKipcclxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIGEgSmF2YVNjcmlwdCBGdW5jdGlvbiBvciBub3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcclxuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQ29uc3RyYWludHMoYXJncywgY29uc3RyYWludHMpIHtcclxuICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKGFyZ3MubGVuZ3RoLCBjb25zdHJhaW50cy5sZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIHZhbGlkYXRlQ29uc3RyYWludChhcmdzW2ldLCBjb25zdHJhaW50c1tpXSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQ29uc3RyYWludChhcmcsIGNvbnN0cmFpbnQpIHtcclxuICAgIGlmIChpc1N0cmluZyhjb25zdHJhaW50KSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYXJnICE9PSBjb25zdHJhaW50KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYXJndW1lbnQgZG9lcyBub3QgbWF0Y2ggY29uc3RyYWludDogdHlwZW9mICR7Y29uc3RyYWludH1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGNvbnN0cmFpbnQpKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIGNvbnN0cmFpbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgLy8gaWdub3JlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNVbmRlZmluZWRPck51bGwoYXJnKSAmJiBhcmcuY29uc3RydWN0b3IgPT09IGNvbnN0cmFpbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uc3RyYWludC5sZW5ndGggPT09IDEgJiYgY29uc3RyYWludC5jYWxsKHVuZGVmaW5lZCwgYXJnKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYXJndW1lbnQgZG9lcyBub3QgbWF0Y2ggb25lIG9mIHRoZXNlIGNvbnN0cmFpbnRzOiBhcmcgaW5zdGFuY2VvZiBjb25zdHJhaW50LCBhcmcuY29uc3RydWN0b3IgPT09IGNvbnN0cmFpbnQsIG5vciBjb25zdHJhaW50KGFyZykgPT09IHRydWVgKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsUHJvcGVydHlOYW1lcyhvYmopIHtcclxuICAgIGxldCByZXMgPSBbXTtcclxuICAgIGxldCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xyXG4gICAgd2hpbGUgKE9iamVjdC5wcm90b3R5cGUgIT09IHByb3RvKSB7XHJcbiAgICAgICAgcmVzID0gcmVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykpO1xyXG4gICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbE1ldGhvZE5hbWVzKG9iaikge1xyXG4gICAgY29uc3QgbWV0aG9kcyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIGdldEFsbFByb3BlcnR5TmFtZXMob2JqKSkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqW3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIG1ldGhvZHMucHVzaChwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWV0aG9kcztcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJveHlPYmplY3QobWV0aG9kTmFtZXMsIGludm9rZSkge1xyXG4gICAgY29uc3QgY3JlYXRlUHJveHlNZXRob2QgPSAobWV0aG9kKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnZva2UobWV0aG9kLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIGxldCByZXN1bHQgPSB7fTtcclxuICAgIGZvciAoY29uc3QgbWV0aG9kTmFtZSBvZiBtZXRob2ROYW1lcykge1xyXG4gICAgICAgIHJlc3VsdFttZXRob2ROYW1lXSA9IGNyZWF0ZVByb3h5TWV0aG9kKG1ldGhvZE5hbWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogQ29udmVydHMgbnVsbCB0byB1bmRlZmluZWQsIHBhc3NlcyBhbGwgb3RoZXIgdmFsdWVzIHRocm91Z2guXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gd2l0aE51bGxBc1VuZGVmaW5lZCh4KSB7XHJcbiAgICByZXR1cm4geCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHg7XHJcbn1cclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1VpbnQ4KHYpIHtcclxuICAgIGlmICh2IDwgMCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgaWYgKHYgPiAyNTUgLyogTUFYX1VJTlRfOCAqLykge1xyXG4gICAgICAgIHJldHVybiAyNTUgLyogTUFYX1VJTlRfOCAqLztcclxuICAgIH1cclxuICAgIHJldHVybiB2IHwgMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdG9VaW50MzIodikge1xyXG4gICAgaWYgKHYgPCAwKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBpZiAodiA+IDQyOTQ5NjcyOTUgLyogTUFYX1VJTlRfMzIgKi8pIHtcclxuICAgICAgICByZXR1cm4gNDI5NDk2NzI5NSAvKiBNQVhfVUlOVF8zMiAqLztcclxuICAgIH1cclxuICAgIHJldHVybiB2IHwgMDtcclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgaXNXaW5kb3dzIH0gZnJvbSAnLi9wbGF0Zm9ybS5qcyc7XHJcbmltcG9ydCAqIGFzIHBhdGhzIGZyb20gJy4vcGF0aC5qcyc7XHJcbmNvbnN0IF9zY2hlbWVQYXR0ZXJuID0gL15cXHdbXFx3XFxkKy4tXSokLztcclxuY29uc3QgX3NpbmdsZVNsYXNoU3RhcnQgPSAvXlxcLy87XHJcbmNvbnN0IF9kb3VibGVTbGFzaFN0YXJ0ID0gL15cXC9cXC8vO1xyXG5mdW5jdGlvbiBfdmFsaWRhdGVVcmkocmV0LCBfc3RyaWN0KSB7XHJcbiAgICAvLyBzY2hlbWUsIG11c3QgYmUgc2V0XHJcbiAgICBpZiAoIXJldC5zY2hlbWUgJiYgX3N0cmljdCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW1VyaUVycm9yXTogU2NoZW1lIGlzIG1pc3Npbmc6IHtzY2hlbWU6IFwiXCIsIGF1dGhvcml0eTogXCIke3JldC5hdXRob3JpdHl9XCIsIHBhdGg6IFwiJHtyZXQucGF0aH1cIiwgcXVlcnk6IFwiJHtyZXQucXVlcnl9XCIsIGZyYWdtZW50OiBcIiR7cmV0LmZyYWdtZW50fVwifWApO1xyXG4gICAgfVxyXG4gICAgLy8gc2NoZW1lLCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMuMVxyXG4gICAgLy8gQUxQSEEgKiggQUxQSEEgLyBESUdJVCAvIFwiK1wiIC8gXCItXCIgLyBcIi5cIiApXHJcbiAgICBpZiAocmV0LnNjaGVtZSAmJiAhX3NjaGVtZVBhdHRlcm4udGVzdChyZXQuc2NoZW1lKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW1VyaUVycm9yXTogU2NoZW1lIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycy4nKTtcclxuICAgIH1cclxuICAgIC8vIHBhdGgsIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjNcclxuICAgIC8vIElmIGEgVVJJIGNvbnRhaW5zIGFuIGF1dGhvcml0eSBjb21wb25lbnQsIHRoZW4gdGhlIHBhdGggY29tcG9uZW50XHJcbiAgICAvLyBtdXN0IGVpdGhlciBiZSBlbXB0eSBvciBiZWdpbiB3aXRoIGEgc2xhc2ggKFwiL1wiKSBjaGFyYWN0ZXIuICBJZiBhIFVSSVxyXG4gICAgLy8gZG9lcyBub3QgY29udGFpbiBhbiBhdXRob3JpdHkgY29tcG9uZW50LCB0aGVuIHRoZSBwYXRoIGNhbm5vdCBiZWdpblxyXG4gICAgLy8gd2l0aCB0d28gc2xhc2ggY2hhcmFjdGVycyAoXCIvL1wiKS5cclxuICAgIGlmIChyZXQucGF0aCkge1xyXG4gICAgICAgIGlmIChyZXQuYXV0aG9yaXR5KSB7XHJcbiAgICAgICAgICAgIGlmICghX3NpbmdsZVNsYXNoU3RhcnQudGVzdChyZXQucGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1VyaUVycm9yXTogSWYgYSBVUkkgY29udGFpbnMgYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjb21wb25lbnQgbXVzdCBlaXRoZXIgYmUgZW1wdHkgb3IgYmVnaW4gd2l0aCBhIHNsYXNoIChcIi9cIikgY2hhcmFjdGVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChfZG91YmxlU2xhc2hTdGFydC50ZXN0KHJldC5wYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbVXJpRXJyb3JdOiBJZiBhIFVSSSBkb2VzIG5vdCBjb250YWluIGFuIGF1dGhvcml0eSBjb21wb25lbnQsIHRoZW4gdGhlIHBhdGggY2Fubm90IGJlZ2luIHdpdGggdHdvIHNsYXNoIGNoYXJhY3RlcnMgKFwiLy9cIiknKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyBmb3IgYSB3aGlsZSB3ZSBhbGxvd2VkIHVyaXMgKndpdGhvdXQqIHNjaGVtZXMgYW5kIHRoaXMgaXMgdGhlIG1pZ3JhdGlvblxyXG4vLyBmb3IgdGhlbSwgZS5nLiBhbiB1cmkgd2l0aG91dCBzY2hlbWUgYW5kIHdpdGhvdXQgc3RyaWN0LW1vZGUgd2FybnMgYW5kIGZhbGxzXHJcbi8vIGJhY2sgdG8gdGhlIGZpbGUtc2NoZW1lLiB0aGF0IHNob3VsZCBjYXVzZSB0aGUgbGVhc3QgY2FybmFnZSBhbmQgc3RpbGwgYmUgYVxyXG4vLyBjbGVhciB3YXJuaW5nXHJcbmZ1bmN0aW9uIF9zY2hlbWVGaXgoc2NoZW1lLCBfc3RyaWN0KSB7XHJcbiAgICBpZiAoIXNjaGVtZSAmJiAhX3N0cmljdCkge1xyXG4gICAgICAgIHJldHVybiAnZmlsZSc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2NoZW1lO1xyXG59XHJcbi8vIGltcGxlbWVudHMgYSBiaXQgb2YgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi01XHJcbmZ1bmN0aW9uIF9yZWZlcmVuY2VSZXNvbHV0aW9uKHNjaGVtZSwgcGF0aCkge1xyXG4gICAgLy8gdGhlIHNsYXNoLWNoYXJhY3RlciBpcyBvdXIgJ2RlZmF1bHQgYmFzZScgYXMgd2UgZG9uJ3RcclxuICAgIC8vIHN1cHBvcnQgY29uc3RydWN0aW5nIFVSSXMgcmVsYXRpdmUgdG8gb3RoZXIgVVJJcy4gVGhpc1xyXG4gICAgLy8gYWxzbyBtZWFucyB0aGF0IHdlIGFsdGVyIGFuZCBwb3RlbnRpYWxseSBicmVhayBwYXRocy5cclxuICAgIC8vIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMS40XHJcbiAgICBzd2l0Y2ggKHNjaGVtZSkge1xyXG4gICAgICAgIGNhc2UgJ2h0dHBzJzpcclxuICAgICAgICBjYXNlICdodHRwJzpcclxuICAgICAgICBjYXNlICdmaWxlJzpcclxuICAgICAgICAgICAgaWYgKCFwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gX3NsYXNoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhdGhbMF0gIT09IF9zbGFzaCkge1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IF9zbGFzaCArIHBhdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aDtcclxufVxyXG5jb25zdCBfZW1wdHkgPSAnJztcclxuY29uc3QgX3NsYXNoID0gJy8nO1xyXG5jb25zdCBfcmVnZXhwID0gL14oKFteOi8/I10rPyk6KT8oXFwvXFwvKFteLz8jXSopKT8oW14/I10qKShcXD8oW14jXSopKT8oIyguKikpPy87XHJcbi8qKlxyXG4gKiBVbmlmb3JtIFJlc291cmNlIElkZW50aWZpZXIgKFVSSSkgaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4Ni5cclxuICogVGhpcyBjbGFzcyBpcyBhIHNpbXBsZSBwYXJzZXIgd2hpY2ggY3JlYXRlcyB0aGUgYmFzaWMgY29tcG9uZW50IHBhcnRzXHJcbiAqIChodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMykgd2l0aCBtaW5pbWFsIHZhbGlkYXRpb25cclxuICogYW5kIGVuY29kaW5nLlxyXG4gKlxyXG4gKiBgYGB0eHRcclxuICogICAgICAgZm9vOi8vZXhhbXBsZS5jb206ODA0Mi9vdmVyL3RoZXJlP25hbWU9ZmVycmV0I25vc2VcclxuICogICAgICAgXFxfLyAgIFxcX19fX19fX19fX19fX18vXFxfX19fX19fX18vIFxcX19fX19fX19fLyBcXF9fL1xyXG4gKiAgICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgIHwgICAgICAgICAgICB8ICAgICAgICB8XHJcbiAqICAgICBzY2hlbWUgICAgIGF1dGhvcml0eSAgICAgICBwYXRoICAgICAgICBxdWVyeSAgIGZyYWdtZW50XHJcbiAqICAgICAgICB8ICAgX19fX19fX19fX19fX19fX19fX19ffF9fXHJcbiAqICAgICAgIC8gXFwgLyAgICAgICAgICAgICAgICAgICAgICAgIFxcXHJcbiAqICAgICAgIHVybjpleGFtcGxlOmFuaW1hbDpmZXJyZXQ6bm9zZVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBjbGFzcyBVUkkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Ioc2NoZW1lT3JEYXRhLCBhdXRob3JpdHksIHBhdGgsIHF1ZXJ5LCBmcmFnbWVudCwgX3N0cmljdCA9IGZhbHNlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWVPckRhdGEgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NoZW1lID0gc2NoZW1lT3JEYXRhLnNjaGVtZSB8fCBfZW1wdHk7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5ID0gc2NoZW1lT3JEYXRhLmF1dGhvcml0eSB8fCBfZW1wdHk7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IHNjaGVtZU9yRGF0YS5wYXRoIHx8IF9lbXB0eTtcclxuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHNjaGVtZU9yRGF0YS5xdWVyeSB8fCBfZW1wdHk7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSBzY2hlbWVPckRhdGEuZnJhZ21lbnQgfHwgX2VtcHR5O1xyXG4gICAgICAgICAgICAvLyBubyB2YWxpZGF0aW9uIGJlY2F1c2UgaXQncyB0aGlzIFVSSVxyXG4gICAgICAgICAgICAvLyB0aGF0IGNyZWF0ZXMgdXJpIGNvbXBvbmVudHMuXHJcbiAgICAgICAgICAgIC8vIF92YWxpZGF0ZVVyaSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NoZW1lID0gX3NjaGVtZUZpeChzY2hlbWVPckRhdGEsIF9zdHJpY3QpO1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhvcml0eSA9IGF1dGhvcml0eSB8fCBfZW1wdHk7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IF9yZWZlcmVuY2VSZXNvbHV0aW9uKHRoaXMuc2NoZW1lLCBwYXRoIHx8IF9lbXB0eSk7XHJcbiAgICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeSB8fCBfZW1wdHk7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudCB8fCBfZW1wdHk7XHJcbiAgICAgICAgICAgIF92YWxpZGF0ZVVyaSh0aGlzLCBfc3RyaWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaXNVcmkodGhpbmcpIHtcclxuICAgICAgICBpZiAodGhpbmcgaW5zdGFuY2VvZiBVUkkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaW5nLmF1dGhvcml0eSA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgJiYgdHlwZW9mIHRoaW5nLmZyYWdtZW50ID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcucGF0aCA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgJiYgdHlwZW9mIHRoaW5nLnF1ZXJ5ID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcuc2NoZW1lID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcuZnNQYXRoID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGluZy53aXRoID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGluZy50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJztcclxuICAgIH1cclxuICAgIC8vIC0tLS0gZmlsZXN5c3RlbSBwYXRoIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb3JyZXNwb25kaW5nIGZpbGUgc3lzdGVtIHBhdGggb2YgdGhpcyBVUkkuXHJcbiAgICAgKiBXaWxsIGhhbmRsZSBVTkMgcGF0aHMsIG5vcm1hbGl6ZXMgd2luZG93cyBkcml2ZSBsZXR0ZXJzIHRvIGxvd2VyLWNhc2UsIGFuZCB1c2VzIHRoZVxyXG4gICAgICogcGxhdGZvcm0gc3BlY2lmaWMgcGF0aCBzZXBhcmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogKiBXaWxsICpub3QqIHZhbGlkYXRlIHRoZSBwYXRoIGZvciBpbnZhbGlkIGNoYXJhY3RlcnMgYW5kIHNlbWFudGljcy5cclxuICAgICAqICogV2lsbCAqbm90KiBsb29rIGF0IHRoZSBzY2hlbWUgb2YgdGhpcyBVUkkuXHJcbiAgICAgKiAqIFRoZSByZXN1bHQgc2hhbGwgKm5vdCogYmUgdXNlZCBmb3IgZGlzcGxheSBwdXJwb3NlcyBidXQgZm9yIGFjY2Vzc2luZyBhIGZpbGUgb24gZGlzay5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogVGhlICpkaWZmZXJlbmNlKiB0byBgVVJJI3BhdGhgIGlzIHRoZSB1c2Ugb2YgdGhlIHBsYXRmb3JtIHNwZWNpZmljIHNlcGFyYXRvciBhbmQgdGhlIGhhbmRsaW5nXHJcbiAgICAgKiBvZiBVTkMgcGF0aHMuIFNlZSB0aGUgYmVsb3cgc2FtcGxlIG9mIGEgZmlsZS11cmkgd2l0aCBhbiBhdXRob3JpdHkgKFVOQyBwYXRoKS5cclxuICAgICAqXHJcbiAgICAgKiBgYGB0c1xyXG4gICAgICAgIGNvbnN0IHUgPSBVUkkucGFyc2UoJ2ZpbGU6Ly9zZXJ2ZXIvYyQvZm9sZGVyL2ZpbGUudHh0JylcclxuICAgICAgICB1LmF1dGhvcml0eSA9PT0gJ3NlcnZlcidcclxuICAgICAgICB1LnBhdGggPT09ICcvc2hhcmVzL2MkL2ZpbGUudHh0J1xyXG4gICAgICAgIHUuZnNQYXRoID09PSAnXFxcXHNlcnZlclxcYyRcXGZvbGRlclxcZmlsZS50eHQnXHJcbiAgICBgYGBcclxuICAgICAqXHJcbiAgICAgKiBVc2luZyBgVVJJI3BhdGhgIHRvIHJlYWQgYSBmaWxlICh1c2luZyBmcy1hcGlzKSB3b3VsZCBub3QgYmUgZW5vdWdoIGJlY2F1c2UgcGFydHMgb2YgdGhlIHBhdGgsXHJcbiAgICAgKiBuYW1lbHkgdGhlIHNlcnZlciBuYW1lLCB3b3VsZCBiZSBtaXNzaW5nLiBUaGVyZWZvcmUgYFVSSSNmc1BhdGhgIGV4aXN0cyAtIGl0J3Mgc3VnYXIgdG8gZWFzZSB3b3JraW5nXHJcbiAgICAgKiB3aXRoIFVSSXMgdGhhdCByZXByZXNlbnQgZmlsZXMgb24gZGlzayAoYGZpbGVgIHNjaGVtZSkuXHJcbiAgICAgKi9cclxuICAgIGdldCBmc1BhdGgoKSB7XHJcbiAgICAgICAgLy8gaWYgKHRoaXMuc2NoZW1lICE9PSAnZmlsZScpIHtcclxuICAgICAgICAvLyBcdGNvbnNvbGUud2FybihgW1VyaUVycm9yXSBjYWxsaW5nIGZzUGF0aCB3aXRoIHNjaGVtZSAke3RoaXMuc2NoZW1lfWApO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICByZXR1cm4gdXJpVG9Gc1BhdGgodGhpcywgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgLy8gLS0tLSBtb2RpZnkgdG8gbmV3IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIHdpdGgoY2hhbmdlKSB7XHJcbiAgICAgICAgaWYgKCFjaGFuZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB7IHNjaGVtZSwgYXV0aG9yaXR5LCBwYXRoLCBxdWVyeSwgZnJhZ21lbnQgfSA9IGNoYW5nZTtcclxuICAgICAgICBpZiAoc2NoZW1lID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc2NoZW1lID0gdGhpcy5zY2hlbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNjaGVtZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzY2hlbWUgPSBfZW1wdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhdXRob3JpdHkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBhdXRob3JpdHkgPSB0aGlzLmF1dGhvcml0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXV0aG9yaXR5ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGF1dGhvcml0eSA9IF9lbXB0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBwYXRoID0gdGhpcy5wYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXRoID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHBhdGggPSBfZW1wdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChxdWVyeSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5xdWVyeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocXVlcnkgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcXVlcnkgPSBfZW1wdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZnJhZ21lbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgZnJhZ21lbnQgPSBfZW1wdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzY2hlbWUgPT09IHRoaXMuc2NoZW1lXHJcbiAgICAgICAgICAgICYmIGF1dGhvcml0eSA9PT0gdGhpcy5hdXRob3JpdHlcclxuICAgICAgICAgICAgJiYgcGF0aCA9PT0gdGhpcy5wYXRoXHJcbiAgICAgICAgICAgICYmIHF1ZXJ5ID09PSB0aGlzLnF1ZXJ5XHJcbiAgICAgICAgICAgICYmIGZyYWdtZW50ID09PSB0aGlzLmZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVyaShzY2hlbWUsIGF1dGhvcml0eSwgcGF0aCwgcXVlcnksIGZyYWdtZW50KTtcclxuICAgIH1cclxuICAgIC8vIC0tLS0gcGFyc2UgJiB2YWxpZGF0ZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBVUkkgZnJvbSBhIHN0cmluZywgZS5nLiBgaHR0cDovL3d3dy5tc2Z0LmNvbS9zb21lL3BhdGhgLFxyXG4gICAgICogYGZpbGU6Ly8vdXNyL2hvbWVgLCBvciBgc2NoZW1lOndpdGgvcGF0aGAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIEEgc3RyaW5nIHdoaWNoIHJlcHJlc2VudHMgYW4gVVJJIChzZWUgYFVSSSN0b1N0cmluZ2ApLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUsIF9zdHJpY3QgPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gX3JlZ2V4cC5leGVjKHZhbHVlKTtcclxuICAgICAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXJpKF9lbXB0eSwgX2VtcHR5LCBfZW1wdHksIF9lbXB0eSwgX2VtcHR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVcmkobWF0Y2hbMl0gfHwgX2VtcHR5LCBwZXJjZW50RGVjb2RlKG1hdGNoWzRdIHx8IF9lbXB0eSksIHBlcmNlbnREZWNvZGUobWF0Y2hbNV0gfHwgX2VtcHR5KSwgcGVyY2VudERlY29kZShtYXRjaFs3XSB8fCBfZW1wdHkpLCBwZXJjZW50RGVjb2RlKG1hdGNoWzldIHx8IF9lbXB0eSksIF9zdHJpY3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFVSSSBmcm9tIGEgZmlsZSBzeXN0ZW0gcGF0aCwgZS5nLiBgYzpcXG15XFxmaWxlc2AsXHJcbiAgICAgKiBgL3Vzci9ob21lYCwgb3IgYFxcXFxzZXJ2ZXJcXHNoYXJlXFxzb21lXFxwYXRoYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgKmRpZmZlcmVuY2UqIGJldHdlZW4gYFVSSSNwYXJzZWAgYW5kIGBVUkkjZmlsZWAgaXMgdGhhdCB0aGUgbGF0dGVyIHRyZWF0cyB0aGUgYXJndW1lbnRcclxuICAgICAqIGFzIHBhdGgsIG5vdCBhcyBzdHJpbmdpZmllZC11cmkuIEUuZy4gYFVSSS5maWxlKHBhdGgpYCBpcyAqKm5vdCB0aGUgc2FtZSBhcyoqXHJcbiAgICAgKiBgVVJJLnBhcnNlKCdmaWxlOi8vJyArIHBhdGgpYCBiZWNhdXNlIHRoZSBwYXRoIG1pZ2h0IGNvbnRhaW4gY2hhcmFjdGVycyB0aGF0IGFyZVxyXG4gICAgICogaW50ZXJwcmV0ZWQgKCMgYW5kID8pLiBTZWUgdGhlIGZvbGxvd2luZyBzYW1wbGU6XHJcbiAgICAgKiBgYGB0c1xyXG4gICAgY29uc3QgZ29vZCA9IFVSSS5maWxlKCcvY29kaW5nL2MjL3Byb2plY3QxJyk7XHJcbiAgICBnb29kLnNjaGVtZSA9PT0gJ2ZpbGUnO1xyXG4gICAgZ29vZC5wYXRoID09PSAnL2NvZGluZy9jIy9wcm9qZWN0MSc7XHJcbiAgICBnb29kLmZyYWdtZW50ID09PSAnJztcclxuICAgIGNvbnN0IGJhZCA9IFVSSS5wYXJzZSgnZmlsZTovLycgKyAnL2NvZGluZy9jIy9wcm9qZWN0MScpO1xyXG4gICAgYmFkLnNjaGVtZSA9PT0gJ2ZpbGUnO1xyXG4gICAgYmFkLnBhdGggPT09ICcvY29kaW5nL2MnOyAvLyBwYXRoIGlzIG5vdyBicm9rZW5cclxuICAgIGJhZC5mcmFnbWVudCA9PT0gJy9wcm9qZWN0MSc7XHJcbiAgICBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBBIGZpbGUgc3lzdGVtIHBhdGggKHNlZSBgVVJJI2ZzUGF0aGApXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmaWxlKHBhdGgpIHtcclxuICAgICAgICBsZXQgYXV0aG9yaXR5ID0gX2VtcHR5O1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSB0byBmd2Qtc2xhc2hlcyBvbiB3aW5kb3dzLFxyXG4gICAgICAgIC8vIG9uIG90aGVyIHN5c3RlbXMgYndkLXNsYXNoZXMgYXJlIHZhbGlkXHJcbiAgICAgICAgLy8gZmlsZW5hbWUgY2hhcmFjdGVyLCBlZyAvZlxcb28vYmFcXHIudHh0XHJcbiAgICAgICAgaWYgKGlzV2luZG93cykge1xyXG4gICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFxcL2csIF9zbGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoZWNrIGZvciBhdXRob3JpdHkgYXMgdXNlZCBpbiBVTkMgc2hhcmVzXHJcbiAgICAgICAgLy8gb3IgdXNlIHRoZSBwYXRoIGFzIGdpdmVuXHJcbiAgICAgICAgaWYgKHBhdGhbMF0gPT09IF9zbGFzaCAmJiBwYXRoWzFdID09PSBfc2xhc2gpIHtcclxuICAgICAgICAgICAgY29uc3QgaWR4ID0gcGF0aC5pbmRleE9mKF9zbGFzaCwgMik7XHJcbiAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBhdXRob3JpdHkgPSBwYXRoLnN1YnN0cmluZygyKTtcclxuICAgICAgICAgICAgICAgIHBhdGggPSBfc2xhc2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhdXRob3JpdHkgPSBwYXRoLnN1YnN0cmluZygyLCBpZHgpO1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKGlkeCkgfHwgX3NsYXNoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVXJpKCdmaWxlJywgYXV0aG9yaXR5LCBwYXRoLCBfZW1wdHksIF9lbXB0eSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbShjb21wb25lbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVcmkoY29tcG9uZW50cy5zY2hlbWUsIGNvbXBvbmVudHMuYXV0aG9yaXR5LCBjb21wb25lbnRzLnBhdGgsIGNvbXBvbmVudHMucXVlcnksIGNvbXBvbmVudHMuZnJhZ21lbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBKb2luIGEgVVJJIHBhdGggd2l0aCBwYXRoIGZyYWdtZW50cyBhbmQgbm9ybWFsaXplcyB0aGUgcmVzdWx0aW5nIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVyaSBUaGUgaW5wdXQgVVJJLlxyXG4gICAgICogQHBhcmFtIHBhdGhGcmFnbWVudCBUaGUgcGF0aCBmcmFnbWVudCB0byBhZGQgdG8gdGhlIFVSSSBwYXRoLlxyXG4gICAgICogQHJldHVybnMgVGhlIHJlc3VsdGluZyBVUkkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBqb2luUGF0aCh1cmksIC4uLnBhdGhGcmFnbWVudCkge1xyXG4gICAgICAgIGlmICghdXJpLnBhdGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbVXJpRXJyb3JdOiBjYW5ub3QgY2FsbCBqb2luUGF0aHMgb24gVVJJIHdpdGhvdXQgcGF0aGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmV3UGF0aDtcclxuICAgICAgICBpZiAoaXNXaW5kb3dzICYmIHVyaS5zY2hlbWUgPT09ICdmaWxlJykge1xyXG4gICAgICAgICAgICBuZXdQYXRoID0gVVJJLmZpbGUocGF0aHMud2luMzIuam9pbih1cmlUb0ZzUGF0aCh1cmksIHRydWUpLCAuLi5wYXRoRnJhZ21lbnQpKS5wYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmV3UGF0aCA9IHBhdGhzLnBvc2l4LmpvaW4odXJpLnBhdGgsIC4uLnBhdGhGcmFnbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1cmkud2l0aCh7IHBhdGg6IG5ld1BhdGggfSk7XHJcbiAgICB9XHJcbiAgICAvLyAtLS0tIHByaW50aW5nL2V4dGVybmFsaXplIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciB0aGlzIFVSSS4gSXQncyBndWFyYW50ZWVkIHRoYXQgY2FsbGluZ1xyXG4gICAgICogYFVSSS5wYXJzZWAgd2l0aCB0aGUgcmVzdWx0IG9mIHRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhbiBVUkkgd2hpY2ggaXMgZXF1YWxcclxuICAgICAqIHRvIHRoaXMgVVJJLlxyXG4gICAgICpcclxuICAgICAqICogVGhlIHJlc3VsdCBzaGFsbCAqbm90KiBiZSB1c2VkIGZvciBkaXNwbGF5IHB1cnBvc2VzIGJ1dCBmb3IgZXh0ZXJuYWxpemF0aW9uIG9yIHRyYW5zcG9ydC5cclxuICAgICAqICogVGhlIHJlc3VsdCB3aWxsIGJlIGVuY29kZWQgdXNpbmcgdGhlIHBlcmNlbnRhZ2UgZW5jb2RpbmcgYW5kIGVuY29kaW5nIGhhcHBlbnMgbW9zdGx5XHJcbiAgICAgKiBpZ25vcmUgdGhlIHNjaGVtZS1zcGVjaWZpYyBlbmNvZGluZyBydWxlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2tpcEVuY29kaW5nIERvIG5vdCBlbmNvZGUgdGhlIHJlc3VsdCwgZGVmYXVsdCBpcyBgZmFsc2VgXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKHNraXBFbmNvZGluZyA9IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIF9hc0Zvcm1hdHRlZCh0aGlzLCBza2lwRW5jb2RpbmcpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHJldml2ZShkYXRhKSB7XHJcbiAgICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVVJJKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVyaShkYXRhKTtcclxuICAgICAgICAgICAgcmVzdWx0Ll9mb3JtYXR0ZWQgPSBkYXRhLmV4dGVybmFsO1xyXG4gICAgICAgICAgICByZXN1bHQuX2ZzUGF0aCA9IGRhdGEuX3NlcCA9PT0gX3BhdGhTZXBNYXJrZXIgPyBkYXRhLmZzUGF0aCA6IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IF9wYXRoU2VwTWFya2VyID0gaXNXaW5kb3dzID8gMSA6IHVuZGVmaW5lZDtcclxuLy8gVGhpcyBjbGFzcyBleGlzdHMgc28gdGhhdCBVUkkgaXMgY29tcGF0aWJpbGUgd2l0aCB2c2NvZGUuVXJpIChBUEkpLlxyXG5jbGFzcyBVcmkgZXh0ZW5kcyBVUkkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLl9mb3JtYXR0ZWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2ZzUGF0aCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXQgZnNQYXRoKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZnNQYXRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZzUGF0aCA9IHVyaVRvRnNQYXRoKHRoaXMsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZzUGF0aDtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKHNraXBFbmNvZGluZyA9IGZhbHNlKSB7XHJcbiAgICAgICAgaWYgKCFza2lwRW5jb2RpbmcpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9mb3JtYXR0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Zvcm1hdHRlZCA9IF9hc0Zvcm1hdHRlZCh0aGlzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdHRlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNhY2hlIHRoYXRcclxuICAgICAgICAgICAgcmV0dXJuIF9hc0Zvcm1hdHRlZCh0aGlzLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0ge1xyXG4gICAgICAgICAgICAkbWlkOiAxXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBjYWNoZWQgc3RhdGVcclxuICAgICAgICBpZiAodGhpcy5fZnNQYXRoKSB7XHJcbiAgICAgICAgICAgIHJlcy5mc1BhdGggPSB0aGlzLl9mc1BhdGg7XHJcbiAgICAgICAgICAgIHJlcy5fc2VwID0gX3BhdGhTZXBNYXJrZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9mb3JtYXR0ZWQpIHtcclxuICAgICAgICAgICAgcmVzLmV4dGVybmFsID0gdGhpcy5fZm9ybWF0dGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1cmkgY29tcG9uZW50c1xyXG4gICAgICAgIGlmICh0aGlzLnBhdGgpIHtcclxuICAgICAgICAgICAgcmVzLnBhdGggPSB0aGlzLnBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNjaGVtZSkge1xyXG4gICAgICAgICAgICByZXMuc2NoZW1lID0gdGhpcy5zY2hlbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmF1dGhvcml0eSkge1xyXG4gICAgICAgICAgICByZXMuYXV0aG9yaXR5ID0gdGhpcy5hdXRob3JpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHJlcy5xdWVyeSA9IHRoaXMucXVlcnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIHJlcy5mcmFnbWVudCA9IHRoaXMuZnJhZ21lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbn1cclxuLy8gcmVzZXJ2ZWQgY2hhcmFjdGVyczogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0yLjJcclxuY29uc3QgZW5jb2RlVGFibGUgPSB7XHJcbiAgICBbNTggLyogQ29sb24gKi9dOiAnJTNBJyxcclxuICAgIFs0NyAvKiBTbGFzaCAqL106ICclMkYnLFxyXG4gICAgWzYzIC8qIFF1ZXN0aW9uTWFyayAqL106ICclM0YnLFxyXG4gICAgWzM1IC8qIEhhc2ggKi9dOiAnJTIzJyxcclxuICAgIFs5MSAvKiBPcGVuU3F1YXJlQnJhY2tldCAqL106ICclNUInLFxyXG4gICAgWzkzIC8qIENsb3NlU3F1YXJlQnJhY2tldCAqL106ICclNUQnLFxyXG4gICAgWzY0IC8qIEF0U2lnbiAqL106ICclNDAnLFxyXG4gICAgWzMzIC8qIEV4Y2xhbWF0aW9uTWFyayAqL106ICclMjEnLFxyXG4gICAgWzM2IC8qIERvbGxhclNpZ24gKi9dOiAnJTI0JyxcclxuICAgIFszOCAvKiBBbXBlcnNhbmQgKi9dOiAnJTI2JyxcclxuICAgIFszOSAvKiBTaW5nbGVRdW90ZSAqL106ICclMjcnLFxyXG4gICAgWzQwIC8qIE9wZW5QYXJlbiAqL106ICclMjgnLFxyXG4gICAgWzQxIC8qIENsb3NlUGFyZW4gKi9dOiAnJTI5JyxcclxuICAgIFs0MiAvKiBBc3RlcmlzayAqL106ICclMkEnLFxyXG4gICAgWzQzIC8qIFBsdXMgKi9dOiAnJTJCJyxcclxuICAgIFs0NCAvKiBDb21tYSAqL106ICclMkMnLFxyXG4gICAgWzU5IC8qIFNlbWljb2xvbiAqL106ICclM0InLFxyXG4gICAgWzYxIC8qIEVxdWFscyAqL106ICclM0QnLFxyXG4gICAgWzMyIC8qIFNwYWNlICovXTogJyUyMCcsXHJcbn07XHJcbmZ1bmN0aW9uIGVuY29kZVVSSUNvbXBvbmVudEZhc3QodXJpQ29tcG9uZW50LCBhbGxvd1NsYXNoKSB7XHJcbiAgICBsZXQgcmVzID0gdW5kZWZpbmVkO1xyXG4gICAgbGV0IG5hdGl2ZUVuY29kZVBvcyA9IC0xO1xyXG4gICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgdXJpQ29tcG9uZW50Lmxlbmd0aDsgcG9zKyspIHtcclxuICAgICAgICBjb25zdCBjb2RlID0gdXJpQ29tcG9uZW50LmNoYXJDb2RlQXQocG9zKTtcclxuICAgICAgICAvLyB1bnJlc2VydmVkIGNoYXJhY3RlcnM6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMi4zXHJcbiAgICAgICAgaWYgKChjb2RlID49IDk3IC8qIGEgKi8gJiYgY29kZSA8PSAxMjIgLyogeiAqLylcclxuICAgICAgICAgICAgfHwgKGNvZGUgPj0gNjUgLyogQSAqLyAmJiBjb2RlIDw9IDkwIC8qIFogKi8pXHJcbiAgICAgICAgICAgIHx8IChjb2RlID49IDQ4IC8qIERpZ2l0MCAqLyAmJiBjb2RlIDw9IDU3IC8qIERpZ2l0OSAqLylcclxuICAgICAgICAgICAgfHwgY29kZSA9PT0gNDUgLyogRGFzaCAqL1xyXG4gICAgICAgICAgICB8fCBjb2RlID09PSA0NiAvKiBQZXJpb2QgKi9cclxuICAgICAgICAgICAgfHwgY29kZSA9PT0gOTUgLyogVW5kZXJsaW5lICovXHJcbiAgICAgICAgICAgIHx8IGNvZGUgPT09IDEyNiAvKiBUaWxkZSAqL1xyXG4gICAgICAgICAgICB8fCAoYWxsb3dTbGFzaCAmJiBjb2RlID09PSA0NyAvKiBTbGFzaCAqLykpIHtcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIGRlbGF5aW5nIG5hdGl2ZSBlbmNvZGVcclxuICAgICAgICAgICAgaWYgKG5hdGl2ZUVuY29kZVBvcyAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJlcyArPSBlbmNvZGVVUklDb21wb25lbnQodXJpQ29tcG9uZW50LnN1YnN0cmluZyhuYXRpdmVFbmNvZGVQb3MsIHBvcykpO1xyXG4gICAgICAgICAgICAgICAgbmF0aXZlRW5jb2RlUG9zID0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2Ugd3JpdGUgaW50byBhIG5ldyBzdHJpbmcgKGJ5IGRlZmF1bHQgd2UgdHJ5IHRvIHJldHVybiB0aGUgcGFyYW0pXHJcbiAgICAgICAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzICs9IHVyaUNvbXBvbmVudC5jaGFyQXQocG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZW5jb2RpbmcgbmVlZGVkLCB3ZSBuZWVkIHRvIGFsbG9jYXRlIGEgbmV3IHN0cmluZ1xyXG4gICAgICAgICAgICBpZiAocmVzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlcyA9IHVyaUNvbXBvbmVudC5zdWJzdHIoMCwgcG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjaGVjayB3aXRoIGRlZmF1bHQgdGFibGUgZmlyc3RcclxuICAgICAgICAgICAgY29uc3QgZXNjYXBlZCA9IGVuY29kZVRhYmxlW2NvZGVdO1xyXG4gICAgICAgICAgICBpZiAoZXNjYXBlZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBhcmUgZGVsYXlpbmcgbmF0aXZlIGVuY29kZVxyXG4gICAgICAgICAgICAgICAgaWYgKG5hdGl2ZUVuY29kZVBvcyAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHVyaUNvbXBvbmVudC5zdWJzdHJpbmcobmF0aXZlRW5jb2RlUG9zLCBwb3MpKTtcclxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVFbmNvZGVQb3MgPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBlc2NhcGVkIHZhcmlhbnQgdG8gcmVzdWx0XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gZXNjYXBlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuYXRpdmVFbmNvZGVQb3MgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1c2UgbmF0aXZlIGVuY29kZSBvbmx5IHdoZW4gbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBuYXRpdmVFbmNvZGVQb3MgPSBwb3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobmF0aXZlRW5jb2RlUG9zICE9PSAtMSkge1xyXG4gICAgICAgIHJlcyArPSBlbmNvZGVVUklDb21wb25lbnQodXJpQ29tcG9uZW50LnN1YnN0cmluZyhuYXRpdmVFbmNvZGVQb3MpKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXMgIT09IHVuZGVmaW5lZCA/IHJlcyA6IHVyaUNvbXBvbmVudDtcclxufVxyXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRNaW5pbWFsKHBhdGgpIHtcclxuICAgIGxldCByZXMgPSB1bmRlZmluZWQ7XHJcbiAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBwYXRoLmxlbmd0aDsgcG9zKyspIHtcclxuICAgICAgICBjb25zdCBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KHBvcyk7XHJcbiAgICAgICAgaWYgKGNvZGUgPT09IDM1IC8qIEhhc2ggKi8gfHwgY29kZSA9PT0gNjMgLyogUXVlc3Rpb25NYXJrICovKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzID0gcGF0aC5zdWJzdHIoMCwgcG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXMgKz0gZW5jb2RlVGFibGVbY29kZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlcyArPSBwYXRoW3Bvc107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzICE9PSB1bmRlZmluZWQgPyByZXMgOiBwYXRoO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlIGBmc1BhdGhgIGZvciB0aGUgZ2l2ZW4gdXJpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXJpVG9Gc1BhdGgodXJpLCBrZWVwRHJpdmVMZXR0ZXJDYXNpbmcpIHtcclxuICAgIGxldCB2YWx1ZTtcclxuICAgIGlmICh1cmkuYXV0aG9yaXR5ICYmIHVyaS5wYXRoLmxlbmd0aCA+IDEgJiYgdXJpLnNjaGVtZSA9PT0gJ2ZpbGUnKSB7XHJcbiAgICAgICAgLy8gdW5jIHBhdGg6IGZpbGU6Ly9zaGFyZXMvYyQvZmFyL2Jvb1xyXG4gICAgICAgIHZhbHVlID0gYC8vJHt1cmkuYXV0aG9yaXR5fSR7dXJpLnBhdGh9YDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHVyaS5wYXRoLmNoYXJDb2RlQXQoMCkgPT09IDQ3IC8qIFNsYXNoICovXHJcbiAgICAgICAgJiYgKHVyaS5wYXRoLmNoYXJDb2RlQXQoMSkgPj0gNjUgLyogQSAqLyAmJiB1cmkucGF0aC5jaGFyQ29kZUF0KDEpIDw9IDkwIC8qIFogKi8gfHwgdXJpLnBhdGguY2hhckNvZGVBdCgxKSA+PSA5NyAvKiBhICovICYmIHVyaS5wYXRoLmNoYXJDb2RlQXQoMSkgPD0gMTIyIC8qIHogKi8pXHJcbiAgICAgICAgJiYgdXJpLnBhdGguY2hhckNvZGVBdCgyKSA9PT0gNTggLyogQ29sb24gKi8pIHtcclxuICAgICAgICBpZiAoIWtlZXBEcml2ZUxldHRlckNhc2luZykge1xyXG4gICAgICAgICAgICAvLyB3aW5kb3dzIGRyaXZlIGxldHRlcjogZmlsZTovLy9jOi9mYXIvYm9vXHJcbiAgICAgICAgICAgIHZhbHVlID0gdXJpLnBhdGhbMV0udG9Mb3dlckNhc2UoKSArIHVyaS5wYXRoLnN1YnN0cigyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdXJpLnBhdGguc3Vic3RyKDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIG90aGVyIHBhdGhcclxuICAgICAgICB2YWx1ZSA9IHVyaS5wYXRoO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzV2luZG93cykge1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFwvL2csICdcXFxcJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSB0aGUgZXh0ZXJuYWwgdmVyc2lvbiBvZiBhIHVyaVxyXG4gKi9cclxuZnVuY3Rpb24gX2FzRm9ybWF0dGVkKHVyaSwgc2tpcEVuY29kaW5nKSB7XHJcbiAgICBjb25zdCBlbmNvZGVyID0gIXNraXBFbmNvZGluZ1xyXG4gICAgICAgID8gZW5jb2RlVVJJQ29tcG9uZW50RmFzdFxyXG4gICAgICAgIDogZW5jb2RlVVJJQ29tcG9uZW50TWluaW1hbDtcclxuICAgIGxldCByZXMgPSAnJztcclxuICAgIGxldCB7IHNjaGVtZSwgYXV0aG9yaXR5LCBwYXRoLCBxdWVyeSwgZnJhZ21lbnQgfSA9IHVyaTtcclxuICAgIGlmIChzY2hlbWUpIHtcclxuICAgICAgICByZXMgKz0gc2NoZW1lO1xyXG4gICAgICAgIHJlcyArPSAnOic7XHJcbiAgICB9XHJcbiAgICBpZiAoYXV0aG9yaXR5IHx8IHNjaGVtZSA9PT0gJ2ZpbGUnKSB7XHJcbiAgICAgICAgcmVzICs9IF9zbGFzaDtcclxuICAgICAgICByZXMgKz0gX3NsYXNoO1xyXG4gICAgfVxyXG4gICAgaWYgKGF1dGhvcml0eSkge1xyXG4gICAgICAgIGxldCBpZHggPSBhdXRob3JpdHkuaW5kZXhPZignQCcpO1xyXG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIDx1c2VyPkA8YXV0aD5cclxuICAgICAgICAgICAgY29uc3QgdXNlcmluZm8gPSBhdXRob3JpdHkuc3Vic3RyKDAsIGlkeCk7XHJcbiAgICAgICAgICAgIGF1dGhvcml0eSA9IGF1dGhvcml0eS5zdWJzdHIoaWR4ICsgMSk7XHJcbiAgICAgICAgICAgIGlkeCA9IHVzZXJpbmZvLmluZGV4T2YoJzonKTtcclxuICAgICAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJlcyArPSBlbmNvZGVyKHVzZXJpbmZvLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyA8dXNlcj46PHBhc3M+QDxhdXRoPlxyXG4gICAgICAgICAgICAgICAgcmVzICs9IGVuY29kZXIodXNlcmluZm8uc3Vic3RyKDAsIGlkeCksIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHJlcyArPSAnOic7XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gZW5jb2Rlcih1c2VyaW5mby5zdWJzdHIoaWR4ICsgMSksIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXMgKz0gJ0AnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhdXRob3JpdHkgPSBhdXRob3JpdHkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZHggPSBhdXRob3JpdHkuaW5kZXhPZignOicpO1xyXG4gICAgICAgIGlmIChpZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJlcyArPSBlbmNvZGVyKGF1dGhvcml0eSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gPGF1dGg+Ojxwb3J0PlxyXG4gICAgICAgICAgICByZXMgKz0gZW5jb2RlcihhdXRob3JpdHkuc3Vic3RyKDAsIGlkeCksIGZhbHNlKTtcclxuICAgICAgICAgICAgcmVzICs9IGF1dGhvcml0eS5zdWJzdHIoaWR4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocGF0aCkge1xyXG4gICAgICAgIC8vIGxvd2VyLWNhc2Ugd2luZG93cyBkcml2ZSBsZXR0ZXJzIGluIC9DOi9mZmYgb3IgQzovZmZmXHJcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID49IDMgJiYgcGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKiBTbGFzaCAqLyAmJiBwYXRoLmNoYXJDb2RlQXQoMikgPT09IDU4IC8qIENvbG9uICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMSk7XHJcbiAgICAgICAgICAgIGlmIChjb2RlID49IDY1IC8qIEEgKi8gJiYgY29kZSA8PSA5MCAvKiBaICovKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gYC8ke1N0cmluZy5mcm9tQ2hhckNvZGUoY29kZSArIDMyKX06JHtwYXRoLnN1YnN0cigzKX1gOyAvLyBcIi9jOlwiLmxlbmd0aCA9PT0gM1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhdGgubGVuZ3RoID49IDIgJiYgcGF0aC5jaGFyQ29kZUF0KDEpID09PSA1OCAvKiBDb2xvbiAqLykge1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgICAgICBpZiAoY29kZSA+PSA2NSAvKiBBICovICYmIGNvZGUgPD0gOTAgLyogWiAqLykge1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IGAke1N0cmluZy5mcm9tQ2hhckNvZGUoY29kZSArIDMyKX06JHtwYXRoLnN1YnN0cigyKX1gOyAvLyBcIi9jOlwiLmxlbmd0aCA9PT0gM1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGVuY29kZSB0aGUgcmVzdCBvZiB0aGUgcGF0aFxyXG4gICAgICAgIHJlcyArPSBlbmNvZGVyKHBhdGgsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKHF1ZXJ5KSB7XHJcbiAgICAgICAgcmVzICs9ICc/JztcclxuICAgICAgICByZXMgKz0gZW5jb2RlcihxdWVyeSwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKGZyYWdtZW50KSB7XHJcbiAgICAgICAgcmVzICs9ICcjJztcclxuICAgICAgICByZXMgKz0gIXNraXBFbmNvZGluZyA/IGVuY29kZVVSSUNvbXBvbmVudEZhc3QoZnJhZ21lbnQsIGZhbHNlKSA6IGZyYWdtZW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG4vLyAtLS0gZGVjb2RlXHJcbmZ1bmN0aW9uIGRlY29kZVVSSUNvbXBvbmVudEdyYWNlZnVsKHN0cikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cik7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgMykgKyBkZWNvZGVVUklDb21wb25lbnRHcmFjZWZ1bChzdHIuc3Vic3RyKDMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IF9yRW5jb2RlZEFzSGV4ID0gLyglWzAtOUEtWmEtel1bMC05QS1aYS16XSkrL2c7XHJcbmZ1bmN0aW9uIHBlcmNlbnREZWNvZGUoc3RyKSB7XHJcbiAgICBpZiAoIXN0ci5tYXRjaChfckVuY29kZWRBc0hleCkpIHtcclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKF9yRW5jb2RlZEFzSGV4LCAobWF0Y2gpID0+IGRlY29kZVVSSUNvbXBvbmVudEdyYWNlZnVsKG1hdGNoKSk7XHJcbn1cclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IHRyYW5zZm9ybUVycm9yRm9yU2VyaWFsaXphdGlvbiB9IGZyb20gJy4uL2Vycm9ycy5qcyc7XHJcbmltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICcuLi9saWZlY3ljbGUuanMnO1xyXG5pbXBvcnQgeyBpc1dlYiB9IGZyb20gJy4uL3BsYXRmb3JtLmpzJztcclxuaW1wb3J0ICogYXMgdHlwZXMgZnJvbSAnLi4vdHlwZXMuanMnO1xyXG5jb25zdCBJTklUSUFMSVpFID0gJyRpbml0aWFsaXplJztcclxubGV0IHdlYldvcmtlcldhcm5pbmdMb2dnZWQgPSBmYWxzZTtcclxuZXhwb3J0IGZ1bmN0aW9uIGxvZ09uY2VXZWJXb3JrZXJXYXJuaW5nKGVycikge1xyXG4gICAgaWYgKCFpc1dlYikge1xyXG4gICAgICAgIC8vIHJ1bm5pbmcgdGVzdHNcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIXdlYldvcmtlcldhcm5pbmdMb2dnZWQpIHtcclxuICAgICAgICB3ZWJXb3JrZXJXYXJuaW5nTG9nZ2VkID0gdHJ1ZTtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBjcmVhdGUgd2ViIHdvcmtlcihzKS4gRmFsbGluZyBiYWNrIHRvIGxvYWRpbmcgd2ViIHdvcmtlciBjb2RlIGluIG1haW4gdGhyZWFkLCB3aGljaCBtaWdodCBjYXVzZSBVSSBmcmVlemVzLiBQbGVhc2Ugc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvbW9uYWNvLWVkaXRvciNmYXEnKTtcclxuICAgIH1cclxuICAgIGNvbnNvbGUud2FybihlcnIubWVzc2FnZSk7XHJcbn1cclxuY2xhc3MgU2ltcGxlV29ya2VyUHJvdG9jb2wge1xyXG4gICAgY29uc3RydWN0b3IoaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuX3dvcmtlcklkID0gLTE7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlciA9IGhhbmRsZXI7XHJcbiAgICAgICAgdGhpcy5fbGFzdFNlbnRSZXEgPSAwO1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZXBsaWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIH1cclxuICAgIHNldFdvcmtlcklkKHdvcmtlcklkKSB7XHJcbiAgICAgICAgdGhpcy5fd29ya2VySWQgPSB3b3JrZXJJZDtcclxuICAgIH1cclxuICAgIHNlbmRNZXNzYWdlKG1ldGhvZCwgYXJncykge1xyXG4gICAgICAgIGxldCByZXEgPSBTdHJpbmcoKyt0aGlzLl9sYXN0U2VudFJlcSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1JlcGxpZXNbcmVxXSA9IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXHJcbiAgICAgICAgICAgICAgICByZWplY3Q6IHJlamVjdFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9zZW5kKHtcclxuICAgICAgICAgICAgICAgIHZzV29ya2VyOiB0aGlzLl93b3JrZXJJZCxcclxuICAgICAgICAgICAgICAgIHJlcTogcmVxLFxyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXHJcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCFtZXNzYWdlIHx8ICFtZXNzYWdlLnZzV29ya2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtlcklkICE9PSAtMSAmJiBtZXNzYWdlLnZzV29ya2VyICE9PSB0aGlzLl93b3JrZXJJZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2hhbmRsZU1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlTWVzc2FnZShtc2cpIHtcclxuICAgICAgICBpZiAobXNnLnNlcSkge1xyXG4gICAgICAgICAgICBsZXQgcmVwbHlNZXNzYWdlID0gbXNnO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BlbmRpbmdSZXBsaWVzW3JlcGx5TWVzc2FnZS5zZXFdKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0dvdCByZXBseSB0byB1bmtub3duIHNlcScpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCByZXBseSA9IHRoaXMuX3BlbmRpbmdSZXBsaWVzW3JlcGx5TWVzc2FnZS5zZXFdO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcGVuZGluZ1JlcGxpZXNbcmVwbHlNZXNzYWdlLnNlcV07XHJcbiAgICAgICAgICAgIGlmIChyZXBseU1lc3NhZ2UuZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZXJyID0gcmVwbHlNZXNzYWdlLmVycjtcclxuICAgICAgICAgICAgICAgIGlmIChyZXBseU1lc3NhZ2UuZXJyLiRpc0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyLm5hbWUgPSByZXBseU1lc3NhZ2UuZXJyLm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSByZXBseU1lc3NhZ2UuZXJyLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyLnN0YWNrID0gcmVwbHlNZXNzYWdlLmVyci5zdGFjaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlcGx5LnJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlcGx5LnJlc29sdmUocmVwbHlNZXNzYWdlLnJlcyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlcXVlc3RNZXNzYWdlID0gbXNnO1xyXG4gICAgICAgIGxldCByZXEgPSByZXF1ZXN0TWVzc2FnZS5yZXE7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuX2hhbmRsZXIuaGFuZGxlTWVzc2FnZShyZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHJlcXVlc3RNZXNzYWdlLmFyZ3MpO1xyXG4gICAgICAgIHJlc3VsdC50aGVuKChyKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbmQoe1xyXG4gICAgICAgICAgICAgICAgdnNXb3JrZXI6IHRoaXMuX3dvcmtlcklkLFxyXG4gICAgICAgICAgICAgICAgc2VxOiByZXEsXHJcbiAgICAgICAgICAgICAgICByZXM6IHIsXHJcbiAgICAgICAgICAgICAgICBlcnI6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5kZXRhaWwgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gTG9hZGluZyBlcnJvcnMgaGF2ZSBhIGRldGFpbCBwcm9wZXJ0eSB0aGF0IHBvaW50cyB0byB0aGUgYWN0dWFsIGVycm9yXHJcbiAgICAgICAgICAgICAgICBlLmRldGFpbCA9IHRyYW5zZm9ybUVycm9yRm9yU2VyaWFsaXphdGlvbihlLmRldGFpbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2VuZCh7XHJcbiAgICAgICAgICAgICAgICB2c1dvcmtlcjogdGhpcy5fd29ya2VySWQsXHJcbiAgICAgICAgICAgICAgICBzZXE6IHJlcSxcclxuICAgICAgICAgICAgICAgIHJlczogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgZXJyOiB0cmFuc2Zvcm1FcnJvckZvclNlcmlhbGl6YXRpb24oZSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfc2VuZChtc2cpIHtcclxuICAgICAgICBsZXQgdHJhbnNmZXIgPSBbXTtcclxuICAgICAgICBpZiAobXNnLnJlcSkge1xyXG4gICAgICAgICAgICBjb25zdCBtID0gbXNnO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG0uYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG0uYXJnc1tpXSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmZXIucHVzaChtLmFyZ3NbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBtID0gbXNnO1xyXG4gICAgICAgICAgICBpZiAobS5yZXMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNmZXIucHVzaChtLnJlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faGFuZGxlci5zZW5kTWVzc2FnZShtc2csIHRyYW5zZmVyKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWFpbiB0aHJlYWQgc2lkZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNpbXBsZVdvcmtlckNsaWVudCBleHRlbmRzIERpc3Bvc2FibGUge1xyXG4gICAgY29uc3RydWN0b3Iod29ya2VyRmFjdG9yeSwgbW9kdWxlSWQsIGhvc3QpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIGxldCBsYXp5UHJveHlSZWplY3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3dvcmtlciA9IHRoaXMuX3JlZ2lzdGVyKHdvcmtlckZhY3RvcnkuY3JlYXRlKCd2cy9iYXNlL2NvbW1vbi93b3JrZXIvc2ltcGxlV29ya2VyJywgKG1zZykgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm90b2NvbC5oYW5kbGVNZXNzYWdlKG1zZyk7XHJcbiAgICAgICAgfSwgKGVycikgPT4ge1xyXG4gICAgICAgICAgICAvLyBpbiBGaXJlZm94LCB3ZWIgd29ya2VycyBmYWlsIGxhemlseSA6KFxyXG4gICAgICAgICAgICAvLyB3ZSB3aWxsIHJlamVjdCB0aGUgcHJveHlcclxuICAgICAgICAgICAgaWYgKGxhenlQcm94eVJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgbGF6eVByb3h5UmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5fcHJvdG9jb2wgPSBuZXcgU2ltcGxlV29ya2VyUHJvdG9jb2woe1xyXG4gICAgICAgICAgICBzZW5kTWVzc2FnZTogKG1zZywgdHJhbnNmZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtlci5wb3N0TWVzc2FnZShtc2csIHRyYW5zZmVyKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGFuZGxlTWVzc2FnZTogKG1ldGhvZCwgYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBob3N0W21ldGhvZF0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdNaXNzaW5nIG1ldGhvZCAnICsgbWV0aG9kICsgJyBvbiBtYWluIHRocmVhZCBob3N0LicpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShob3N0W21ldGhvZF0uYXBwbHkoaG9zdCwgYXJncykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9wcm90b2NvbC5zZXRXb3JrZXJJZCh0aGlzLl93b3JrZXIuZ2V0SWQoKSk7XHJcbiAgICAgICAgLy8gR2F0aGVyIGxvYWRlciBjb25maWd1cmF0aW9uXHJcbiAgICAgICAgbGV0IGxvYWRlckNvbmZpZ3VyYXRpb24gPSBudWxsO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZi5yZXF1aXJlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygc2VsZi5yZXF1aXJlLmdldENvbmZpZyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgTW9uYWNvIEFNRCBMb2FkZXJcclxuICAgICAgICAgICAgbG9hZGVyQ29uZmlndXJhdGlvbiA9IHNlbGYucmVxdWlyZS5nZXRDb25maWcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNlbGYucmVxdWlyZWpzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGNvbmZpZ3VyYXRpb24gZnJvbSByZXF1aXJlanNcclxuICAgICAgICAgICAgbG9hZGVyQ29uZmlndXJhdGlvbiA9IHNlbGYucmVxdWlyZWpzLnMuY29udGV4dHMuXy5jb25maWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhvc3RNZXRob2RzID0gdHlwZXMuZ2V0QWxsTWV0aG9kTmFtZXMoaG9zdCk7XHJcbiAgICAgICAgLy8gU2VuZCBpbml0aWFsaXplIG1lc3NhZ2VcclxuICAgICAgICB0aGlzLl9vbk1vZHVsZUxvYWRlZCA9IHRoaXMuX3Byb3RvY29sLnNlbmRNZXNzYWdlKElOSVRJQUxJWkUsIFtcclxuICAgICAgICAgICAgdGhpcy5fd29ya2VyLmdldElkKCksXHJcbiAgICAgICAgICAgIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobG9hZGVyQ29uZmlndXJhdGlvbikpLFxyXG4gICAgICAgICAgICBtb2R1bGVJZCxcclxuICAgICAgICAgICAgaG9zdE1ldGhvZHMsXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgLy8gQ3JlYXRlIHByb3h5IHRvIGxvYWRlZCBjb2RlXHJcbiAgICAgICAgY29uc3QgcHJveHlNZXRob2RSZXF1ZXN0ID0gKG1ldGhvZCwgYXJncykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdChtZXRob2QsIGFyZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fbGF6eVByb3h5ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBsYXp5UHJveHlSZWplY3QgPSByZWplY3Q7XHJcbiAgICAgICAgICAgIHRoaXMuX29uTW9kdWxlTG9hZGVkLnRoZW4oKGF2YWlsYWJsZU1ldGhvZHMpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodHlwZXMuY3JlYXRlUHJveHlPYmplY3QoYXZhaWxhYmxlTWV0aG9kcywgcHJveHlNZXRob2RSZXF1ZXN0KSk7XHJcbiAgICAgICAgICAgIH0sIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkVycm9yKCdXb3JrZXIgZmFpbGVkIHRvIGxvYWQgJyArIG1vZHVsZUlkLCBlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRQcm94eU9iamVjdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGF6eVByb3h5O1xyXG4gICAgfVxyXG4gICAgX3JlcXVlc3QobWV0aG9kLCBhcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fb25Nb2R1bGVMb2FkZWQudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm90b2NvbC5zZW5kTWVzc2FnZShtZXRob2QsIGFyZ3MpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgfSwgcmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9vbkVycm9yKG1lc3NhZ2UsIGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcclxuICAgICAgICBjb25zb2xlLmluZm8oZXJyb3IpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBXb3JrZXIgc2lkZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNpbXBsZVdvcmtlclNlcnZlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwb3N0TWVzc2FnZSwgcmVxdWVzdEhhbmRsZXJGYWN0b3J5KSB7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdEhhbmRsZXJGYWN0b3J5ID0gcmVxdWVzdEhhbmRsZXJGYWN0b3J5O1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9wcm90b2NvbCA9IG5ldyBTaW1wbGVXb3JrZXJQcm90b2NvbCh7XHJcbiAgICAgICAgICAgIHNlbmRNZXNzYWdlOiAobXNnLCB0cmFuc2ZlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UobXNnLCB0cmFuc2Zlcik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhhbmRsZU1lc3NhZ2U6IChtZXRob2QsIGFyZ3MpID0+IHRoaXMuX2hhbmRsZU1lc3NhZ2UobWV0aG9kLCBhcmdzKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb25tZXNzYWdlKG1zZykge1xyXG4gICAgICAgIHRoaXMuX3Byb3RvY29sLmhhbmRsZU1lc3NhZ2UobXNnKTtcclxuICAgIH1cclxuICAgIF9oYW5kbGVNZXNzYWdlKG1ldGhvZCwgYXJncykge1xyXG4gICAgICAgIGlmIChtZXRob2QgPT09IElOSVRJQUxJWkUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZShhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0SGFuZGxlciB8fCB0eXBlb2YgdGhpcy5fcmVxdWVzdEhhbmRsZXJbbWV0aG9kXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdNaXNzaW5nIHJlcXVlc3RIYW5kbGVyIG9yIG1ldGhvZDogJyArIG1ldGhvZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3JlcXVlc3RIYW5kbGVyW21ldGhvZF0uYXBwbHkodGhpcy5fcmVxdWVzdEhhbmRsZXIsIGFyZ3MpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGluaXRpYWxpemUod29ya2VySWQsIGxvYWRlckNvbmZpZywgbW9kdWxlSWQsIGhvc3RNZXRob2RzKSB7XHJcbiAgICAgICAgdGhpcy5fcHJvdG9jb2wuc2V0V29ya2VySWQod29ya2VySWQpO1xyXG4gICAgICAgIGNvbnN0IHByb3h5TWV0aG9kUmVxdWVzdCA9IChtZXRob2QsIGFyZ3MpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3RvY29sLnNlbmRNZXNzYWdlKG1ldGhvZCwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBob3N0UHJveHkgPSB0eXBlcy5jcmVhdGVQcm94eU9iamVjdChob3N0TWV0aG9kcywgcHJveHlNZXRob2RSZXF1ZXN0KTtcclxuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdEhhbmRsZXJGYWN0b3J5KSB7XHJcbiAgICAgICAgICAgIC8vIHN0YXRpYyByZXF1ZXN0IGhhbmRsZXJcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdEhhbmRsZXIgPSB0aGlzLl9yZXF1ZXN0SGFuZGxlckZhY3RvcnkoaG9zdFByb3h5KTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0eXBlcy5nZXRBbGxNZXRob2ROYW1lcyh0aGlzLl9yZXF1ZXN0SGFuZGxlcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobG9hZGVyQ29uZmlnKSB7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSAnYmFzZVVybCcsIGhhbmRsaW5nIGl0IGlzIGJleW9uZCBzY29wZSBmb3Igbm93XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbG9hZGVyQ29uZmlnLmJhc2VVcmwgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbG9hZGVyQ29uZmlnWydiYXNlVXJsJ107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2FkZXJDb25maWcucGF0aHMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxvYWRlckNvbmZpZy5wYXRocy52cyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbG9hZGVyQ29uZmlnLnBhdGhzWyd2cyddO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgaW4gYSB3ZWIgd29ya2VyLCBlbmFibGUgY2F0Y2hpbmcgZXJyb3JzXHJcbiAgICAgICAgICAgIGxvYWRlckNvbmZpZy5jYXRjaEVycm9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2VsZi5yZXF1aXJlLmNvbmZpZyhsb2FkZXJDb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBVc2UgdGhlIGdsb2JhbCByZXF1aXJlIHRvIGJlIHN1cmUgdG8gZ2V0IHRoZSBnbG9iYWwgY29uZmlnXHJcbiAgICAgICAgICAgIHNlbGYucmVxdWlyZShbbW9kdWxlSWRdLCAobW9kdWxlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlciA9IG1vZHVsZS5jcmVhdGUoaG9zdFByb3h5KTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcmVxdWVzdEhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBObyBSZXF1ZXN0SGFuZGxlciFgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0eXBlcy5nZXRBbGxNZXRob2ROYW1lcyh0aGlzLl9yZXF1ZXN0SGFuZGxlcikpO1xyXG4gICAgICAgICAgICB9LCByZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYWxsZWQgb24gdGhlIHdvcmtlciBzaWRlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHBvc3RNZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gbmV3IFNpbXBsZVdvcmtlclNlcnZlcihwb3N0TWVzc2FnZSwgbnVsbCk7XHJcbn1cclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IHRvVWludDggfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi91aW50LmpzJztcclxuLyoqXHJcbiAqIEEgZmFzdCBjaGFyYWN0ZXIgY2xhc3NpZmllciB0aGF0IHVzZXMgYSBjb21wYWN0IGFycmF5IGZvciBBU0NJSSB2YWx1ZXMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2hhcmFjdGVyQ2xhc3NpZmllciB7XHJcbiAgICBjb25zdHJ1Y3RvcihfZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgbGV0IGRlZmF1bHRWYWx1ZSA9IHRvVWludDgoX2RlZmF1bHRWYWx1ZSk7XHJcbiAgICAgICAgdGhpcy5fZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2FzY2lpTWFwID0gQ2hhcmFjdGVyQ2xhc3NpZmllci5fY3JlYXRlQXNjaWlNYXAoZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2NyZWF0ZUFzY2lpTWFwKGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGxldCBhc2NpaU1hcCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xyXG4gICAgICAgICAgICBhc2NpaU1hcFtpXSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFzY2lpTWFwO1xyXG4gICAgfVxyXG4gICAgc2V0KGNoYXJDb2RlLCBfdmFsdWUpIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSB0b1VpbnQ4KF92YWx1ZSk7XHJcbiAgICAgICAgaWYgKGNoYXJDb2RlID49IDAgJiYgY2hhckNvZGUgPCAyNTYpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXNjaWlNYXBbY2hhckNvZGVdID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXAuc2V0KGNoYXJDb2RlLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0KGNoYXJDb2RlKSB7XHJcbiAgICAgICAgaWYgKGNoYXJDb2RlID49IDAgJiYgY2hhckNvZGUgPCAyNTYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FzY2lpTWFwW2NoYXJDb2RlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fbWFwLmdldChjaGFyQ29kZSkgfHwgdGhpcy5fZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIENoYXJhY3RlclNldCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9hY3R1YWwgPSBuZXcgQ2hhcmFjdGVyQ2xhc3NpZmllcigwIC8qIEZhbHNlICovKTtcclxuICAgIH1cclxuICAgIGFkZChjaGFyQ29kZSkge1xyXG4gICAgICAgIHRoaXMuX2FjdHVhbC5zZXQoY2hhckNvZGUsIDEgLyogVHJ1ZSAqLyk7XHJcbiAgICB9XHJcbiAgICBoYXMoY2hhckNvZGUpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX2FjdHVhbC5nZXQoY2hhckNvZGUpID09PSAxIC8qIFRydWUgKi8pO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vKipcclxuICogQSBwb3NpdGlvbiBpbiB0aGUgZWRpdG9yLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBvc2l0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGxpbmVOdW1iZXIsIGNvbHVtbikge1xyXG4gICAgICAgIHRoaXMubGluZU51bWJlciA9IGxpbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBwb3NpdGlvbiBmcm9tIHRoaXMgcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5ld0xpbmVOdW1iZXIgbmV3IGxpbmUgbnVtYmVyXHJcbiAgICAgKiBAcGFyYW0gbmV3Q29sdW1uIG5ldyBjb2x1bW5cclxuICAgICAqL1xyXG4gICAgd2l0aChuZXdMaW5lTnVtYmVyID0gdGhpcy5saW5lTnVtYmVyLCBuZXdDb2x1bW4gPSB0aGlzLmNvbHVtbikge1xyXG4gICAgICAgIGlmIChuZXdMaW5lTnVtYmVyID09PSB0aGlzLmxpbmVOdW1iZXIgJiYgbmV3Q29sdW1uID09PSB0aGlzLmNvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24obmV3TGluZU51bWJlciwgbmV3Q29sdW1uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlcml2ZSBhIG5ldyBwb3NpdGlvbiBmcm9tIHRoaXMgcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRlbHRhTGluZU51bWJlciBsaW5lIG51bWJlciBkZWx0YVxyXG4gICAgICogQHBhcmFtIGRlbHRhQ29sdW1uIGNvbHVtbiBkZWx0YVxyXG4gICAgICovXHJcbiAgICBkZWx0YShkZWx0YUxpbmVOdW1iZXIgPSAwLCBkZWx0YUNvbHVtbiA9IDApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53aXRoKHRoaXMubGluZU51bWJlciArIGRlbHRhTGluZU51bWJlciwgdGhpcy5jb2x1bW4gKyBkZWx0YUNvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgdGhpcyBwb3NpdGlvbiBlcXVhbHMgb3RoZXIgcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmVxdWFscyh0aGlzLCBvdGhlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgcG9zaXRpb24gYGFgIGVxdWFscyBwb3NpdGlvbiBgYmBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XHJcbiAgICAgICAgaWYgKCFhICYmICFiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKCEhYSAmJlxyXG4gICAgICAgICAgICAhIWIgJiZcclxuICAgICAgICAgICAgYS5saW5lTnVtYmVyID09PSBiLmxpbmVOdW1iZXIgJiZcclxuICAgICAgICAgICAgYS5jb2x1bW4gPT09IGIuY29sdW1uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiB0aGlzIHBvc2l0aW9uIGlzIGJlZm9yZSBvdGhlciBwb3NpdGlvbi5cclxuICAgICAqIElmIHRoZSB0d28gcG9zaXRpb25zIGFyZSBlcXVhbCwgdGhlIHJlc3VsdCB3aWxsIGJlIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBpc0JlZm9yZShvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBQb3NpdGlvbi5pc0JlZm9yZSh0aGlzLCBvdGhlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgcG9zaXRpb24gYGFgIGlzIGJlZm9yZSBwb3NpdGlvbiBgYmAuXHJcbiAgICAgKiBJZiB0aGUgdHdvIHBvc2l0aW9ucyBhcmUgZXF1YWwsIHRoZSByZXN1bHQgd2lsbCBiZSBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzQmVmb3JlKGEsIGIpIHtcclxuICAgICAgICBpZiAoYS5saW5lTnVtYmVyIDwgYi5saW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYi5saW5lTnVtYmVyIDwgYS5saW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGEuY29sdW1uIDwgYi5jb2x1bW47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgdGhpcyBwb3NpdGlvbiBpcyBiZWZvcmUgb3RoZXIgcG9zaXRpb24uXHJcbiAgICAgKiBJZiB0aGUgdHdvIHBvc2l0aW9ucyBhcmUgZXF1YWwsIHRoZSByZXN1bHQgd2lsbCBiZSB0cnVlLlxyXG4gICAgICovXHJcbiAgICBpc0JlZm9yZU9yRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gUG9zaXRpb24uaXNCZWZvcmVPckVxdWFsKHRoaXMsIG90aGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiBwb3NpdGlvbiBgYWAgaXMgYmVmb3JlIHBvc2l0aW9uIGBiYC5cclxuICAgICAqIElmIHRoZSB0d28gcG9zaXRpb25zIGFyZSBlcXVhbCwgdGhlIHJlc3VsdCB3aWxsIGJlIHRydWUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0JlZm9yZU9yRXF1YWwoYSwgYikge1xyXG4gICAgICAgIGlmIChhLmxpbmVOdW1iZXIgPCBiLmxpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiLmxpbmVOdW1iZXIgPCBhLmxpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYS5jb2x1bW4gPD0gYi5jb2x1bW47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCBjb21wYXJlcyBwb3NpdGlvbnMsIHVzZWZ1bCBmb3Igc29ydGluZ1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgbGV0IGFMaW5lTnVtYmVyID0gYS5saW5lTnVtYmVyIHwgMDtcclxuICAgICAgICBsZXQgYkxpbmVOdW1iZXIgPSBiLmxpbmVOdW1iZXIgfCAwO1xyXG4gICAgICAgIGlmIChhTGluZU51bWJlciA9PT0gYkxpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgbGV0IGFDb2x1bW4gPSBhLmNvbHVtbiB8IDA7XHJcbiAgICAgICAgICAgIGxldCBiQ29sdW1uID0gYi5jb2x1bW4gfCAwO1xyXG4gICAgICAgICAgICByZXR1cm4gYUNvbHVtbiAtIGJDb2x1bW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhTGluZU51bWJlciAtIGJMaW5lTnVtYmVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9uZSB0aGlzIHBvc2l0aW9uLlxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMubGluZU51bWJlciwgdGhpcy5jb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRvIGEgaHVtYW4tcmVhZGFibGUgcmVwcmVzZW50YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnKCcgKyB0aGlzLmxpbmVOdW1iZXIgKyAnLCcgKyB0aGlzLmNvbHVtbiArICcpJztcclxuICAgIH1cclxuICAgIC8vIC0tLVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBgUG9zaXRpb25gIGZyb20gYW4gYElQb3NpdGlvbmAuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBsaWZ0KHBvcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24ocG9zLmxpbmVOdW1iZXIsIHBvcy5jb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIGBvYmpgIGlzIGFuIGBJUG9zaXRpb25gLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNJUG9zaXRpb24ob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIChvYmpcclxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmoubGluZU51bWJlciA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICYmICh0eXBlb2Ygb2JqLmNvbHVtbiA9PT0gJ251bWJlcicpKTtcclxuICAgIH1cclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuL3Bvc2l0aW9uLmpzJztcclxuLyoqXHJcbiAqIEEgcmFuZ2UgaW4gdGhlIGVkaXRvci4gKHN0YXJ0TGluZU51bWJlcixzdGFydENvbHVtbikgaXMgPD0gKGVuZExpbmVOdW1iZXIsZW5kQ29sdW1uKVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJhbmdlIHtcclxuICAgIGNvbnN0cnVjdG9yKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbikge1xyXG4gICAgICAgIGlmICgoc3RhcnRMaW5lTnVtYmVyID4gZW5kTGluZU51bWJlcikgfHwgKHN0YXJ0TGluZU51bWJlciA9PT0gZW5kTGluZU51bWJlciAmJiBzdGFydENvbHVtbiA+IGVuZENvbHVtbikpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydExpbmVOdW1iZXIgPSBlbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0Q29sdW1uID0gZW5kQ29sdW1uO1xyXG4gICAgICAgICAgICB0aGlzLmVuZExpbmVOdW1iZXIgPSBzdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kQ29sdW1uID0gc3RhcnRDb2x1bW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0TGluZU51bWJlciA9IHN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICAgICAgdGhpcy5zdGFydENvbHVtbiA9IHN0YXJ0Q29sdW1uO1xyXG4gICAgICAgICAgICB0aGlzLmVuZExpbmVOdW1iZXIgPSBlbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICB0aGlzLmVuZENvbHVtbiA9IGVuZENvbHVtbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgdGhpcyByYW5nZSBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gUmFuZ2UuaXNFbXB0eSh0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiBgcmFuZ2VgIGlzIGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNFbXB0eShyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiAocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID09PSByYW5nZS5lbmRMaW5lTnVtYmVyICYmIHJhbmdlLnN0YXJ0Q29sdW1uID09PSByYW5nZS5lbmRDb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIHBvc2l0aW9uIGlzIGluIHRoaXMgcmFuZ2UuIElmIHRoZSBwb3NpdGlvbiBpcyBhdCB0aGUgZWRnZXMsIHdpbGwgcmV0dXJuIHRydWUuXHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zUG9zaXRpb24ocG9zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gUmFuZ2UuY29udGFpbnNQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgYHBvc2l0aW9uYCBpcyBpbiBgcmFuZ2VgLiBJZiB0aGUgcG9zaXRpb24gaXMgYXQgdGhlIGVkZ2VzLCB3aWxsIHJldHVybiB0cnVlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29udGFpbnNQb3NpdGlvbihyYW5nZSwgcG9zaXRpb24pIHtcclxuICAgICAgICBpZiAocG9zaXRpb24ubGluZU51bWJlciA8IHJhbmdlLnN0YXJ0TGluZU51bWJlciB8fCBwb3NpdGlvbi5saW5lTnVtYmVyID4gcmFuZ2UuZW5kTGluZU51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwb3NpdGlvbi5saW5lTnVtYmVyID09PSByYW5nZS5zdGFydExpbmVOdW1iZXIgJiYgcG9zaXRpb24uY29sdW1uIDwgcmFuZ2Uuc3RhcnRDb2x1bW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocG9zaXRpb24ubGluZU51bWJlciA9PT0gcmFuZ2UuZW5kTGluZU51bWJlciAmJiBwb3NpdGlvbi5jb2x1bW4gPiByYW5nZS5lbmRDb2x1bW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiByYW5nZSBpcyBpbiB0aGlzIHJhbmdlLiBJZiB0aGUgcmFuZ2UgaXMgZXF1YWwgdG8gdGhpcyByYW5nZSwgd2lsbCByZXR1cm4gdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgY29udGFpbnNSYW5nZShyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiBSYW5nZS5jb250YWluc1JhbmdlKHRoaXMsIHJhbmdlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiBgb3RoZXJSYW5nZWAgaXMgaW4gYHJhbmdlYC4gSWYgdGhlIHJhbmdlcyBhcmUgZXF1YWwsIHdpbGwgcmV0dXJuIHRydWUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjb250YWluc1JhbmdlKHJhbmdlLCBvdGhlclJhbmdlKSB7XHJcbiAgICAgICAgaWYgKG90aGVyUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIDwgcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIHx8IG90aGVyUmFuZ2UuZW5kTGluZU51bWJlciA8IHJhbmdlLnN0YXJ0TGluZU51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0TGluZU51bWJlciA+IHJhbmdlLmVuZExpbmVOdW1iZXIgfHwgb3RoZXJSYW5nZS5lbmRMaW5lTnVtYmVyID4gcmFuZ2UuZW5kTGluZU51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICYmIG90aGVyUmFuZ2Uuc3RhcnRDb2x1bW4gPCByYW5nZS5zdGFydENvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlclJhbmdlLmVuZExpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIgJiYgb3RoZXJSYW5nZS5lbmRDb2x1bW4gPiByYW5nZS5lbmRDb2x1bW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiBgcmFuZ2VgIGlzIHN0cmljdGx5IGluIHRoaXMgcmFuZ2UuIGByYW5nZWAgbXVzdCBzdGFydCBhZnRlciBhbmQgZW5kIGJlZm9yZSB0aGlzIHJhbmdlIGZvciB0aGUgcmVzdWx0IHRvIGJlIHRydWUuXHJcbiAgICAgKi9cclxuICAgIHN0cmljdENvbnRhaW5zUmFuZ2UocmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gUmFuZ2Uuc3RyaWN0Q29udGFpbnNSYW5nZSh0aGlzLCByYW5nZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgYG90aGVyUmFuZ2VgIGlzIHN0cmluY3RseSBpbiBgcmFuZ2VgIChtdXN0IHN0YXJ0IGFmdGVyLCBhbmQgZW5kIGJlZm9yZSkuIElmIHRoZSByYW5nZXMgYXJlIGVxdWFsLCB3aWxsIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHN0cmljdENvbnRhaW5zUmFuZ2UocmFuZ2UsIG90aGVyUmFuZ2UpIHtcclxuICAgICAgICBpZiAob3RoZXJSYW5nZS5zdGFydExpbmVOdW1iZXIgPCByYW5nZS5zdGFydExpbmVOdW1iZXIgfHwgb3RoZXJSYW5nZS5lbmRMaW5lTnVtYmVyIDwgcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG90aGVyUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID4gcmFuZ2UuZW5kTGluZU51bWJlciB8fCBvdGhlclJhbmdlLmVuZExpbmVOdW1iZXIgPiByYW5nZS5lbmRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG90aGVyUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID09PSByYW5nZS5zdGFydExpbmVOdW1iZXIgJiYgb3RoZXJSYW5nZS5zdGFydENvbHVtbiA8PSByYW5nZS5zdGFydENvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlclJhbmdlLmVuZExpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIgJiYgb3RoZXJSYW5nZS5lbmRDb2x1bW4gPj0gcmFuZ2UuZW5kQ29sdW1uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgcmV1bmlvbiBvZiB0aGUgdHdvIHJhbmdlcy5cclxuICAgICAqIFRoZSBzbWFsbGVzdCBwb3NpdGlvbiB3aWxsIGJlIHVzZWQgYXMgdGhlIHN0YXJ0IHBvaW50LCBhbmQgdGhlIGxhcmdlc3Qgb25lIGFzIHRoZSBlbmQgcG9pbnQuXHJcbiAgICAgKi9cclxuICAgIHBsdXNSYW5nZShyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiBSYW5nZS5wbHVzUmFuZ2UodGhpcywgcmFuZ2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHJldW5pb24gb2YgdGhlIHR3byByYW5nZXMuXHJcbiAgICAgKiBUaGUgc21hbGxlc3QgcG9zaXRpb24gd2lsbCBiZSB1c2VkIGFzIHRoZSBzdGFydCBwb2ludCwgYW5kIHRoZSBsYXJnZXN0IG9uZSBhcyB0aGUgZW5kIHBvaW50LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcGx1c1JhbmdlKGEsIGIpIHtcclxuICAgICAgICBsZXQgc3RhcnRMaW5lTnVtYmVyO1xyXG4gICAgICAgIGxldCBzdGFydENvbHVtbjtcclxuICAgICAgICBsZXQgZW5kTGluZU51bWJlcjtcclxuICAgICAgICBsZXQgZW5kQ29sdW1uO1xyXG4gICAgICAgIGlmIChiLnN0YXJ0TGluZU51bWJlciA8IGEuc3RhcnRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlciA9IGIuc3RhcnRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICBzdGFydENvbHVtbiA9IGIuc3RhcnRDb2x1bW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGIuc3RhcnRMaW5lTnVtYmVyID09PSBhLnN0YXJ0TGluZU51bWJlcikge1xyXG4gICAgICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBiLnN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBNYXRoLm1pbihiLnN0YXJ0Q29sdW1uLCBhLnN0YXJ0Q29sdW1uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlciA9IGEuc3RhcnRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICBzdGFydENvbHVtbiA9IGEuc3RhcnRDb2x1bW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiLmVuZExpbmVOdW1iZXIgPiBhLmVuZExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgZW5kTGluZU51bWJlciA9IGIuZW5kTGluZU51bWJlcjtcclxuICAgICAgICAgICAgZW5kQ29sdW1uID0gYi5lbmRDb2x1bW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGIuZW5kTGluZU51bWJlciA9PT0gYS5lbmRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGVuZExpbmVOdW1iZXIgPSBiLmVuZExpbmVOdW1iZXI7XHJcbiAgICAgICAgICAgIGVuZENvbHVtbiA9IE1hdGgubWF4KGIuZW5kQ29sdW1uLCBhLmVuZENvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbmRMaW5lTnVtYmVyID0gYS5lbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICBlbmRDb2x1bW4gPSBhLmVuZENvbHVtbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJhbmdlcy5cclxuICAgICAqL1xyXG4gICAgaW50ZXJzZWN0UmFuZ2VzKHJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIFJhbmdlLmludGVyc2VjdFJhbmdlcyh0aGlzLCByYW5nZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gcmFuZ2VzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50ZXJzZWN0UmFuZ2VzKGEsIGIpIHtcclxuICAgICAgICBsZXQgcmVzdWx0U3RhcnRMaW5lTnVtYmVyID0gYS5zdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgbGV0IHJlc3VsdFN0YXJ0Q29sdW1uID0gYS5zdGFydENvbHVtbjtcclxuICAgICAgICBsZXQgcmVzdWx0RW5kTGluZU51bWJlciA9IGEuZW5kTGluZU51bWJlcjtcclxuICAgICAgICBsZXQgcmVzdWx0RW5kQ29sdW1uID0gYS5lbmRDb2x1bW47XHJcbiAgICAgICAgbGV0IG90aGVyU3RhcnRMaW5lTnVtYmVyID0gYi5zdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgbGV0IG90aGVyU3RhcnRDb2x1bW4gPSBiLnN0YXJ0Q29sdW1uO1xyXG4gICAgICAgIGxldCBvdGhlckVuZExpbmVOdW1iZXIgPSBiLmVuZExpbmVOdW1iZXI7XHJcbiAgICAgICAgbGV0IG90aGVyRW5kQ29sdW1uID0gYi5lbmRDb2x1bW47XHJcbiAgICAgICAgaWYgKHJlc3VsdFN0YXJ0TGluZU51bWJlciA8IG90aGVyU3RhcnRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFN0YXJ0TGluZU51bWJlciA9IG90aGVyU3RhcnRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICByZXN1bHRTdGFydENvbHVtbiA9IG90aGVyU3RhcnRDb2x1bW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdFN0YXJ0TGluZU51bWJlciA9PT0gb3RoZXJTdGFydExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmVzdWx0U3RhcnRDb2x1bW4gPSBNYXRoLm1heChyZXN1bHRTdGFydENvbHVtbiwgb3RoZXJTdGFydENvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN1bHRFbmRMaW5lTnVtYmVyID4gb3RoZXJFbmRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdEVuZExpbmVOdW1iZXIgPSBvdGhlckVuZExpbmVOdW1iZXI7XHJcbiAgICAgICAgICAgIHJlc3VsdEVuZENvbHVtbiA9IG90aGVyRW5kQ29sdW1uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZXN1bHRFbmRMaW5lTnVtYmVyID09PSBvdGhlckVuZExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmVzdWx0RW5kQ29sdW1uID0gTWF0aC5taW4ocmVzdWx0RW5kQ29sdW1uLCBvdGhlckVuZENvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIGlmIHNlbGVjdGlvbiBpcyBub3cgZW1wdHlcclxuICAgICAgICBpZiAocmVzdWx0U3RhcnRMaW5lTnVtYmVyID4gcmVzdWx0RW5kTGluZU51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3VsdFN0YXJ0TGluZU51bWJlciA9PT0gcmVzdWx0RW5kTGluZU51bWJlciAmJiByZXN1bHRTdGFydENvbHVtbiA+IHJlc3VsdEVuZENvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyZXN1bHRTdGFydExpbmVOdW1iZXIsIHJlc3VsdFN0YXJ0Q29sdW1uLCByZXN1bHRFbmRMaW5lTnVtYmVyLCByZXN1bHRFbmRDb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIHRoaXMgcmFuZ2UgZXF1YWxzIG90aGVyLlxyXG4gICAgICovXHJcbiAgICBlcXVhbHNSYW5nZShvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBSYW5nZS5lcXVhbHNSYW5nZSh0aGlzLCBvdGhlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgcmFuZ2UgYGFgIGVxdWFscyBgYmAuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBlcXVhbHNSYW5nZShhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuICghIWEgJiZcclxuICAgICAgICAgICAgISFiICYmXHJcbiAgICAgICAgICAgIGEuc3RhcnRMaW5lTnVtYmVyID09PSBiLnN0YXJ0TGluZU51bWJlciAmJlxyXG4gICAgICAgICAgICBhLnN0YXJ0Q29sdW1uID09PSBiLnN0YXJ0Q29sdW1uICYmXHJcbiAgICAgICAgICAgIGEuZW5kTGluZU51bWJlciA9PT0gYi5lbmRMaW5lTnVtYmVyICYmXHJcbiAgICAgICAgICAgIGEuZW5kQ29sdW1uID09PSBiLmVuZENvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZW5kIHBvc2l0aW9uICh3aGljaCB3aWxsIGJlIGFmdGVyIG9yIGVxdWFsIHRvIHRoZSBzdGFydCBwb3NpdGlvbilcclxuICAgICAqL1xyXG4gICAgZ2V0RW5kUG9zaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFJhbmdlLmdldEVuZFBvc2l0aW9uKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGVuZCBwb3NpdGlvbiAod2hpY2ggd2lsbCBiZSBhZnRlciBvciBlcXVhbCB0byB0aGUgc3RhcnQgcG9zaXRpb24pXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRFbmRQb3NpdGlvbihyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24ocmFuZ2UuZW5kTGluZU51bWJlciwgcmFuZ2UuZW5kQ29sdW1uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBzdGFydCBwb3NpdGlvbiAod2hpY2ggd2lsbCBiZSBiZWZvcmUgb3IgZXF1YWwgdG8gdGhlIGVuZCBwb3NpdGlvbilcclxuICAgICAqL1xyXG4gICAgZ2V0U3RhcnRQb3NpdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gUmFuZ2UuZ2V0U3RhcnRQb3NpdGlvbih0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBzdGFydCBwb3NpdGlvbiAod2hpY2ggd2lsbCBiZSBiZWZvcmUgb3IgZXF1YWwgdG8gdGhlIGVuZCBwb3NpdGlvbilcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFN0YXJ0UG9zaXRpb24ocmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2Uuc3RhcnRDb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm0gdG8gYSB1c2VyIHByZXNlbnRhYmxlIHN0cmluZyByZXByZXNlbnRhdGlvbi5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICdbJyArIHRoaXMuc3RhcnRMaW5lTnVtYmVyICsgJywnICsgdGhpcy5zdGFydENvbHVtbiArICcgLT4gJyArIHRoaXMuZW5kTGluZU51bWJlciArICcsJyArIHRoaXMuZW5kQ29sdW1uICsgJ10nO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgcmFuZ2UgdXNpbmcgdGhpcyByYW5nZSdzIHN0YXJ0IHBvc2l0aW9uLCBhbmQgdXNpbmcgZW5kTGluZU51bWJlciBhbmQgZW5kQ29sdW1uIGFzIHRoZSBlbmQgcG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIHNldEVuZFBvc2l0aW9uKGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy5zdGFydExpbmVOdW1iZXIsIHRoaXMuc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyByYW5nZSB1c2luZyB0aGlzIHJhbmdlJ3MgZW5kIHBvc2l0aW9uLCBhbmQgdXNpbmcgc3RhcnRMaW5lTnVtYmVyIGFuZCBzdGFydENvbHVtbiBhcyB0aGUgc3RhcnQgcG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIHNldFN0YXJ0UG9zaXRpb24oc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgdGhpcy5lbmRMaW5lTnVtYmVyLCB0aGlzLmVuZENvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBlbXB0eSByYW5nZSB1c2luZyB0aGlzIHJhbmdlJ3Mgc3RhcnQgcG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIGNvbGxhcHNlVG9TdGFydCgpIHtcclxuICAgICAgICByZXR1cm4gUmFuZ2UuY29sbGFwc2VUb1N0YXJ0KHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgZW1wdHkgcmFuZ2UgdXNpbmcgdGhpcyByYW5nZSdzIHN0YXJ0IHBvc2l0aW9uLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29sbGFwc2VUb1N0YXJ0KHJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uLCByYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uKTtcclxuICAgIH1cclxuICAgIC8vIC0tLVxyXG4gICAgc3RhdGljIGZyb21Qb3NpdGlvbnMoc3RhcnQsIGVuZCA9IHN0YXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydC5saW5lTnVtYmVyLCBzdGFydC5jb2x1bW4sIGVuZC5saW5lTnVtYmVyLCBlbmQuY29sdW1uKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBsaWZ0KHJhbmdlKSB7XHJcbiAgICAgICAgaWYgKCFyYW5nZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uLCByYW5nZS5lbmRMaW5lTnVtYmVyLCByYW5nZS5lbmRDb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIGBvYmpgIGlzIGFuIGBJUmFuZ2VgLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNJUmFuZ2Uob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIChvYmpcclxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc3RhcnRMaW5lTnVtYmVyID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc3RhcnRDb2x1bW4gPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5lbmRMaW5lTnVtYmVyID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouZW5kQ29sdW1uID09PSAnbnVtYmVyJykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIHRoZSB0d28gcmFuZ2VzIGFyZSB0b3VjaGluZyBpbiBhbnkgd2F5LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXJlSW50ZXJzZWN0aW5nT3JUb3VjaGluZyhhLCBiKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYGFgIGlzIGJlZm9yZSBgYmBcclxuICAgICAgICBpZiAoYS5lbmRMaW5lTnVtYmVyIDwgYi5zdGFydExpbmVOdW1iZXIgfHwgKGEuZW5kTGluZU51bWJlciA9PT0gYi5zdGFydExpbmVOdW1iZXIgJiYgYS5lbmRDb2x1bW4gPCBiLnN0YXJ0Q29sdW1uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIGlmIGBiYCBpcyBiZWZvcmUgYGFgXHJcbiAgICAgICAgaWYgKGIuZW5kTGluZU51bWJlciA8IGEuc3RhcnRMaW5lTnVtYmVyIHx8IChiLmVuZExpbmVOdW1iZXIgPT09IGEuc3RhcnRMaW5lTnVtYmVyICYmIGIuZW5kQ29sdW1uIDwgYS5zdGFydENvbHVtbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGVzZSByYW5nZXMgbXVzdCBpbnRlcnNlY3RcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiB0aGUgdHdvIHJhbmdlcyBhcmUgaW50ZXJzZWN0aW5nLiBJZiB0aGUgcmFuZ2VzIGFyZSB0b3VjaGluZyBpdCByZXR1cm5zIHRydWUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhcmVJbnRlcnNlY3RpbmcoYSwgYikge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIGBhYCBpcyBiZWZvcmUgYGJgXHJcbiAgICAgICAgaWYgKGEuZW5kTGluZU51bWJlciA8IGIuc3RhcnRMaW5lTnVtYmVyIHx8IChhLmVuZExpbmVOdW1iZXIgPT09IGIuc3RhcnRMaW5lTnVtYmVyICYmIGEuZW5kQ29sdW1uIDw9IGIuc3RhcnRDb2x1bW4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYGJgIGlzIGJlZm9yZSBgYWBcclxuICAgICAgICBpZiAoYi5lbmRMaW5lTnVtYmVyIDwgYS5zdGFydExpbmVOdW1iZXIgfHwgKGIuZW5kTGluZU51bWJlciA9PT0gYS5zdGFydExpbmVOdW1iZXIgJiYgYi5lbmRDb2x1bW4gPD0gYS5zdGFydENvbHVtbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGVzZSByYW5nZXMgbXVzdCBpbnRlcnNlY3RcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGNvbXBhcmVzIHJhbmdlcywgdXNlZnVsIGZvciBzb3J0aW5nIHJhbmdlc1xyXG4gICAgICogSXQgd2lsbCBmaXJzdCBjb21wYXJlIHJhbmdlcyBvbiB0aGUgc3RhcnRQb3NpdGlvbiBhbmQgdGhlbiBvbiB0aGUgZW5kUG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNvbXBhcmVSYW5nZXNVc2luZ1N0YXJ0cyhhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEgJiYgYikge1xyXG4gICAgICAgICAgICBjb25zdCBhU3RhcnRMaW5lTnVtYmVyID0gYS5zdGFydExpbmVOdW1iZXIgfCAwO1xyXG4gICAgICAgICAgICBjb25zdCBiU3RhcnRMaW5lTnVtYmVyID0gYi5zdGFydExpbmVOdW1iZXIgfCAwO1xyXG4gICAgICAgICAgICBpZiAoYVN0YXJ0TGluZU51bWJlciA9PT0gYlN0YXJ0TGluZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYVN0YXJ0Q29sdW1uID0gYS5zdGFydENvbHVtbiB8IDA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiU3RhcnRDb2x1bW4gPSBiLnN0YXJ0Q29sdW1uIHwgMDtcclxuICAgICAgICAgICAgICAgIGlmIChhU3RhcnRDb2x1bW4gPT09IGJTdGFydENvbHVtbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFFbmRMaW5lTnVtYmVyID0gYS5lbmRMaW5lTnVtYmVyIHwgMDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiRW5kTGluZU51bWJlciA9IGIuZW5kTGluZU51bWJlciB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFFbmRMaW5lTnVtYmVyID09PSBiRW5kTGluZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhRW5kQ29sdW1uID0gYS5lbmRDb2x1bW4gfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiRW5kQ29sdW1uID0gYi5lbmRDb2x1bW4gfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYUVuZENvbHVtbiAtIGJFbmRDb2x1bW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhRW5kTGluZU51bWJlciAtIGJFbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFTdGFydENvbHVtbiAtIGJTdGFydENvbHVtbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYVN0YXJ0TGluZU51bWJlciAtIGJTdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFFeGlzdHMgPSAoYSA/IDEgOiAwKTtcclxuICAgICAgICBjb25zdCBiRXhpc3RzID0gKGIgPyAxIDogMCk7XHJcbiAgICAgICAgcmV0dXJuIGFFeGlzdHMgLSBiRXhpc3RzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgY29tcGFyZXMgcmFuZ2VzLCB1c2VmdWwgZm9yIHNvcnRpbmcgcmFuZ2VzXHJcbiAgICAgKiBJdCB3aWxsIGZpcnN0IGNvbXBhcmUgcmFuZ2VzIG9uIHRoZSBlbmRQb3NpdGlvbiBhbmQgdGhlbiBvbiB0aGUgc3RhcnRQb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29tcGFyZVJhbmdlc1VzaW5nRW5kcyhhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEuZW5kTGluZU51bWJlciA9PT0gYi5lbmRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGlmIChhLmVuZENvbHVtbiA9PT0gYi5lbmRDb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChhLnN0YXJ0TGluZU51bWJlciA9PT0gYi5zdGFydExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGFydENvbHVtbiAtIGIuc3RhcnRDb2x1bW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGFydExpbmVOdW1iZXIgLSBiLnN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYS5lbmRDb2x1bW4gLSBiLmVuZENvbHVtbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGEuZW5kTGluZU51bWJlciAtIGIuZW5kTGluZU51bWJlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiB0aGUgcmFuZ2Ugc3BhbnMgbXVsdGlwbGUgbGluZXMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzcGFuc011bHRpcGxlTGluZXMocmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gcmFuZ2UuZW5kTGluZU51bWJlciA+IHJhbmdlLnN0YXJ0TGluZU51bWJlcjtcclxuICAgIH1cclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuL3Bvc2l0aW9uLmpzJztcclxuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuL3JhbmdlLmpzJztcclxuLyoqXHJcbiAqIEEgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IuXHJcbiAqIFRoZSBzZWxlY3Rpb24gaXMgYSByYW5nZSB0aGF0IGhhcyBhbiBvcmllbnRhdGlvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBTZWxlY3Rpb24gZXh0ZW5kcyBSYW5nZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZWxlY3Rpb25TdGFydExpbmVOdW1iZXIsIHNlbGVjdGlvblN0YXJ0Q29sdW1uLCBwb3NpdGlvbkxpbmVOdW1iZXIsIHBvc2l0aW9uQ29sdW1uKSB7XHJcbiAgICAgICAgc3VwZXIoc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyLCBzZWxlY3Rpb25TdGFydENvbHVtbiwgcG9zaXRpb25MaW5lTnVtYmVyLCBwb3NpdGlvbkNvbHVtbik7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydExpbmVOdW1iZXIgPSBzZWxlY3Rpb25TdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydENvbHVtbiA9IHNlbGVjdGlvblN0YXJ0Q29sdW1uO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb25MaW5lTnVtYmVyID0gcG9zaXRpb25MaW5lTnVtYmVyO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb25Db2x1bW4gPSBwb3NpdGlvbkNvbHVtbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtIHRvIGEgaHVtYW4tcmVhZGFibGUgcmVwcmVzZW50YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnWycgKyB0aGlzLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciArICcsJyArIHRoaXMuc2VsZWN0aW9uU3RhcnRDb2x1bW4gKyAnIC0+ICcgKyB0aGlzLnBvc2l0aW9uTGluZU51bWJlciArICcsJyArIHRoaXMucG9zaXRpb25Db2x1bW4gKyAnXSc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgZXF1YWxzIG90aGVyIHNlbGVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgZXF1YWxzU2VsZWN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIChTZWxlY3Rpb24uc2VsZWN0aW9uc0VxdWFsKHRoaXMsIG90aGVyKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgdGhlIHR3byBzZWxlY3Rpb25zIGFyZSBlcXVhbC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNlbGVjdGlvbnNFcXVhbChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIChhLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciA9PT0gYi5zZWxlY3Rpb25TdGFydExpbmVOdW1iZXIgJiZcclxuICAgICAgICAgICAgYS5zZWxlY3Rpb25TdGFydENvbHVtbiA9PT0gYi5zZWxlY3Rpb25TdGFydENvbHVtbiAmJlxyXG4gICAgICAgICAgICBhLnBvc2l0aW9uTGluZU51bWJlciA9PT0gYi5wb3NpdGlvbkxpbmVOdW1iZXIgJiZcclxuICAgICAgICAgICAgYS5wb3NpdGlvbkNvbHVtbiA9PT0gYi5wb3NpdGlvbkNvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBkaXJlY3Rpb25zIChMVFIgb3IgUlRMKS5cclxuICAgICAqL1xyXG4gICAgZ2V0RGlyZWN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciA9PT0gdGhpcy5zdGFydExpbmVOdW1iZXIgJiYgdGhpcy5zZWxlY3Rpb25TdGFydENvbHVtbiA9PT0gdGhpcy5zdGFydENvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4gMCAvKiBMVFIgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAxIC8qIFJUTCAqLztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IHNlbGVjdGlvbiB3aXRoIGEgZGlmZmVyZW50IGBwb3NpdGlvbkxpbmVOdW1iZXJgIGFuZCBgcG9zaXRpb25Db2x1bW5gLlxyXG4gICAgICovXHJcbiAgICBzZXRFbmRQb3NpdGlvbihlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4pIHtcclxuICAgICAgICBpZiAodGhpcy5nZXREaXJlY3Rpb24oKSA9PT0gMCAvKiBMVFIgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5zdGFydExpbmVOdW1iZXIsIHRoaXMuc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbiwgdGhpcy5zdGFydExpbmVOdW1iZXIsIHRoaXMuc3RhcnRDb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHBvc2l0aW9uIGF0IGBwb3NpdGlvbkxpbmVOdW1iZXJgIGFuZCBgcG9zaXRpb25Db2x1bW5gLlxyXG4gICAgICovXHJcbiAgICBnZXRQb3NpdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMucG9zaXRpb25MaW5lTnVtYmVyLCB0aGlzLnBvc2l0aW9uQ29sdW1uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IHNlbGVjdGlvbiB3aXRoIGEgZGlmZmVyZW50IGBzZWxlY3Rpb25TdGFydExpbmVOdW1iZXJgIGFuZCBgc2VsZWN0aW9uU3RhcnRDb2x1bW5gLlxyXG4gICAgICovXHJcbiAgICBzZXRTdGFydFBvc2l0aW9uKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4pIHtcclxuICAgICAgICBpZiAodGhpcy5nZXREaXJlY3Rpb24oKSA9PT0gMCAvKiBMVFIgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgdGhpcy5lbmRMaW5lTnVtYmVyLCB0aGlzLmVuZENvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuZW5kTGluZU51bWJlciwgdGhpcy5lbmRDb2x1bW4sIHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLy8gLS0tLVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBgU2VsZWN0aW9uYCBmcm9tIG9uZSBvciB0d28gcG9zaXRpb25zXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tUG9zaXRpb25zKHN0YXJ0LCBlbmQgPSBzdGFydCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHN0YXJ0LmxpbmVOdW1iZXIsIHN0YXJ0LmNvbHVtbiwgZW5kLmxpbmVOdW1iZXIsIGVuZC5jb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBgU2VsZWN0aW9uYCBmcm9tIGFuIGBJU2VsZWN0aW9uYC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGxpZnRTZWxlY3Rpb24oc2VsKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc2VsLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciwgc2VsLnNlbGVjdGlvblN0YXJ0Q29sdW1uLCBzZWwucG9zaXRpb25MaW5lTnVtYmVyLCBzZWwucG9zaXRpb25Db2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBgYWAgZXF1YWxzIGBiYC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNlbGVjdGlvbnNBcnJFcXVhbChhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEgJiYgIWIgfHwgIWEgJiYgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYSAmJiAhYikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25zRXF1YWwoYVtpXSwgYltpXSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiBgb2JqYCBpcyBhbiBgSVNlbGVjdGlvbmAuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0lTZWxlY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIChvYmpcclxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc2VsZWN0aW9uU3RhcnRDb2x1bW4gPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5wb3NpdGlvbkxpbmVOdW1iZXIgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5wb3NpdGlvbkNvbHVtbiA9PT0gJ251bWJlcicpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHdpdGggYSBkaXJlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVXaXRoRGlyZWN0aW9uKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbiwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gMCAvKiBMVFIgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgZW5kTGluZU51bWJlciwgZW5kQ29sdW1uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oZW5kTGluZU51bWJlciwgZW5kQ29sdW1uLCBzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uKTtcclxuICAgIH1cclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZXhwb3J0IGNsYXNzIFRva2VuIHtcclxuICAgIGNvbnN0cnVjdG9yKG9mZnNldCwgdHlwZSwgbGFuZ3VhZ2UpIHtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldCB8IDA7IC8vIEBwZXJmXHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLmxhbmd1YWdlID0gbGFuZ3VhZ2U7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gJygnICsgdGhpcy5vZmZzZXQgKyAnLCAnICsgdGhpcy50eXBlICsgJyknO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBUb2tlbml6YXRpb25SZXN1bHQge1xyXG4gICAgY29uc3RydWN0b3IodG9rZW5zLCBlbmRTdGF0ZSkge1xyXG4gICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xyXG4gICAgICAgIHRoaXMuZW5kU3RhdGUgPSBlbmRTdGF0ZTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgVG9rZW5pemF0aW9uUmVzdWx0MiB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbnMsIGVuZFN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XHJcbiAgICAgICAgdGhpcy5lbmRTdGF0ZSA9IGVuZFN0YXRlO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBMY3NEaWZmIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vZGlmZi9kaWZmLmpzJztcclxuaW1wb3J0ICogYXMgc3RyaW5ncyBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9zdHJpbmdzLmpzJztcclxuY29uc3QgTUlOSU1VTV9NQVRDSElOR19DSEFSQUNURVJfTEVOR1RIID0gMztcclxuZnVuY3Rpb24gY29tcHV0ZURpZmYob3JpZ2luYWxTZXF1ZW5jZSwgbW9kaWZpZWRTZXF1ZW5jZSwgY29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlLCBwcmV0dHkpIHtcclxuICAgIGNvbnN0IGRpZmZBbGdvID0gbmV3IExjc0RpZmYob3JpZ2luYWxTZXF1ZW5jZSwgbW9kaWZpZWRTZXF1ZW5jZSwgY29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlKTtcclxuICAgIHJldHVybiBkaWZmQWxnby5Db21wdXRlRGlmZihwcmV0dHkpO1xyXG59XHJcbmNsYXNzIExpbmVTZXF1ZW5jZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihsaW5lcykge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0Q29sdW1ucyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGVuZENvbHVtbnMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc3RhcnRDb2x1bW5zW2ldID0gZ2V0Rmlyc3ROb25CbGFua0NvbHVtbihsaW5lc1tpXSwgMSk7XHJcbiAgICAgICAgICAgIGVuZENvbHVtbnNbaV0gPSBnZXRMYXN0Tm9uQmxhbmtDb2x1bW4obGluZXNbaV0sIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxpbmVzID0gbGluZXM7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRDb2x1bW5zID0gc3RhcnRDb2x1bW5zO1xyXG4gICAgICAgIHRoaXMuX2VuZENvbHVtbnMgPSBlbmRDb2x1bW5zO1xyXG4gICAgfVxyXG4gICAgZ2V0RWxlbWVudHMoKSB7XHJcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5saW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBlbGVtZW50c1tpXSA9IHRoaXMubGluZXNbaV0uc3Vic3RyaW5nKHRoaXMuX3N0YXJ0Q29sdW1uc1tpXSAtIDEsIHRoaXMuX2VuZENvbHVtbnNbaV0gLSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xyXG4gICAgfVxyXG4gICAgZ2V0U3RhcnRMaW5lTnVtYmVyKGkpIHtcclxuICAgICAgICByZXR1cm4gaSArIDE7XHJcbiAgICB9XHJcbiAgICBnZXRFbmRMaW5lTnVtYmVyKGkpIHtcclxuICAgICAgICByZXR1cm4gaSArIDE7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVDaGFyU2VxdWVuY2Uoc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgY2hhckNvZGVzID0gW107XHJcbiAgICAgICAgY29uc3QgbGluZU51bWJlcnMgPSBbXTtcclxuICAgICAgICBjb25zdCBjb2x1bW5zID0gW107XHJcbiAgICAgICAgbGV0IGxlbiA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSBzdGFydEluZGV4OyBpbmRleCA8PSBlbmRJbmRleDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lQ29udGVudCA9IHRoaXMubGluZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydENvbHVtbiA9IChzaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZSA/IHRoaXMuX3N0YXJ0Q29sdW1uc1tpbmRleF0gOiAxKTtcclxuICAgICAgICAgICAgY29uc3QgZW5kQ29sdW1uID0gKHNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlID8gdGhpcy5fZW5kQ29sdW1uc1tpbmRleF0gOiBsaW5lQ29udGVudC5sZW5ndGggKyAxKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gc3RhcnRDb2x1bW47IGNvbCA8IGVuZENvbHVtbjsgY29sKyspIHtcclxuICAgICAgICAgICAgICAgIGNoYXJDb2Rlc1tsZW5dID0gbGluZUNvbnRlbnQuY2hhckNvZGVBdChjb2wgLSAxKTtcclxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXJzW2xlbl0gPSBpbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5zW2xlbl0gPSBjb2w7XHJcbiAgICAgICAgICAgICAgICBsZW4rKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IENoYXJTZXF1ZW5jZShjaGFyQ29kZXMsIGxpbmVOdW1iZXJzLCBjb2x1bW5zKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDaGFyU2VxdWVuY2Uge1xyXG4gICAgY29uc3RydWN0b3IoY2hhckNvZGVzLCBsaW5lTnVtYmVycywgY29sdW1ucykge1xyXG4gICAgICAgIHRoaXMuX2NoYXJDb2RlcyA9IGNoYXJDb2RlcztcclxuICAgICAgICB0aGlzLl9saW5lTnVtYmVycyA9IGxpbmVOdW1iZXJzO1xyXG4gICAgICAgIHRoaXMuX2NvbHVtbnMgPSBjb2x1bW5zO1xyXG4gICAgfVxyXG4gICAgZ2V0RWxlbWVudHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJDb2RlcztcclxuICAgIH1cclxuICAgIGdldFN0YXJ0TGluZU51bWJlcihpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVOdW1iZXJzW2ldO1xyXG4gICAgfVxyXG4gICAgZ2V0U3RhcnRDb2x1bW4oaSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zW2ldO1xyXG4gICAgfVxyXG4gICAgZ2V0RW5kTGluZU51bWJlcihpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVOdW1iZXJzW2ldO1xyXG4gICAgfVxyXG4gICAgZ2V0RW5kQ29sdW1uKGkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1uc1tpXSArIDE7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQ2hhckNoYW5nZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbFN0YXJ0TGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxFbmRMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRTdGFydExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRDb2x1bW4sIG1vZGlmaWVkRW5kTGluZU51bWJlciwgbW9kaWZpZWRFbmRDb2x1bW4pIHtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyID0gb3JpZ2luYWxTdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5hbFN0YXJ0Q29sdW1uID0gb3JpZ2luYWxTdGFydENvbHVtbjtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsRW5kTGluZU51bWJlciA9IG9yaWdpbmFsRW5kTGluZU51bWJlcjtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsRW5kQ29sdW1uID0gb3JpZ2luYWxFbmRDb2x1bW47XHJcbiAgICAgICAgdGhpcy5tb2RpZmllZFN0YXJ0TGluZU51bWJlciA9IG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyO1xyXG4gICAgICAgIHRoaXMubW9kaWZpZWRTdGFydENvbHVtbiA9IG1vZGlmaWVkU3RhcnRDb2x1bW47XHJcbiAgICAgICAgdGhpcy5tb2RpZmllZEVuZExpbmVOdW1iZXIgPSBtb2RpZmllZEVuZExpbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllZEVuZENvbHVtbiA9IG1vZGlmaWVkRW5kQ29sdW1uO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZUZyb21EaWZmQ2hhbmdlKGRpZmZDaGFuZ2UsIG9yaWdpbmFsQ2hhclNlcXVlbmNlLCBtb2RpZmllZENoYXJTZXF1ZW5jZSkge1xyXG4gICAgICAgIGxldCBvcmlnaW5hbFN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICBsZXQgb3JpZ2luYWxTdGFydENvbHVtbjtcclxuICAgICAgICBsZXQgb3JpZ2luYWxFbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgIGxldCBvcmlnaW5hbEVuZENvbHVtbjtcclxuICAgICAgICBsZXQgbW9kaWZpZWRTdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgbGV0IG1vZGlmaWVkU3RhcnRDb2x1bW47XHJcbiAgICAgICAgbGV0IG1vZGlmaWVkRW5kTGluZU51bWJlcjtcclxuICAgICAgICBsZXQgbW9kaWZpZWRFbmRDb2x1bW47XHJcbiAgICAgICAgaWYgKGRpZmZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgb3JpZ2luYWxTdGFydExpbmVOdW1iZXIgPSAwO1xyXG4gICAgICAgICAgICBvcmlnaW5hbFN0YXJ0Q29sdW1uID0gMDtcclxuICAgICAgICAgICAgb3JpZ2luYWxFbmRMaW5lTnVtYmVyID0gMDtcclxuICAgICAgICAgICAgb3JpZ2luYWxFbmRDb2x1bW4gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3JpZ2luYWxTdGFydExpbmVOdW1iZXIgPSBvcmlnaW5hbENoYXJTZXF1ZW5jZS5nZXRTdGFydExpbmVOdW1iZXIoZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0KTtcclxuICAgICAgICAgICAgb3JpZ2luYWxTdGFydENvbHVtbiA9IG9yaWdpbmFsQ2hhclNlcXVlbmNlLmdldFN0YXJ0Q29sdW1uKGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCk7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsRW5kTGluZU51bWJlciA9IG9yaWdpbmFsQ2hhclNlcXVlbmNlLmdldEVuZExpbmVOdW1iZXIoZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICBvcmlnaW5hbEVuZENvbHVtbiA9IG9yaWdpbmFsQ2hhclNlcXVlbmNlLmdldEVuZENvbHVtbihkaWZmQ2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBkaWZmQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaWZmQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyID0gMDtcclxuICAgICAgICAgICAgbW9kaWZpZWRTdGFydENvbHVtbiA9IDA7XHJcbiAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlciA9IDA7XHJcbiAgICAgICAgICAgIG1vZGlmaWVkRW5kQ29sdW1uID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyID0gbW9kaWZpZWRDaGFyU2VxdWVuY2UuZ2V0U3RhcnRMaW5lTnVtYmVyKGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCk7XHJcbiAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRDb2x1bW4gPSBtb2RpZmllZENoYXJTZXF1ZW5jZS5nZXRTdGFydENvbHVtbihkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQpO1xyXG4gICAgICAgICAgICBtb2RpZmllZEVuZExpbmVOdW1iZXIgPSBtb2RpZmllZENoYXJTZXF1ZW5jZS5nZXRFbmRMaW5lTnVtYmVyKGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCArIGRpZmZDaGFuZ2UubW9kaWZpZWRMZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgbW9kaWZpZWRFbmRDb2x1bW4gPSBtb2RpZmllZENoYXJTZXF1ZW5jZS5nZXRFbmRDb2x1bW4oZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IENoYXJDaGFuZ2Uob3JpZ2luYWxTdGFydExpbmVOdW1iZXIsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG9yaWdpbmFsRW5kTGluZU51bWJlciwgb3JpZ2luYWxFbmRDb2x1bW4sIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZEVuZExpbmVOdW1iZXIsIG1vZGlmaWVkRW5kQ29sdW1uKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwb3N0UHJvY2Vzc0NoYXJDaGFuZ2VzKHJhd0NoYW5nZXMpIHtcclxuICAgIGlmIChyYXdDaGFuZ2VzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhd0NoYW5nZXM7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXN1bHQgPSBbcmF3Q2hhbmdlc1swXV07XHJcbiAgICBsZXQgcHJldkNoYW5nZSA9IHJlc3VsdFswXTtcclxuICAgIGZvciAobGV0IGkgPSAxLCBsZW4gPSByYXdDaGFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY3VyckNoYW5nZSA9IHJhd0NoYW5nZXNbaV07XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxNYXRjaGluZ0xlbmd0aCA9IGN1cnJDaGFuZ2Uub3JpZ2luYWxTdGFydCAtIChwcmV2Q2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBwcmV2Q2hhbmdlLm9yaWdpbmFsTGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBtb2RpZmllZE1hdGNoaW5nTGVuZ3RoID0gY3VyckNoYW5nZS5tb2RpZmllZFN0YXJ0IC0gKHByZXZDaGFuZ2UubW9kaWZpZWRTdGFydCArIHByZXZDaGFuZ2UubW9kaWZpZWRMZW5ndGgpO1xyXG4gICAgICAgIC8vIEJvdGggb2YgdGhlIGFib3ZlIHNob3VsZCBiZSBlcXVhbCwgYnV0IHRoZSBjb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUgbWF5IHByZXZlbnQgdGhpcyBmcm9tIGJlaW5nIHRydWVcclxuICAgICAgICBjb25zdCBtYXRjaGluZ0xlbmd0aCA9IE1hdGgubWluKG9yaWdpbmFsTWF0Y2hpbmdMZW5ndGgsIG1vZGlmaWVkTWF0Y2hpbmdMZW5ndGgpO1xyXG4gICAgICAgIGlmIChtYXRjaGluZ0xlbmd0aCA8IE1JTklNVU1fTUFUQ0hJTkdfQ0hBUkFDVEVSX0xFTkdUSCkge1xyXG4gICAgICAgICAgICAvLyBNZXJnZSB0aGUgY3VycmVudCBjaGFuZ2UgaW50byB0aGUgcHJldmlvdXMgb25lXHJcbiAgICAgICAgICAgIHByZXZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggPSAoY3VyckNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgY3VyckNoYW5nZS5vcmlnaW5hbExlbmd0aCkgLSBwcmV2Q2hhbmdlLm9yaWdpbmFsU3RhcnQ7XHJcbiAgICAgICAgICAgIHByZXZDaGFuZ2UubW9kaWZpZWRMZW5ndGggPSAoY3VyckNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgY3VyckNoYW5nZS5tb2RpZmllZExlbmd0aCkgLSBwcmV2Q2hhbmdlLm1vZGlmaWVkU3RhcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIGN1cnJlbnQgY2hhbmdlXHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJDaGFuZ2UpO1xyXG4gICAgICAgICAgICBwcmV2Q2hhbmdlID0gY3VyckNoYW5nZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmNsYXNzIExpbmVDaGFuZ2Uge1xyXG4gICAgY29uc3RydWN0b3Iob3JpZ2luYWxTdGFydExpbmVOdW1iZXIsIG9yaWdpbmFsRW5kTGluZU51bWJlciwgbW9kaWZpZWRTdGFydExpbmVOdW1iZXIsIG1vZGlmaWVkRW5kTGluZU51bWJlciwgY2hhckNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyID0gb3JpZ2luYWxTdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVuZExpbmVOdW1iZXIgPSBvcmlnaW5hbEVuZExpbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllZFN0YXJ0TGluZU51bWJlciA9IG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyO1xyXG4gICAgICAgIHRoaXMubW9kaWZpZWRFbmRMaW5lTnVtYmVyID0gbW9kaWZpZWRFbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgIHRoaXMuY2hhckNoYW5nZXMgPSBjaGFyQ2hhbmdlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVhdGVGcm9tRGlmZlJlc3VsdChzaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZSwgZGlmZkNoYW5nZSwgb3JpZ2luYWxMaW5lU2VxdWVuY2UsIG1vZGlmaWVkTGluZVNlcXVlbmNlLCBjb250aW51ZUNoYXJEaWZmLCBzaG91bGRDb21wdXRlQ2hhckNoYW5nZXMsIHNob3VsZFBvc3RQcm9jZXNzQ2hhckNoYW5nZXMpIHtcclxuICAgICAgICBsZXQgb3JpZ2luYWxTdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgbGV0IG9yaWdpbmFsRW5kTGluZU51bWJlcjtcclxuICAgICAgICBsZXQgbW9kaWZpZWRTdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgbGV0IG1vZGlmaWVkRW5kTGluZU51bWJlcjtcclxuICAgICAgICBsZXQgY2hhckNoYW5nZXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKGRpZmZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgb3JpZ2luYWxTdGFydExpbmVOdW1iZXIgPSBvcmlnaW5hbExpbmVTZXF1ZW5jZS5nZXRTdGFydExpbmVOdW1iZXIoZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0KSAtIDE7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsRW5kTGluZU51bWJlciA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcmlnaW5hbFN0YXJ0TGluZU51bWJlciA9IG9yaWdpbmFsTGluZVNlcXVlbmNlLmdldFN0YXJ0TGluZU51bWJlcihkaWZmQ2hhbmdlLm9yaWdpbmFsU3RhcnQpO1xyXG4gICAgICAgICAgICBvcmlnaW5hbEVuZExpbmVOdW1iZXIgPSBvcmlnaW5hbExpbmVTZXF1ZW5jZS5nZXRFbmRMaW5lTnVtYmVyKGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCArIGRpZmZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggLSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpZmZDaGFuZ2UubW9kaWZpZWRMZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgbW9kaWZpZWRTdGFydExpbmVOdW1iZXIgPSBtb2RpZmllZExpbmVTZXF1ZW5jZS5nZXRTdGFydExpbmVOdW1iZXIoZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0KSAtIDE7XHJcbiAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlciA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtb2RpZmllZFN0YXJ0TGluZU51bWJlciA9IG1vZGlmaWVkTGluZVNlcXVlbmNlLmdldFN0YXJ0TGluZU51bWJlcihkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQpO1xyXG4gICAgICAgICAgICBtb2RpZmllZEVuZExpbmVOdW1iZXIgPSBtb2RpZmllZExpbmVTZXF1ZW5jZS5nZXRFbmRMaW5lTnVtYmVyKGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCArIGRpZmZDaGFuZ2UubW9kaWZpZWRMZW5ndGggLSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcyAmJiBkaWZmQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoID4gMCAmJiBkaWZmQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoIDwgMjAgJiYgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCA+IDAgJiYgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCA8IDIwICYmIGNvbnRpbnVlQ2hhckRpZmYoKSkge1xyXG4gICAgICAgICAgICAvLyBDb21wdXRlIGNoYXJhY3RlciBjaGFuZ2VzIGZvciBkaWZmIGNodW5rcyBvZiBhdCBtb3N0IDIwIGxpbmVzLi4uXHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsQ2hhclNlcXVlbmNlID0gb3JpZ2luYWxMaW5lU2VxdWVuY2UuY3JlYXRlQ2hhclNlcXVlbmNlKHNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlLCBkaWZmQ2hhbmdlLm9yaWdpbmFsU3RhcnQsIGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCArIGRpZmZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRDaGFyU2VxdWVuY2UgPSBtb2RpZmllZExpbmVTZXF1ZW5jZS5jcmVhdGVDaGFyU2VxdWVuY2Uoc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UsIGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCwgZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICBsZXQgcmF3Q2hhbmdlcyA9IGNvbXB1dGVEaWZmKG9yaWdpbmFsQ2hhclNlcXVlbmNlLCBtb2RpZmllZENoYXJTZXF1ZW5jZSwgY29udGludWVDaGFyRGlmZiwgdHJ1ZSkuY2hhbmdlcztcclxuICAgICAgICAgICAgaWYgKHNob3VsZFBvc3RQcm9jZXNzQ2hhckNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIHJhd0NoYW5nZXMgPSBwb3N0UHJvY2Vzc0NoYXJDaGFuZ2VzKHJhd0NoYW5nZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoYXJDaGFuZ2VzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSByYXdDaGFuZ2VzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFyQ2hhbmdlcy5wdXNoKENoYXJDaGFuZ2UuY3JlYXRlRnJvbURpZmZDaGFuZ2UocmF3Q2hhbmdlc1tpXSwgb3JpZ2luYWxDaGFyU2VxdWVuY2UsIG1vZGlmaWVkQ2hhclNlcXVlbmNlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lQ2hhbmdlKG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyLCBtb2RpZmllZEVuZExpbmVOdW1iZXIsIGNoYXJDaGFuZ2VzKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgRGlmZkNvbXB1dGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIG9wdHMpIHtcclxuICAgICAgICB0aGlzLnNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcyA9IG9wdHMuc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzO1xyXG4gICAgICAgIHRoaXMuc2hvdWxkUG9zdFByb2Nlc3NDaGFyQ2hhbmdlcyA9IG9wdHMuc2hvdWxkUG9zdFByb2Nlc3NDaGFyQ2hhbmdlcztcclxuICAgICAgICB0aGlzLnNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlID0gb3B0cy5zaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZTtcclxuICAgICAgICB0aGlzLnNob3VsZE1ha2VQcmV0dHlEaWZmID0gb3B0cy5zaG91bGRNYWtlUHJldHR5RGlmZjtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsTGluZXMgPSBvcmlnaW5hbExpbmVzO1xyXG4gICAgICAgIHRoaXMubW9kaWZpZWRMaW5lcyA9IG1vZGlmaWVkTGluZXM7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5hbCA9IG5ldyBMaW5lU2VxdWVuY2Uob3JpZ2luYWxMaW5lcyk7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllZCA9IG5ldyBMaW5lU2VxdWVuY2UobW9kaWZpZWRMaW5lcyk7XHJcbiAgICAgICAgdGhpcy5jb250aW51ZUxpbmVEaWZmID0gY3JlYXRlQ29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlKG9wdHMubWF4Q29tcHV0YXRpb25UaW1lKTtcclxuICAgICAgICB0aGlzLmNvbnRpbnVlQ2hhckRpZmYgPSBjcmVhdGVDb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUob3B0cy5tYXhDb21wdXRhdGlvblRpbWUgPT09IDAgPyAwIDogTWF0aC5taW4ob3B0cy5tYXhDb21wdXRhdGlvblRpbWUsIDUwMDApKTsgLy8gbmV2ZXIgcnVuIGFmdGVyIDVzIGZvciBjaGFyYWN0ZXIgY2hhbmdlcy4uLlxyXG4gICAgfVxyXG4gICAgY29tcHV0ZURpZmYoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3JpZ2luYWwubGluZXMubGVuZ3RoID09PSAxICYmIHRoaXMub3JpZ2luYWwubGluZXNbMF0ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIGVtcHR5IG9yaWdpbmFsID0+IGZhc3QgcGF0aFxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcXVpdEVhcmx5OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNoYW5nZXM6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZExpbmVOdW1iZXI6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEVuZExpbmVOdW1iZXI6IHRoaXMubW9kaWZpZWQubGluZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ2hhbmdlczogW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEVuZENvbHVtbjogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEVuZExpbmVOdW1iZXI6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydENvbHVtbjogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZFN0YXJ0TGluZU51bWJlcjogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZENvbHVtbjogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZExpbmVOdW1iZXI6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydENvbHVtbjogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0TGluZU51bWJlcjogMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tb2RpZmllZC5saW5lcy5sZW5ndGggPT09IDEgJiYgdGhpcy5tb2RpZmllZC5saW5lc1swXS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgLy8gZW1wdHkgbW9kaWZpZWQgPT4gZmFzdCBwYXRoXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBxdWl0RWFybHk6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY2hhbmdlczogW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydExpbmVOdW1iZXI6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kTGluZU51bWJlcjogdGhpcy5vcmlnaW5hbC5saW5lcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEVuZExpbmVOdW1iZXI6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDaGFuZ2VzOiBbe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRW5kQ29sdW1uOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlcjogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZFN0YXJ0Q29sdW1uOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kQ29sdW1uOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kTGluZU51bWJlcjogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0Q29sdW1uOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyOiAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICAgICAgICAgIH1dXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRpZmZSZXN1bHQgPSBjb21wdXRlRGlmZih0aGlzLm9yaWdpbmFsLCB0aGlzLm1vZGlmaWVkLCB0aGlzLmNvbnRpbnVlTGluZURpZmYsIHRoaXMuc2hvdWxkTWFrZVByZXR0eURpZmYpO1xyXG4gICAgICAgIGNvbnN0IHJhd0NoYW5nZXMgPSBkaWZmUmVzdWx0LmNoYW5nZXM7XHJcbiAgICAgICAgY29uc3QgcXVpdEVhcmx5ID0gZGlmZlJlc3VsdC5xdWl0RWFybHk7XHJcbiAgICAgICAgLy8gVGhlIGRpZmYgaXMgYWx3YXlzIGNvbXB1dGVkIHdpdGggaWdub3JpbmcgdHJpbSB3aGl0ZXNwYWNlXHJcbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHdlIGdldCB0aGUgcHJldHRpZXN0IGRpZmZcclxuICAgICAgICBpZiAodGhpcy5zaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZSkge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lQ2hhbmdlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gcmF3Q2hhbmdlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGluZUNoYW5nZXMucHVzaChMaW5lQ2hhbmdlLmNyZWF0ZUZyb21EaWZmUmVzdWx0KHRoaXMuc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UsIHJhd0NoYW5nZXNbaV0sIHRoaXMub3JpZ2luYWwsIHRoaXMubW9kaWZpZWQsIHRoaXMuY29udGludWVDaGFyRGlmZiwgdGhpcy5zaG91bGRDb21wdXRlQ2hhckNoYW5nZXMsIHRoaXMuc2hvdWxkUG9zdFByb2Nlc3NDaGFyQ2hhbmdlcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBxdWl0RWFybHk6IHF1aXRFYXJseSxcclxuICAgICAgICAgICAgICAgIGNoYW5nZXM6IGxpbmVDaGFuZ2VzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5lZWQgdG8gcG9zdC1wcm9jZXNzIGFuZCBpbnRyb2R1Y2UgY2hhbmdlcyB3aGVyZSB0aGUgdHJpbSB3aGl0ZXNwYWNlIGlzIGRpZmZlcmVudFxyXG4gICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBhcmUgbG9vcGluZyBzdGFydGluZyBhdCAtMSB0byBhbHNvIGNvdmVyIHRoZSBsaW5lcyBiZWZvcmUgdGhlIGZpcnN0IGNoYW5nZVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGxldCBvcmlnaW5hbExpbmVJbmRleCA9IDA7XHJcbiAgICAgICAgbGV0IG1vZGlmaWVkTGluZUluZGV4ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gLTEgLyogISEhISAqLywgbGVuID0gcmF3Q2hhbmdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0Q2hhbmdlID0gKGkgKyAxIDwgbGVuID8gcmF3Q2hhbmdlc1tpICsgMV0gOiBudWxsKTtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdG9wID0gKG5leHRDaGFuZ2UgPyBuZXh0Q2hhbmdlLm9yaWdpbmFsU3RhcnQgOiB0aGlzLm9yaWdpbmFsTGluZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRTdG9wID0gKG5leHRDaGFuZ2UgPyBuZXh0Q2hhbmdlLm1vZGlmaWVkU3RhcnQgOiB0aGlzLm1vZGlmaWVkTGluZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgd2hpbGUgKG9yaWdpbmFsTGluZUluZGV4IDwgb3JpZ2luYWxTdG9wICYmIG1vZGlmaWVkTGluZUluZGV4IDwgbW9kaWZpZWRTdG9wKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbExpbmUgPSB0aGlzLm9yaWdpbmFsTGluZXNbb3JpZ2luYWxMaW5lSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRMaW5lID0gdGhpcy5tb2RpZmllZExpbmVzW21vZGlmaWVkTGluZUluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbExpbmUgIT09IG1vZGlmaWVkTGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGxpbmVzIGRpZmZlciBvbmx5IGluIHRyaW0gd2hpdGVzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvcmlnaW5hbFN0YXJ0Q29sdW1uID0gZ2V0Rmlyc3ROb25CbGFua0NvbHVtbihvcmlnaW5hbExpbmUsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbW9kaWZpZWRTdGFydENvbHVtbiA9IGdldEZpcnN0Tm9uQmxhbmtDb2x1bW4obW9kaWZpZWRMaW5lLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9yaWdpbmFsU3RhcnRDb2x1bW4gPiAxICYmIG1vZGlmaWVkU3RhcnRDb2x1bW4gPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbENoYXIgPSBvcmlnaW5hbExpbmUuY2hhckNvZGVBdChvcmlnaW5hbFN0YXJ0Q29sdW1uIC0gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZENoYXIgPSBtb2RpZmllZExpbmUuY2hhckNvZGVBdChtb2RpZmllZFN0YXJ0Q29sdW1uIC0gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxDaGFyICE9PSBtb2RpZmllZENoYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRDb2x1bW4tLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRDb2x1bW4tLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxTdGFydENvbHVtbiA+IDEgfHwgbW9kaWZpZWRTdGFydENvbHVtbiA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1c2hUcmltV2hpdGVzcGFjZUNoYXJDaGFuZ2UocmVzdWx0LCBvcmlnaW5hbExpbmVJbmRleCArIDEsIDEsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG1vZGlmaWVkTGluZUluZGV4ICsgMSwgMSwgbW9kaWZpZWRTdGFydENvbHVtbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHRyYWlsaW5nIHdoaXRlc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvcmlnaW5hbEVuZENvbHVtbiA9IGdldExhc3ROb25CbGFua0NvbHVtbihvcmlnaW5hbExpbmUsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbW9kaWZpZWRFbmRDb2x1bW4gPSBnZXRMYXN0Tm9uQmxhbmtDb2x1bW4obW9kaWZpZWRMaW5lLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxNYXhDb2x1bW4gPSBvcmlnaW5hbExpbmUubGVuZ3RoICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRNYXhDb2x1bW4gPSBtb2RpZmllZExpbmUubGVuZ3RoICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9yaWdpbmFsRW5kQ29sdW1uIDwgb3JpZ2luYWxNYXhDb2x1bW4gJiYgbW9kaWZpZWRFbmRDb2x1bW4gPCBtb2RpZmllZE1heENvbHVtbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxDaGFyID0gb3JpZ2luYWxMaW5lLmNoYXJDb2RlQXQob3JpZ2luYWxFbmRDb2x1bW4gLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkQ2hhciA9IG9yaWdpbmFsTGluZS5jaGFyQ29kZUF0KG1vZGlmaWVkRW5kQ29sdW1uIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxDaGFyICE9PSBtb2RpZmllZENoYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kQ29sdW1uKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEVuZENvbHVtbisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEVuZENvbHVtbiA8IG9yaWdpbmFsTWF4Q29sdW1uIHx8IG1vZGlmaWVkRW5kQ29sdW1uIDwgbW9kaWZpZWRNYXhDb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1c2hUcmltV2hpdGVzcGFjZUNoYXJDaGFuZ2UocmVzdWx0LCBvcmlnaW5hbExpbmVJbmRleCArIDEsIG9yaWdpbmFsRW5kQ29sdW1uLCBvcmlnaW5hbE1heENvbHVtbiwgbW9kaWZpZWRMaW5lSW5kZXggKyAxLCBtb2RpZmllZEVuZENvbHVtbiwgbW9kaWZpZWRNYXhDb2x1bW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxMaW5lSW5kZXgrKztcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVkTGluZUluZGV4Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5leHRDaGFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIEVtaXQgdGhlIGFjdHVhbCBjaGFuZ2VcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKExpbmVDaGFuZ2UuY3JlYXRlRnJvbURpZmZSZXN1bHQodGhpcy5zaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZSwgbmV4dENoYW5nZSwgdGhpcy5vcmlnaW5hbCwgdGhpcy5tb2RpZmllZCwgdGhpcy5jb250aW51ZUNoYXJEaWZmLCB0aGlzLnNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcywgdGhpcy5zaG91bGRQb3N0UHJvY2Vzc0NoYXJDaGFuZ2VzKSk7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbExpbmVJbmRleCArPSBuZXh0Q2hhbmdlLm9yaWdpbmFsTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRMaW5lSW5kZXggKz0gbmV4dENoYW5nZS5tb2RpZmllZExlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBxdWl0RWFybHk6IHF1aXRFYXJseSxcclxuICAgICAgICAgICAgY2hhbmdlczogcmVzdWx0XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIF9wdXNoVHJpbVdoaXRlc3BhY2VDaGFyQ2hhbmdlKHJlc3VsdCwgb3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbFN0YXJ0Q29sdW1uLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZEVuZENvbHVtbikge1xyXG4gICAgICAgIGlmICh0aGlzLl9tZXJnZVRyaW1XaGl0ZXNwYWNlQ2hhckNoYW5nZShyZXN1bHQsIG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxFbmRDb2x1bW4sIG1vZGlmaWVkTGluZU51bWJlciwgbW9kaWZpZWRTdGFydENvbHVtbiwgbW9kaWZpZWRFbmRDb2x1bW4pKSB7XHJcbiAgICAgICAgICAgIC8vIE1lcmdlZCBpbnRvIHByZXZpb3VzXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNoYXJDaGFuZ2VzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmICh0aGlzLnNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcykge1xyXG4gICAgICAgICAgICBjaGFyQ2hhbmdlcyA9IFtuZXcgQ2hhckNoYW5nZShvcmlnaW5hbExpbmVOdW1iZXIsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxFbmRDb2x1bW4sIG1vZGlmaWVkTGluZU51bWJlciwgbW9kaWZpZWRTdGFydENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZEVuZENvbHVtbildO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQucHVzaChuZXcgTGluZUNoYW5nZShvcmlnaW5hbExpbmVOdW1iZXIsIG9yaWdpbmFsTGluZU51bWJlciwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZExpbmVOdW1iZXIsIGNoYXJDaGFuZ2VzKSk7XHJcbiAgICB9XHJcbiAgICBfbWVyZ2VUcmltV2hpdGVzcGFjZUNoYXJDaGFuZ2UocmVzdWx0LCBvcmlnaW5hbExpbmVOdW1iZXIsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG9yaWdpbmFsRW5kQ29sdW1uLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRDb2x1bW4sIG1vZGlmaWVkRW5kQ29sdW1uKSB7XHJcbiAgICAgICAgY29uc3QgbGVuID0gcmVzdWx0Lmxlbmd0aDtcclxuICAgICAgICBpZiAobGVuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHJldkNoYW5nZSA9IHJlc3VsdFtsZW4gLSAxXTtcclxuICAgICAgICBpZiAocHJldkNoYW5nZS5vcmlnaW5hbEVuZExpbmVOdW1iZXIgPT09IDAgfHwgcHJldkNoYW5nZS5tb2RpZmllZEVuZExpbmVOdW1iZXIgPT09IDApIHtcclxuICAgICAgICAgICAgLy8gRG9uJ3QgbWVyZ2Ugd2l0aCBpbnNlcnRzL2RlbGV0ZXNcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldkNoYW5nZS5vcmlnaW5hbEVuZExpbmVOdW1iZXIgKyAxID09PSBvcmlnaW5hbExpbmVOdW1iZXIgJiYgcHJldkNoYW5nZS5tb2RpZmllZEVuZExpbmVOdW1iZXIgKyAxID09PSBtb2RpZmllZExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgcHJldkNoYW5nZS5vcmlnaW5hbEVuZExpbmVOdW1iZXIgPSBvcmlnaW5hbExpbmVOdW1iZXI7XHJcbiAgICAgICAgICAgIHByZXZDaGFuZ2UubW9kaWZpZWRFbmRMaW5lTnVtYmVyID0gbW9kaWZpZWRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRDb21wdXRlQ2hhckNoYW5nZXMgJiYgcHJldkNoYW5nZS5jaGFyQ2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgcHJldkNoYW5nZS5jaGFyQ2hhbmdlcy5wdXNoKG5ldyBDaGFyQ2hhbmdlKG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkRW5kQ29sdW1uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRGaXJzdE5vbkJsYW5rQ29sdW1uKHR4dCwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICBjb25zdCByID0gc3RyaW5ncy5maXJzdE5vbldoaXRlc3BhY2VJbmRleCh0eHQpO1xyXG4gICAgaWYgKHIgPT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiByICsgMTtcclxufVxyXG5mdW5jdGlvbiBnZXRMYXN0Tm9uQmxhbmtDb2x1bW4odHh0LCBkZWZhdWx0VmFsdWUpIHtcclxuICAgIGNvbnN0IHIgPSBzdHJpbmdzLmxhc3ROb25XaGl0ZXNwYWNlSW5kZXgodHh0KTtcclxuICAgIGlmIChyID09PSAtMSkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gciArIDI7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlKG1heGltdW1SdW50aW1lKSB7XHJcbiAgICBpZiAobWF4aW11bVJ1bnRpbWUgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gKCkgPT4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgbWF4aW11bVJ1bnRpbWU7XHJcbiAgICB9O1xyXG59XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gJy4uL2NvcmUvcG9zaXRpb24uanMnO1xyXG5pbXBvcnQgeyBQcmVmaXhTdW1Db21wdXRlciB9IGZyb20gJy4uL3ZpZXdNb2RlbC9wcmVmaXhTdW1Db21wdXRlci5qcyc7XHJcbmV4cG9ydCBjbGFzcyBNaXJyb3JUZXh0TW9kZWwge1xyXG4gICAgY29uc3RydWN0b3IodXJpLCBsaW5lcywgZW9sLCB2ZXJzaW9uSWQpIHtcclxuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XHJcbiAgICAgICAgdGhpcy5fbGluZXMgPSBsaW5lcztcclxuICAgICAgICB0aGlzLl9lb2wgPSBlb2w7XHJcbiAgICAgICAgdGhpcy5fdmVyc2lvbklkID0gdmVyc2lvbklkO1xyXG4gICAgICAgIHRoaXMuX2xpbmVTdGFydHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2NhY2hlZFRleHRWYWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuX2xpbmVzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICBnZXRUZXh0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWRUZXh0VmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FjaGVkVGV4dFZhbHVlID0gdGhpcy5fbGluZXMuam9pbih0aGlzLl9lb2wpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkVGV4dFZhbHVlO1xyXG4gICAgfVxyXG4gICAgb25FdmVudHMoZSkge1xyXG4gICAgICAgIGlmIChlLmVvbCAmJiBlLmVvbCAhPT0gdGhpcy5fZW9sKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VvbCA9IGUuZW9sO1xyXG4gICAgICAgICAgICB0aGlzLl9saW5lU3RhcnRzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIG15IGxpbmVzXHJcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGUuY2hhbmdlcztcclxuICAgICAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjY2VwdERlbGV0ZVJhbmdlKGNoYW5nZS5yYW5nZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjY2VwdEluc2VydFRleHQobmV3IFBvc2l0aW9uKGNoYW5nZS5yYW5nZS5zdGFydExpbmVOdW1iZXIsIGNoYW5nZS5yYW5nZS5zdGFydENvbHVtbiksIGNoYW5nZS50ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdmVyc2lvbklkID0gZS52ZXJzaW9uSWQ7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVkVGV4dFZhbHVlID0gbnVsbDtcclxuICAgIH1cclxuICAgIF9lbnN1cmVMaW5lU3RhcnRzKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fbGluZVN0YXJ0cykge1xyXG4gICAgICAgICAgICBjb25zdCBlb2xMZW5ndGggPSB0aGlzLl9lb2wubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lc0xlbmd0aCA9IHRoaXMuX2xpbmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgbGluZVN0YXJ0VmFsdWVzID0gbmV3IFVpbnQzMkFycmF5KGxpbmVzTGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lc0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnRWYWx1ZXNbaV0gPSB0aGlzLl9saW5lc1tpXS5sZW5ndGggKyBlb2xMZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbGluZVN0YXJ0cyA9IG5ldyBQcmVmaXhTdW1Db21wdXRlcihsaW5lU3RhcnRWYWx1ZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxsIGNoYW5nZXMgdG8gYSBsaW5lJ3MgdGV4dCBnbyB0aHJvdWdoIHRoaXMgbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIF9zZXRMaW5lVGV4dChsaW5lSW5kZXgsIG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fbGluZXNbbGluZUluZGV4XSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIGlmICh0aGlzLl9saW5lU3RhcnRzKSB7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwcmVmaXggc3VtXHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmVTdGFydHMuY2hhbmdlVmFsdWUobGluZUluZGV4LCB0aGlzLl9saW5lc1tsaW5lSW5kZXhdLmxlbmd0aCArIHRoaXMuX2VvbC5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9hY2NlcHREZWxldGVSYW5nZShyYW5nZSkge1xyXG4gICAgICAgIGlmIChyYW5nZS5zdGFydExpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0Q29sdW1uID09PSByYW5nZS5lbmRDb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZGVsZXRlXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRGVsZXRlIHRleHQgb24gdGhlIGFmZmVjdGVkIGxpbmVcclxuICAgICAgICAgICAgdGhpcy5fc2V0TGluZVRleHQocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMSwgdGhpcy5fbGluZXNbcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKDAsIHJhbmdlLnN0YXJ0Q29sdW1uIC0gMSlcclxuICAgICAgICAgICAgICAgICsgdGhpcy5fbGluZXNbcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKHJhbmdlLmVuZENvbHVtbiAtIDEpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUYWtlIHJlbWFpbmluZyB0ZXh0IG9uIGxhc3QgbGluZSBhbmQgYXBwZW5kIGl0IHRvIHJlbWFpbmluZyB0ZXh0IG9uIGZpcnN0IGxpbmVcclxuICAgICAgICB0aGlzLl9zZXRMaW5lVGV4dChyYW5nZS5zdGFydExpbmVOdW1iZXIgLSAxLCB0aGlzLl9saW5lc1tyYW5nZS5zdGFydExpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcoMCwgcmFuZ2Uuc3RhcnRDb2x1bW4gLSAxKVxyXG4gICAgICAgICAgICArIHRoaXMuX2xpbmVzW3JhbmdlLmVuZExpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcocmFuZ2UuZW5kQ29sdW1uIC0gMSkpO1xyXG4gICAgICAgIC8vIERlbGV0ZSBtaWRkbGUgbGluZXNcclxuICAgICAgICB0aGlzLl9saW5lcy5zcGxpY2UocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5lbmRMaW5lTnVtYmVyIC0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyKTtcclxuICAgICAgICBpZiAodGhpcy5fbGluZVN0YXJ0cykge1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgcHJlZml4IHN1bVxyXG4gICAgICAgICAgICB0aGlzLl9saW5lU3RhcnRzLnJlbW92ZVZhbHVlcyhyYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLmVuZExpbmVOdW1iZXIgLSByYW5nZS5zdGFydExpbmVOdW1iZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9hY2NlcHRJbnNlcnRUZXh0KHBvc2l0aW9uLCBpbnNlcnRUZXh0KSB7XHJcbiAgICAgICAgaWYgKGluc2VydFRleHQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gaW5zZXJ0XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGluc2VydExpbmVzID0gaW5zZXJ0VGV4dC5zcGxpdCgvXFxyXFxufFxccnxcXG4vKTtcclxuICAgICAgICBpZiAoaW5zZXJ0TGluZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIC8vIEluc2VydGluZyB0ZXh0IG9uIG9uZSBsaW5lXHJcbiAgICAgICAgICAgIHRoaXMuX3NldExpbmVUZXh0KHBvc2l0aW9uLmxpbmVOdW1iZXIgLSAxLCB0aGlzLl9saW5lc1twb3NpdGlvbi5saW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKDAsIHBvc2l0aW9uLmNvbHVtbiAtIDEpXHJcbiAgICAgICAgICAgICAgICArIGluc2VydExpbmVzWzBdXHJcbiAgICAgICAgICAgICAgICArIHRoaXMuX2xpbmVzW3Bvc2l0aW9uLmxpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcocG9zaXRpb24uY29sdW1uIC0gMSkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFwcGVuZCBvdmVyZmxvd2luZyB0ZXh0IGZyb20gZmlyc3QgbGluZSB0byB0aGUgZW5kIG9mIHRleHQgdG8gaW5zZXJ0XHJcbiAgICAgICAgaW5zZXJ0TGluZXNbaW5zZXJ0TGluZXMubGVuZ3RoIC0gMV0gKz0gdGhpcy5fbGluZXNbcG9zaXRpb24ubGluZU51bWJlciAtIDFdLnN1YnN0cmluZyhwb3NpdGlvbi5jb2x1bW4gLSAxKTtcclxuICAgICAgICAvLyBEZWxldGUgb3ZlcmZsb3dpbmcgdGV4dCBmcm9tIGZpcnN0IGxpbmUgYW5kIGluc2VydCB0ZXh0IG9uIGZpcnN0IGxpbmVcclxuICAgICAgICB0aGlzLl9zZXRMaW5lVGV4dChwb3NpdGlvbi5saW5lTnVtYmVyIC0gMSwgdGhpcy5fbGluZXNbcG9zaXRpb24ubGluZU51bWJlciAtIDFdLnN1YnN0cmluZygwLCBwb3NpdGlvbi5jb2x1bW4gLSAxKVxyXG4gICAgICAgICAgICArIGluc2VydExpbmVzWzBdKTtcclxuICAgICAgICAvLyBJbnNlcnQgbmV3IGxpbmVzICYgc3RvcmUgbGVuZ3Roc1xyXG4gICAgICAgIGxldCBuZXdMZW5ndGhzID0gbmV3IFVpbnQzMkFycmF5KGluc2VydExpbmVzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaW5zZXJ0TGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fbGluZXMuc3BsaWNlKHBvc2l0aW9uLmxpbmVOdW1iZXIgKyBpIC0gMSwgMCwgaW5zZXJ0TGluZXNbaV0pO1xyXG4gICAgICAgICAgICBuZXdMZW5ndGhzW2kgLSAxXSA9IGluc2VydExpbmVzW2ldLmxlbmd0aCArIHRoaXMuX2VvbC5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9saW5lU3RhcnRzKSB7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwcmVmaXggc3VtXHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmVTdGFydHMuaW5zZXJ0VmFsdWVzKHBvc2l0aW9uLmxpbmVOdW1iZXIsIG5ld0xlbmd0aHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZXhwb3J0IGNvbnN0IFVTVUFMX1dPUkRfU0VQQVJBVE9SUyA9ICdgfiFAIyQlXiYqKCktPStbe119XFxcXHw7OlxcJ1wiLC48Pi8/JztcclxuLyoqXHJcbiAqIENyZWF0ZSBhIHdvcmQgZGVmaW5pdGlvbiByZWd1bGFyIGV4cHJlc3Npb24gYmFzZWQgb24gZGVmYXVsdCB3b3JkIHNlcGFyYXRvcnMuXHJcbiAqIE9wdGlvbmFsbHkgcHJvdmlkZSBhbGxvd2VkIHNlcGFyYXRvcnMgdGhhdCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gd29yZHMuXHJcbiAqXHJcbiAqIFRoZSBkZWZhdWx0IHdvdWxkIGxvb2sgbGlrZSB0aGlzOlxyXG4gKiAvKC0/XFxkKlxcLlxcZFxcdyopfChbXlxcYFxcflxcIVxcQFxcI1xcJFxcJVxcXlxcJlxcKlxcKFxcKVxcLVxcPVxcK1xcW1xce1xcXVxcfVxcXFxcXHxcXDtcXDpcXCdcXFwiXFwsXFwuXFw8XFw+XFwvXFw/XFxzXSspL2dcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVdvcmRSZWdFeHAoYWxsb3dJbldvcmRzID0gJycpIHtcclxuICAgIGxldCBzb3VyY2UgPSAnKC0/XFxcXGQqXFxcXC5cXFxcZFxcXFx3Kil8KFteJztcclxuICAgIGZvciAoY29uc3Qgc2VwIG9mIFVTVUFMX1dPUkRfU0VQQVJBVE9SUykge1xyXG4gICAgICAgIGlmIChhbGxvd0luV29yZHMuaW5kZXhPZihzZXApID49IDApIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNvdXJjZSArPSAnXFxcXCcgKyBzZXA7XHJcbiAgICB9XHJcbiAgICBzb3VyY2UgKz0gJ1xcXFxzXSspJztcclxuICAgIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZSwgJ2cnKTtcclxufVxyXG4vLyBjYXRjaGVzIG51bWJlcnMgKGluY2x1ZGluZyBmbG9hdGluZyBudW1iZXJzKSBpbiB0aGUgZmlyc3QgZ3JvdXAsIGFuZCBhbHBoYW51bSBpbiB0aGUgc2Vjb25kXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1dPUkRfUkVHRVhQID0gY3JlYXRlV29yZFJlZ0V4cCgpO1xyXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlVmFsaWRXb3JkRGVmaW5pdGlvbih3b3JkRGVmaW5pdGlvbikge1xyXG4gICAgbGV0IHJlc3VsdCA9IERFRkFVTFRfV09SRF9SRUdFWFA7XHJcbiAgICBpZiAod29yZERlZmluaXRpb24gJiYgKHdvcmREZWZpbml0aW9uIGluc3RhbmNlb2YgUmVnRXhwKSkge1xyXG4gICAgICAgIGlmICghd29yZERlZmluaXRpb24uZ2xvYmFsKSB7XHJcbiAgICAgICAgICAgIGxldCBmbGFncyA9ICdnJztcclxuICAgICAgICAgICAgaWYgKHdvcmREZWZpbml0aW9uLmlnbm9yZUNhc2UpIHtcclxuICAgICAgICAgICAgICAgIGZsYWdzICs9ICdpJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAod29yZERlZmluaXRpb24ubXVsdGlsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICBmbGFncyArPSAnbSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHdvcmREZWZpbml0aW9uLnVuaWNvZGUpIHtcclxuICAgICAgICAgICAgICAgIGZsYWdzICs9ICd1JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgUmVnRXhwKHdvcmREZWZpbml0aW9uLnNvdXJjZSwgZmxhZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gd29yZERlZmluaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzdWx0Lmxhc3RJbmRleCA9IDA7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmNvbnN0IF9kZWZhdWx0Q29uZmlnID0ge1xyXG4gICAgbWF4TGVuOiAxMDAwLFxyXG4gICAgd2luZG93U2l6ZTogMTUsXHJcbiAgICB0aW1lQnVkZ2V0OiAxNTBcclxufTtcclxuZXhwb3J0IGZ1bmN0aW9uIGdldFdvcmRBdFRleHQoY29sdW1uLCB3b3JkRGVmaW5pdGlvbiwgdGV4dCwgdGV4dE9mZnNldCwgY29uZmlnID0gX2RlZmF1bHRDb25maWcpIHtcclxuICAgIGlmICh0ZXh0Lmxlbmd0aCA+IGNvbmZpZy5tYXhMZW4pIHtcclxuICAgICAgICAvLyBkb24ndCB0aHJvdyBzdHJpbmdzIHRoYXQgbG9uZyBhdCB0aGUgcmVnZXhwXHJcbiAgICAgICAgLy8gYnV0IHVzZSBhIHN1Yi1zdHJpbmcgaW4gd2hpY2ggYSB3b3JkIG11c3Qgb2NjdXJcclxuICAgICAgICBsZXQgc3RhcnQgPSBjb2x1bW4gLSBjb25maWcubWF4TGVuIC8gMjtcclxuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XHJcbiAgICAgICAgICAgIHRleHRPZmZzZXQgKz0gY29sdW1uO1xyXG4gICAgICAgICAgICBzdGFydCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ICs9IHN0YXJ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoc3RhcnQsIGNvbHVtbiArIGNvbmZpZy5tYXhMZW4gLyAyKTtcclxuICAgICAgICByZXR1cm4gZ2V0V29yZEF0VGV4dChjb2x1bW4sIHdvcmREZWZpbml0aW9uLCB0ZXh0LCB0ZXh0T2Zmc2V0LCBjb25maWcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdDEgPSBEYXRlLm5vdygpO1xyXG4gICAgY29uc3QgcG9zID0gY29sdW1uIC0gMSAtIHRleHRPZmZzZXQ7XHJcbiAgICBsZXQgcHJldlJlZ2V4SW5kZXggPSAtMTtcclxuICAgIGxldCBtYXRjaCA9IG51bGw7XHJcbiAgICBmb3IgKGxldCBpID0gMTs7IGkrKykge1xyXG4gICAgICAgIC8vIGNoZWNrIHRpbWUgYnVkZ2V0XHJcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSB0MSA+PSBjb25maWcudGltZUJ1ZGdldCkge1xyXG4gICAgICAgICAgICAvLyBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVzZXQgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSByZWdleHAgc2hvdWxkIHN0YXJ0IG1hdGNoaW5nLCBhbHNvIGtub3cgd2hlcmUgaXRcclxuICAgICAgICAvLyBzaG91bGQgc3RvcCBzbyB0aGF0IHN1YnNlcXVlbnQgc2VhcmNoIGRvbid0IHJlcGVhdCBwcmV2aW91cyBzZWFyY2hlc1xyXG4gICAgICAgIGNvbnN0IHJlZ2V4SW5kZXggPSBwb3MgLSBjb25maWcud2luZG93U2l6ZSAqIGk7XHJcbiAgICAgICAgd29yZERlZmluaXRpb24ubGFzdEluZGV4ID0gTWF0aC5tYXgoMCwgcmVnZXhJbmRleCk7XHJcbiAgICAgICAgY29uc3QgdGhpc01hdGNoID0gX2ZpbmRSZWdleE1hdGNoRW5jbG9zaW5nUG9zaXRpb24od29yZERlZmluaXRpb24sIHRleHQsIHBvcywgcHJldlJlZ2V4SW5kZXgpO1xyXG4gICAgICAgIGlmICghdGhpc01hdGNoICYmIG1hdGNoKSB7XHJcbiAgICAgICAgICAgIC8vIHN0b3A6IHdlIGhhdmUgc29tZXRoaW5nXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXRjaCA9IHRoaXNNYXRjaDtcclxuICAgICAgICAvLyBzdG9wOiBzZWFyY2hlZCBhdCBzdGFydFxyXG4gICAgICAgIGlmIChyZWdleEluZGV4IDw9IDApIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXZSZWdleEluZGV4ID0gcmVnZXhJbmRleDtcclxuICAgIH1cclxuICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIHdvcmQ6IG1hdGNoWzBdLFxyXG4gICAgICAgICAgICBzdGFydENvbHVtbjogdGV4dE9mZnNldCArIDEgKyBtYXRjaC5pbmRleCxcclxuICAgICAgICAgICAgZW5kQ29sdW1uOiB0ZXh0T2Zmc2V0ICsgMSArIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoXHJcbiAgICAgICAgfTtcclxuICAgICAgICB3b3JkRGVmaW5pdGlvbi5sYXN0SW5kZXggPSAwO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBfZmluZFJlZ2V4TWF0Y2hFbmNsb3NpbmdQb3NpdGlvbih3b3JkRGVmaW5pdGlvbiwgdGV4dCwgcG9zLCBzdG9wUG9zKSB7XHJcbiAgICBsZXQgbWF0Y2g7XHJcbiAgICB3aGlsZSAobWF0Y2ggPSB3b3JkRGVmaW5pdGlvbi5leGVjKHRleHQpKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2hJbmRleCA9IG1hdGNoLmluZGV4IHx8IDA7XHJcbiAgICAgICAgaWYgKG1hdGNoSW5kZXggPD0gcG9zICYmIHdvcmREZWZpbml0aW9uLmxhc3RJbmRleCA+PSBwb3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdG9wUG9zID4gMCAmJiBtYXRjaEluZGV4ID4gc3RvcFBvcykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgQ2hhcmFjdGVyQ2xhc3NpZmllciB9IGZyb20gJy4uL2NvcmUvY2hhcmFjdGVyQ2xhc3NpZmllci5qcyc7XHJcbmV4cG9ydCBjbGFzcyBVaW50OE1hdHJpeCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihyb3dzLCBjb2xzLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkocm93cyAqIGNvbHMpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSByb3dzICogY29sczsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRhdGFbaV0gPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMucm93cyA9IHJvd3M7XHJcbiAgICAgICAgdGhpcy5jb2xzID0gY29scztcclxuICAgIH1cclxuICAgIGdldChyb3csIGNvbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhW3JvdyAqIHRoaXMuY29scyArIGNvbF07XHJcbiAgICB9XHJcbiAgICBzZXQocm93LCBjb2wsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fZGF0YVtyb3cgKiB0aGlzLmNvbHMgKyBjb2xdID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIFN0YXRlTWFjaGluZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihlZGdlcykge1xyXG4gICAgICAgIGxldCBtYXhDaGFyQ29kZSA9IDA7XHJcbiAgICAgICAgbGV0IG1heFN0YXRlID0gMCAvKiBJbnZhbGlkICovO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBlZGdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgW2Zyb20sIGNoQ29kZSwgdG9dID0gZWRnZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChjaENvZGUgPiBtYXhDaGFyQ29kZSkge1xyXG4gICAgICAgICAgICAgICAgbWF4Q2hhckNvZGUgPSBjaENvZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZyb20gPiBtYXhTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgbWF4U3RhdGUgPSBmcm9tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0byA+IG1heFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhTdGF0ZSA9IHRvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1heENoYXJDb2RlKys7XHJcbiAgICAgICAgbWF4U3RhdGUrKztcclxuICAgICAgICBsZXQgc3RhdGVzID0gbmV3IFVpbnQ4TWF0cml4KG1heFN0YXRlLCBtYXhDaGFyQ29kZSwgMCAvKiBJbnZhbGlkICovKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZWRnZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IFtmcm9tLCBjaENvZGUsIHRvXSA9IGVkZ2VzW2ldO1xyXG4gICAgICAgICAgICBzdGF0ZXMuc2V0KGZyb20sIGNoQ29kZSwgdG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zdGF0ZXMgPSBzdGF0ZXM7XHJcbiAgICAgICAgdGhpcy5fbWF4Q2hhckNvZGUgPSBtYXhDaGFyQ29kZTtcclxuICAgIH1cclxuICAgIG5leHRTdGF0ZShjdXJyZW50U3RhdGUsIGNoQ29kZSkge1xyXG4gICAgICAgIGlmIChjaENvZGUgPCAwIHx8IGNoQ29kZSA+PSB0aGlzLl9tYXhDaGFyQ29kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMCAvKiBJbnZhbGlkICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVzLmdldChjdXJyZW50U3RhdGUsIGNoQ29kZSk7XHJcbiAgICB9XHJcbn1cclxuLy8gU3RhdGUgbWFjaGluZSBmb3IgaHR0cDovLyBvciBodHRwczovLyBvciBmaWxlOi8vXHJcbmxldCBfc3RhdGVNYWNoaW5lID0gbnVsbDtcclxuZnVuY3Rpb24gZ2V0U3RhdGVNYWNoaW5lKCkge1xyXG4gICAgaWYgKF9zdGF0ZU1hY2hpbmUgPT09IG51bGwpIHtcclxuICAgICAgICBfc3RhdGVNYWNoaW5lID0gbmV3IFN0YXRlTWFjaGluZShbXHJcbiAgICAgICAgICAgIFsxIC8qIFN0YXJ0ICovLCAxMDQgLyogaCAqLywgMiAvKiBIICovXSxcclxuICAgICAgICAgICAgWzEgLyogU3RhcnQgKi8sIDcyIC8qIEggKi8sIDIgLyogSCAqL10sXHJcbiAgICAgICAgICAgIFsxIC8qIFN0YXJ0ICovLCAxMDIgLyogZiAqLywgNiAvKiBGICovXSxcclxuICAgICAgICAgICAgWzEgLyogU3RhcnQgKi8sIDcwIC8qIEYgKi8sIDYgLyogRiAqL10sXHJcbiAgICAgICAgICAgIFsyIC8qIEggKi8sIDExNiAvKiB0ICovLCAzIC8qIEhUICovXSxcclxuICAgICAgICAgICAgWzIgLyogSCAqLywgODQgLyogVCAqLywgMyAvKiBIVCAqL10sXHJcbiAgICAgICAgICAgIFszIC8qIEhUICovLCAxMTYgLyogdCAqLywgNCAvKiBIVFQgKi9dLFxyXG4gICAgICAgICAgICBbMyAvKiBIVCAqLywgODQgLyogVCAqLywgNCAvKiBIVFQgKi9dLFxyXG4gICAgICAgICAgICBbNCAvKiBIVFQgKi8sIDExMiAvKiBwICovLCA1IC8qIEhUVFAgKi9dLFxyXG4gICAgICAgICAgICBbNCAvKiBIVFQgKi8sIDgwIC8qIFAgKi8sIDUgLyogSFRUUCAqL10sXHJcbiAgICAgICAgICAgIFs1IC8qIEhUVFAgKi8sIDExNSAvKiBzICovLCA5IC8qIEJlZm9yZUNvbG9uICovXSxcclxuICAgICAgICAgICAgWzUgLyogSFRUUCAqLywgODMgLyogUyAqLywgOSAvKiBCZWZvcmVDb2xvbiAqL10sXHJcbiAgICAgICAgICAgIFs1IC8qIEhUVFAgKi8sIDU4IC8qIENvbG9uICovLCAxMCAvKiBBZnRlckNvbG9uICovXSxcclxuICAgICAgICAgICAgWzYgLyogRiAqLywgMTA1IC8qIGkgKi8sIDcgLyogRkkgKi9dLFxyXG4gICAgICAgICAgICBbNiAvKiBGICovLCA3MyAvKiBJICovLCA3IC8qIEZJICovXSxcclxuICAgICAgICAgICAgWzcgLyogRkkgKi8sIDEwOCAvKiBsICovLCA4IC8qIEZJTCAqL10sXHJcbiAgICAgICAgICAgIFs3IC8qIEZJICovLCA3NiAvKiBMICovLCA4IC8qIEZJTCAqL10sXHJcbiAgICAgICAgICAgIFs4IC8qIEZJTCAqLywgMTAxIC8qIGUgKi8sIDkgLyogQmVmb3JlQ29sb24gKi9dLFxyXG4gICAgICAgICAgICBbOCAvKiBGSUwgKi8sIDY5IC8qIEUgKi8sIDkgLyogQmVmb3JlQ29sb24gKi9dLFxyXG4gICAgICAgICAgICBbOSAvKiBCZWZvcmVDb2xvbiAqLywgNTggLyogQ29sb24gKi8sIDEwIC8qIEFmdGVyQ29sb24gKi9dLFxyXG4gICAgICAgICAgICBbMTAgLyogQWZ0ZXJDb2xvbiAqLywgNDcgLyogU2xhc2ggKi8sIDExIC8qIEFsbW9zdFRoZXJlICovXSxcclxuICAgICAgICAgICAgWzExIC8qIEFsbW9zdFRoZXJlICovLCA0NyAvKiBTbGFzaCAqLywgMTIgLyogRW5kICovXSxcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBfc3RhdGVNYWNoaW5lO1xyXG59XHJcbmxldCBfY2xhc3NpZmllciA9IG51bGw7XHJcbmZ1bmN0aW9uIGdldENsYXNzaWZpZXIoKSB7XHJcbiAgICBpZiAoX2NsYXNzaWZpZXIgPT09IG51bGwpIHtcclxuICAgICAgICBfY2xhc3NpZmllciA9IG5ldyBDaGFyYWN0ZXJDbGFzc2lmaWVyKDAgLyogTm9uZSAqLyk7XHJcbiAgICAgICAgY29uc3QgRk9SQ0VfVEVSTUlOQVRJT05fQ0hBUkFDVEVSUyA9ICcgXFx0PD5cXCdcXFwi44CB44CC772h772k77yM77yO77ya77yb4oCY4oCc44CI44CK44CM44CO44CQ44CU77yI77y7772b772i772j772d77y977yJ44CV44CR44CP44CN44CL44CJ4oCd4oCZ772A772e4oCmJztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEZPUkNFX1RFUk1JTkFUSU9OX0NIQVJBQ1RFUlMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgX2NsYXNzaWZpZXIuc2V0KEZPUkNFX1RFUk1JTkFUSU9OX0NIQVJBQ1RFUlMuY2hhckNvZGVBdChpKSwgMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgQ0FOTk9UX0VORF9XSVRIX0NIQVJBQ1RFUlMgPSAnLiw7JztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENBTk5PVF9FTkRfV0lUSF9DSEFSQUNURVJTLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIF9jbGFzc2lmaWVyLnNldChDQU5OT1RfRU5EX1dJVEhfQ0hBUkFDVEVSUy5jaGFyQ29kZUF0KGkpLCAyIC8qIENhbm5vdEVuZEluICovKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2NsYXNzaWZpZXI7XHJcbn1cclxuZXhwb3J0IGNsYXNzIExpbmtDb21wdXRlciB7XHJcbiAgICBzdGF0aWMgX2NyZWF0ZUxpbmsoY2xhc3NpZmllciwgbGluZSwgbGluZU51bWJlciwgbGlua0JlZ2luSW5kZXgsIGxpbmtFbmRJbmRleCkge1xyXG4gICAgICAgIC8vIERvIG5vdCBhbGxvdyB0byBlbmQgbGluayBpbiBjZXJ0YWluIGNoYXJhY3RlcnMuLi5cclxuICAgICAgICBsZXQgbGFzdEluY2x1ZGVkQ2hhckluZGV4ID0gbGlua0VuZEluZGV4IC0gMTtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoQ29kZSA9IGxpbmUuY2hhckNvZGVBdChsYXN0SW5jbHVkZWRDaGFySW5kZXgpO1xyXG4gICAgICAgICAgICBjb25zdCBjaENsYXNzID0gY2xhc3NpZmllci5nZXQoY2hDb2RlKTtcclxuICAgICAgICAgICAgaWYgKGNoQ2xhc3MgIT09IDIgLyogQ2Fubm90RW5kSW4gKi8pIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhc3RJbmNsdWRlZENoYXJJbmRleC0tO1xyXG4gICAgICAgIH0gd2hpbGUgKGxhc3RJbmNsdWRlZENoYXJJbmRleCA+IGxpbmtCZWdpbkluZGV4KTtcclxuICAgICAgICAvLyBIYW5kbGUgbGlua3MgZW5jbG9zZWQgaW4gcGFyZW5zLCBzcXVhcmUgYnJhY2tldHMgYW5kIGN1cmx5cy5cclxuICAgICAgICBpZiAobGlua0JlZ2luSW5kZXggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYXJDb2RlQmVmb3JlTGluayA9IGxpbmUuY2hhckNvZGVBdChsaW5rQmVnaW5JbmRleCAtIDEpO1xyXG4gICAgICAgICAgICBjb25zdCBsYXN0Q2hhckNvZGVJbkxpbmsgPSBsaW5lLmNoYXJDb2RlQXQobGFzdEluY2x1ZGVkQ2hhckluZGV4KTtcclxuICAgICAgICAgICAgaWYgKChjaGFyQ29kZUJlZm9yZUxpbmsgPT09IDQwIC8qIE9wZW5QYXJlbiAqLyAmJiBsYXN0Q2hhckNvZGVJbkxpbmsgPT09IDQxIC8qIENsb3NlUGFyZW4gKi8pXHJcbiAgICAgICAgICAgICAgICB8fCAoY2hhckNvZGVCZWZvcmVMaW5rID09PSA5MSAvKiBPcGVuU3F1YXJlQnJhY2tldCAqLyAmJiBsYXN0Q2hhckNvZGVJbkxpbmsgPT09IDkzIC8qIENsb3NlU3F1YXJlQnJhY2tldCAqLylcclxuICAgICAgICAgICAgICAgIHx8IChjaGFyQ29kZUJlZm9yZUxpbmsgPT09IDEyMyAvKiBPcGVuQ3VybHlCcmFjZSAqLyAmJiBsYXN0Q2hhckNvZGVJbkxpbmsgPT09IDEyNSAvKiBDbG9zZUN1cmx5QnJhY2UgKi8pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgZW5kIGluICkgaWYgKCBpcyBiZWZvcmUgdGhlIGxpbmsgc3RhcnRcclxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBlbmQgaW4gXSBpZiBbIGlzIGJlZm9yZSB0aGUgbGluayBzdGFydFxyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGVuZCBpbiB9IGlmIHsgaXMgYmVmb3JlIHRoZSBsaW5rIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICBsYXN0SW5jbHVkZWRDaGFySW5kZXgtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByYW5nZToge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRDb2x1bW46IGxpbmtCZWdpbkluZGV4ICsgMSxcclxuICAgICAgICAgICAgICAgIGVuZExpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW46IGxhc3RJbmNsdWRlZENoYXJJbmRleCArIDJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXJsOiBsaW5lLnN1YnN0cmluZyhsaW5rQmVnaW5JbmRleCwgbGFzdEluY2x1ZGVkQ2hhckluZGV4ICsgMSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNvbXB1dGVMaW5rcyhtb2RlbCwgc3RhdGVNYWNoaW5lID0gZ2V0U3RhdGVNYWNoaW5lKCkpIHtcclxuICAgICAgICBjb25zdCBjbGFzc2lmaWVyID0gZ2V0Q2xhc3NpZmllcigpO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMSwgbGluZUNvdW50ID0gbW9kZWwuZ2V0TGluZUNvdW50KCk7IGkgPD0gbGluZUNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbGluZSA9IG1vZGVsLmdldExpbmVDb250ZW50KGkpO1xyXG4gICAgICAgICAgICBjb25zdCBsZW4gPSBsaW5lLmxlbmd0aDtcclxuICAgICAgICAgICAgbGV0IGogPSAwO1xyXG4gICAgICAgICAgICBsZXQgbGlua0JlZ2luSW5kZXggPSAwO1xyXG4gICAgICAgICAgICBsZXQgbGlua0JlZ2luQ2hDb2RlID0gMDtcclxuICAgICAgICAgICAgbGV0IHN0YXRlID0gMSAvKiBTdGFydCAqLztcclxuICAgICAgICAgICAgbGV0IGhhc09wZW5QYXJlbnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IGhhc09wZW5TcXVhcmVCcmFja2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBpblNxdWFyZUJyYWNrZXRzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBoYXNPcGVuQ3VybHlCcmFja2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzZXRTdGF0ZU1hY2hpbmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoQ29kZSA9IGxpbmUuY2hhckNvZGVBdChqKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMTMgLyogQWNjZXB0ICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoQ2xhc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaENvZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MCAvKiBPcGVuUGFyZW4gKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNPcGVuUGFyZW5zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAwIC8qIE5vbmUgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MSAvKiBDbG9zZVBhcmVuICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChoYXNPcGVuUGFyZW5zID8gMCAvKiBOb25lICovIDogMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkxIC8qIE9wZW5TcXVhcmVCcmFja2V0ICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5TcXVhcmVCcmFja2V0cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNPcGVuU3F1YXJlQnJhY2tldCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gMCAvKiBOb25lICovO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTMgLyogQ2xvc2VTcXVhcmVCcmFja2V0ICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5TcXVhcmVCcmFja2V0cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChoYXNPcGVuU3F1YXJlQnJhY2tldCA/IDAgLyogTm9uZSAqLyA6IDEgLyogRm9yY2VUZXJtaW5hdGlvbiAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjMgLyogT3BlbkN1cmx5QnJhY2UgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNPcGVuQ3VybHlCcmFja2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAwIC8qIE5vbmUgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjUgLyogQ2xvc2VDdXJseUJyYWNlICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChoYXNPcGVuQ3VybHlCcmFja2V0ID8gMCAvKiBOb25lICovIDogMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBUaGUgZm9sbG93aW5nIHRocmVlIHJ1bGVzIG1ha2UgaXQgdGhhdCAnIG9yIFwiIG9yIGAgYXJlIGFsbG93ZWQgaW5zaWRlIGxpbmtzIGlmIHRoZSBsaW5rIGJlZ2FuIHdpdGggYSBkaWZmZXJlbnQgb25lICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzkgLyogU2luZ2xlUXVvdGUgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gKGxpbmtCZWdpbkNoQ29kZSA9PT0gMzQgLyogRG91YmxlUXVvdGUgKi8gfHwgbGlua0JlZ2luQ2hDb2RlID09PSA5NiAvKiBCYWNrVGljayAqLykgPyAwIC8qIE5vbmUgKi8gOiAxIC8qIEZvcmNlVGVybWluYXRpb24gKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNCAvKiBEb3VibGVRdW90ZSAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAobGlua0JlZ2luQ2hDb2RlID09PSAzOSAvKiBTaW5nbGVRdW90ZSAqLyB8fCBsaW5rQmVnaW5DaENvZGUgPT09IDk2IC8qIEJhY2tUaWNrICovKSA/IDAgLyogTm9uZSAqLyA6IDEgLyogRm9yY2VUZXJtaW5hdGlvbiAqLztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk2IC8qIEJhY2tUaWNrICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChsaW5rQmVnaW5DaENvZGUgPT09IDM5IC8qIFNpbmdsZVF1b3RlICovIHx8IGxpbmtCZWdpbkNoQ29kZSA9PT0gMzQgLyogRG91YmxlUXVvdGUgKi8pID8gMCAvKiBOb25lICovIDogMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDIgLyogQXN0ZXJpc2sgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBgKmAgdGVybWluYXRlcyBhIGxpbmsgaWYgdGhlIGxpbmsgYmVnYW4gd2l0aCBgKmBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAobGlua0JlZ2luQ2hDb2RlID09PSA0MiAvKiBBc3RlcmlzayAqLykgPyAxIC8qIEZvcmNlVGVybWluYXRpb24gKi8gOiAwIC8qIE5vbmUgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjQgLyogUGlwZSAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGB8YCB0ZXJtaW5hdGVzIGEgbGluayBpZiB0aGUgbGluayBiZWdhbiB3aXRoIGB8YFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChsaW5rQmVnaW5DaENvZGUgPT09IDEyNCAvKiBQaXBlICovKSA/IDEgLyogRm9yY2VUZXJtaW5hdGlvbiAqLyA6IDAgLyogTm9uZSAqLztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDMyIC8qIFNwYWNlICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYCBgIGFsbG93IHNwYWNlIGluIGJldHdlZW4gWyBhbmQgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChpblNxdWFyZUJyYWNrZXRzID8gMCAvKiBOb25lICovIDogMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IGNsYXNzaWZpZXIuZ2V0KGNoQ29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGNoYXJhY3RlciB0ZXJtaW5hdGVzIGxpbmtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hDbGFzcyA9PT0gMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKExpbmtDb21wdXRlci5fY3JlYXRlTGluayhjbGFzc2lmaWVyLCBsaW5lLCBpLCBsaW5rQmVnaW5JbmRleCwgaikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFN0YXRlTWFjaGluZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09IDEyIC8qIEVuZCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjaENsYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaENvZGUgPT09IDkxIC8qIE9wZW5TcXVhcmVCcmFja2V0ICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGZvciB0aGUgYXV0aG9yaXR5IHBhcnQgdG8gY29udGFpbiBpcHY2IGFkZHJlc3NlcyB3aGljaCBjb250YWluIFsgYW5kIF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3BlblNxdWFyZUJyYWNrZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gMCAvKiBOb25lICovO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IGNsYXNzaWZpZXIuZ2V0KGNoQ29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGNoYXJhY3RlciB0ZXJtaW5hdGVzIGxpbmtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hDbGFzcyA9PT0gMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0U3RhdGVNYWNoaW5lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMTMgLyogQWNjZXB0ICovO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGVNYWNoaW5lLm5leHRTdGF0ZShzdGF0ZSwgY2hDb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IDAgLyogSW52YWxpZCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFN0YXRlTWFjaGluZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc2V0U3RhdGVNYWNoaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxIC8qIFN0YXJ0ICovO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc09wZW5QYXJlbnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNPcGVuU3F1YXJlQnJhY2tldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc09wZW5DdXJseUJyYWNrZXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZWNvcmQgd2hlcmUgdGhlIGxpbmsgc3RhcnRlZFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmtCZWdpbkluZGV4ID0gaiArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlua0JlZ2luQ2hDb2RlID0gY2hDb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMTMgLyogQWNjZXB0ICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChMaW5rQ29tcHV0ZXIuX2NyZWF0ZUxpbmsoY2xhc3NpZmllciwgbGluZSwgaSwgbGlua0JlZ2luSW5kZXgsIGxlbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGxpbmtzIGNvbnRhaW5zIGluIHRoZSBwcm92aWRlZFxyXG4gKiBkb2N1bWVudC4gKk5vdGUqIHRoYXQgdGhpcyBvcGVyYXRpb24gaXMgY29tcHV0YXRpb25hbFxyXG4gKiBleHBlbnNpdmUgYW5kIHNob3VsZCBub3QgcnVuIGluIHRoZSBVSSB0aHJlYWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUxpbmtzKG1vZGVsKSB7XHJcbiAgICBpZiAoIW1vZGVsIHx8IHR5cGVvZiBtb2RlbC5nZXRMaW5lQ291bnQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG1vZGVsLmdldExpbmVDb250ZW50ICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gVW5rbm93biBjYWxsZXIhXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIExpbmtDb21wdXRlci5jb21wdXRlTGlua3MobW9kZWwpO1xyXG59XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5leHBvcnQgY2xhc3MgQmFzaWNJbnBsYWNlUmVwbGFjZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWVTZXQgPSBbXHJcbiAgICAgICAgICAgIFsndHJ1ZScsICdmYWxzZSddLFxyXG4gICAgICAgICAgICBbJ1RydWUnLCAnRmFsc2UnXSxcclxuICAgICAgICAgICAgWydQcml2YXRlJywgJ1B1YmxpYycsICdGcmllbmQnLCAnUmVhZE9ubHknLCAnUGFydGlhbCcsICdQcm90ZWN0ZWQnLCAnV3JpdGVPbmx5J10sXHJcbiAgICAgICAgICAgIFsncHVibGljJywgJ3Byb3RlY3RlZCcsICdwcml2YXRlJ10sXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIG5hdmlnYXRlVmFsdWVTZXQocmFuZ2UxLCB0ZXh0MSwgcmFuZ2UyLCB0ZXh0MiwgdXApIHtcclxuICAgICAgICBpZiAocmFuZ2UxICYmIHRleHQxKSB7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmRvTmF2aWdhdGVWYWx1ZVNldCh0ZXh0MSwgdXApO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZTEsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmFuZ2UyICYmIHRleHQyKSB7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmRvTmF2aWdhdGVWYWx1ZVNldCh0ZXh0MiwgdXApO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZTIsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGRvTmF2aWdhdGVWYWx1ZVNldCh0ZXh0LCB1cCkge1xyXG4gICAgICAgIGxldCBudW1iZXJSZXN1bHQgPSB0aGlzLm51bWJlclJlcGxhY2UodGV4dCwgdXApO1xyXG4gICAgICAgIGlmIChudW1iZXJSZXN1bHQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlclJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dFJlcGxhY2UodGV4dCwgdXApO1xyXG4gICAgfVxyXG4gICAgbnVtYmVyUmVwbGFjZSh2YWx1ZSwgdXApIHtcclxuICAgICAgICBsZXQgcHJlY2lzaW9uID0gTWF0aC5wb3coMTAsIHZhbHVlLmxlbmd0aCAtICh2YWx1ZS5sYXN0SW5kZXhPZignLicpICsgMSkpO1xyXG4gICAgICAgIGxldCBuMSA9IE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgbGV0IG4yID0gcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKCFpc05hTihuMSkgJiYgIWlzTmFOKG4yKSAmJiBuMSA9PT0gbjIpIHtcclxuICAgICAgICAgICAgaWYgKG4xID09PSAwICYmICF1cCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvbid0IGRvIG5lZ2F0aXZlXHJcbiAgICAgICAgICAgICAgICAvL1x0XHRcdH0gZWxzZSBpZihuMSA9PT0gOSAmJiB1cCkge1xyXG4gICAgICAgICAgICAgICAgLy9cdFx0XHRcdHJldHVybiBudWxsOyAvLyBkb24ndCBpbnNlcnQgMTAgaW50byBhIG51bWJlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbjEgPSBNYXRoLmZsb29yKG4xICogcHJlY2lzaW9uKTtcclxuICAgICAgICAgICAgICAgIG4xICs9IHVwID8gcHJlY2lzaW9uIDogLXByZWNpc2lvbjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcobjEgLyBwcmVjaXNpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgdGV4dFJlcGxhY2UodmFsdWUsIHVwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVTZXRzUmVwbGFjZSh0aGlzLl9kZWZhdWx0VmFsdWVTZXQsIHZhbHVlLCB1cCk7XHJcbiAgICB9XHJcbiAgICB2YWx1ZVNldHNSZXBsYWNlKHZhbHVlU2V0cywgdmFsdWUsIHVwKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbHVlU2V0cy5sZW5ndGg7IHJlc3VsdCA9PT0gbnVsbCAmJiBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy52YWx1ZVNldFJlcGxhY2UodmFsdWVTZXRzW2ldLCB2YWx1ZSwgdXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgdmFsdWVTZXRSZXBsYWNlKHZhbHVlU2V0LCB2YWx1ZSwgdXApIHtcclxuICAgICAgICBsZXQgaWR4ID0gdmFsdWVTZXQuaW5kZXhPZih2YWx1ZSk7XHJcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XHJcbiAgICAgICAgICAgIGlkeCArPSB1cCA/ICsxIDogLTE7XHJcbiAgICAgICAgICAgIGlmIChpZHggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZHggPSB2YWx1ZVNldC5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWR4ICU9IHZhbHVlU2V0Lmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVTZXRbaWR4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuQmFzaWNJbnBsYWNlUmVwbGFjZS5JTlNUQU5DRSA9IG5ldyBCYXNpY0lucGxhY2VSZXBsYWNlKCk7XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbmltcG9ydCB7IG1lcmdlU29ydCB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2FycmF5cy5qcyc7XHJcbmltcG9ydCB7IHN0cmluZ0RpZmYgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9kaWZmL2RpZmYuanMnO1xyXG5pbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vcGxhdGZvcm0uanMnO1xyXG5pbXBvcnQgeyBVUkkgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi91cmkuanMnO1xyXG5pbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gJy4uL2NvcmUvcG9zaXRpb24uanMnO1xyXG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4uL2NvcmUvcmFuZ2UuanMnO1xyXG5pbXBvcnQgeyBEaWZmQ29tcHV0ZXIgfSBmcm9tICcuLi9kaWZmL2RpZmZDb21wdXRlci5qcyc7XHJcbmltcG9ydCB7IE1pcnJvclRleHRNb2RlbCBhcyBCYXNlTWlycm9yTW9kZWwgfSBmcm9tICcuLi9tb2RlbC9taXJyb3JUZXh0TW9kZWwuanMnO1xyXG5pbXBvcnQgeyBlbnN1cmVWYWxpZFdvcmREZWZpbml0aW9uLCBnZXRXb3JkQXRUZXh0IH0gZnJvbSAnLi4vbW9kZWwvd29yZEhlbHBlci5qcyc7XHJcbmltcG9ydCB7IGNvbXB1dGVMaW5rcyB9IGZyb20gJy4uL21vZGVzL2xpbmtDb21wdXRlci5qcyc7XHJcbmltcG9ydCB7IEJhc2ljSW5wbGFjZVJlcGxhY2UgfSBmcm9tICcuLi9tb2Rlcy9zdXBwb3J0cy9pbnBsYWNlUmVwbGFjZVN1cHBvcnQuanMnO1xyXG5pbXBvcnQgeyBjcmVhdGVNb25hY29CYXNlQVBJIH0gZnJvbSAnLi4vc3RhbmRhbG9uZS9zdGFuZGFsb25lQmFzZS5qcyc7XHJcbmltcG9ydCAqIGFzIHR5cGVzIGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3R5cGVzLmpzJztcclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgTWlycm9yTW9kZWwgZXh0ZW5kcyBCYXNlTWlycm9yTW9kZWwge1xyXG4gICAgZ2V0IHVyaSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZlcnNpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnNpb25JZDtcclxuICAgIH1cclxuICAgIGdldCBlb2woKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VvbDtcclxuICAgIH1cclxuICAgIGdldFZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFRleHQoKTtcclxuICAgIH1cclxuICAgIGdldExpbmVzQ29udGVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZXMuc2xpY2UoMCk7XHJcbiAgICB9XHJcbiAgICBnZXRMaW5lQ291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGdldExpbmVDb250ZW50KGxpbmVOdW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZXNbbGluZU51bWJlciAtIDFdO1xyXG4gICAgfVxyXG4gICAgZ2V0V29yZEF0UG9zaXRpb24ocG9zaXRpb24sIHdvcmREZWZpbml0aW9uKSB7XHJcbiAgICAgICAgbGV0IHdvcmRBdFRleHQgPSBnZXRXb3JkQXRUZXh0KHBvc2l0aW9uLmNvbHVtbiwgZW5zdXJlVmFsaWRXb3JkRGVmaW5pdGlvbih3b3JkRGVmaW5pdGlvbiksIHRoaXMuX2xpbmVzW3Bvc2l0aW9uLmxpbmVOdW1iZXIgLSAxXSwgMCk7XHJcbiAgICAgICAgaWYgKHdvcmRBdFRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShwb3NpdGlvbi5saW5lTnVtYmVyLCB3b3JkQXRUZXh0LnN0YXJ0Q29sdW1uLCBwb3NpdGlvbi5saW5lTnVtYmVyLCB3b3JkQXRUZXh0LmVuZENvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgd29yZHMod29yZERlZmluaXRpb24pIHtcclxuICAgICAgICBjb25zdCBsaW5lcyA9IHRoaXMuX2xpbmVzO1xyXG4gICAgICAgIGNvbnN0IHdvcmRlbml6ZSA9IHRoaXMuX3dvcmRlbml6ZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIGxldCBsaW5lTnVtYmVyID0gMDtcclxuICAgICAgICBsZXQgbGluZVRleHQgPSAnJztcclxuICAgICAgICBsZXQgd29yZFJhbmdlc0lkeCA9IDA7XHJcbiAgICAgICAgbGV0IHdvcmRSYW5nZXMgPSBbXTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh3b3JkUmFuZ2VzSWR4IDwgd29yZFJhbmdlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBsaW5lVGV4dC5zdWJzdHJpbmcod29yZFJhbmdlc1t3b3JkUmFuZ2VzSWR4XS5zdGFydCwgd29yZFJhbmdlc1t3b3JkUmFuZ2VzSWR4XS5lbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JkUmFuZ2VzSWR4ICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVOdW1iZXIgPCBsaW5lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVUZXh0ID0gbGluZXNbbGluZU51bWJlcl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JkUmFuZ2VzID0gd29yZGVuaXplKGxpbmVUZXh0LCB3b3JkRGVmaW5pdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JkUmFuZ2VzSWR4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXIgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGdldExpbmVXb3JkcyhsaW5lTnVtYmVyLCB3b3JkRGVmaW5pdGlvbikge1xyXG4gICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5fbGluZXNbbGluZU51bWJlciAtIDFdO1xyXG4gICAgICAgIGxldCByYW5nZXMgPSB0aGlzLl93b3JkZW5pemUoY29udGVudCwgd29yZERlZmluaXRpb24pO1xyXG4gICAgICAgIGxldCB3b3JkcyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgcmFuZ2Ugb2YgcmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHdvcmRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgd29yZDogY29udGVudC5zdWJzdHJpbmcocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCksXHJcbiAgICAgICAgICAgICAgICBzdGFydENvbHVtbjogcmFuZ2Uuc3RhcnQgKyAxLFxyXG4gICAgICAgICAgICAgICAgZW5kQ29sdW1uOiByYW5nZS5lbmQgKyAxXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd29yZHM7XHJcbiAgICB9XHJcbiAgICBfd29yZGVuaXplKGNvbnRlbnQsIHdvcmREZWZpbml0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgbGV0IG1hdGNoO1xyXG4gICAgICAgIHdvcmREZWZpbml0aW9uLmxhc3RJbmRleCA9IDA7IC8vIHJlc2V0IGxhc3RJbmRleCBqdXN0IHRvIGJlIHN1cmVcclxuICAgICAgICB3aGlsZSAobWF0Y2ggPSB3b3JkRGVmaW5pdGlvbi5leGVjKGNvbnRlbnQpKSB7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaFswXS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIGl0IGRpZCBtYXRjaCB0aGUgZW1wdHkgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IHN0YXJ0OiBtYXRjaC5pbmRleCwgZW5kOiBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGdldFZhbHVlSW5SYW5nZShyYW5nZSkge1xyXG4gICAgICAgIHJhbmdlID0gdGhpcy5fdmFsaWRhdGVSYW5nZShyYW5nZSk7XHJcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcmFuZ2UuZW5kTGluZU51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGluZXNbcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKHJhbmdlLnN0YXJ0Q29sdW1uIC0gMSwgcmFuZ2UuZW5kQ29sdW1uIC0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBsaW5lRW5kaW5nID0gdGhpcy5fZW9sO1xyXG4gICAgICAgIGxldCBzdGFydExpbmVJbmRleCA9IHJhbmdlLnN0YXJ0TGluZU51bWJlciAtIDE7XHJcbiAgICAgICAgbGV0IGVuZExpbmVJbmRleCA9IHJhbmdlLmVuZExpbmVOdW1iZXIgLSAxO1xyXG4gICAgICAgIGxldCByZXN1bHRMaW5lcyA9IFtdO1xyXG4gICAgICAgIHJlc3VsdExpbmVzLnB1c2godGhpcy5fbGluZXNbc3RhcnRMaW5lSW5kZXhdLnN1YnN0cmluZyhyYW5nZS5zdGFydENvbHVtbiAtIDEpKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRMaW5lSW5kZXggKyAxOyBpIDwgZW5kTGluZUluZGV4OyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0TGluZXMucHVzaCh0aGlzLl9saW5lc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdExpbmVzLnB1c2godGhpcy5fbGluZXNbZW5kTGluZUluZGV4XS5zdWJzdHJpbmcoMCwgcmFuZ2UuZW5kQ29sdW1uIC0gMSkpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRMaW5lcy5qb2luKGxpbmVFbmRpbmcpO1xyXG4gICAgfVxyXG4gICAgb2Zmc2V0QXQocG9zaXRpb24pIHtcclxuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX3ZhbGlkYXRlUG9zaXRpb24ocG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUxpbmVTdGFydHMoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZVN0YXJ0cy5nZXRBY2N1bXVsYXRlZFZhbHVlKHBvc2l0aW9uLmxpbmVOdW1iZXIgLSAyKSArIChwb3NpdGlvbi5jb2x1bW4gLSAxKTtcclxuICAgIH1cclxuICAgIHBvc2l0aW9uQXQob2Zmc2V0KSB7XHJcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5mbG9vcihvZmZzZXQpO1xyXG4gICAgICAgIG9mZnNldCA9IE1hdGgubWF4KDAsIG9mZnNldCk7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlTGluZVN0YXJ0cygpO1xyXG4gICAgICAgIGxldCBvdXQgPSB0aGlzLl9saW5lU3RhcnRzLmdldEluZGV4T2Yob2Zmc2V0KTtcclxuICAgICAgICBsZXQgbGluZUxlbmd0aCA9IHRoaXMuX2xpbmVzW291dC5pbmRleF0ubGVuZ3RoO1xyXG4gICAgICAgIC8vIEVuc3VyZSB3ZSByZXR1cm4gYSB2YWxpZCBwb3NpdGlvblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IDEgKyBvdXQuaW5kZXgsXHJcbiAgICAgICAgICAgIGNvbHVtbjogMSArIE1hdGgubWluKG91dC5yZW1haW5kZXIsIGxpbmVMZW5ndGgpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIF92YWxpZGF0ZVJhbmdlKHJhbmdlKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl92YWxpZGF0ZVBvc2l0aW9uKHsgbGluZU51bWJlcjogcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCBjb2x1bW46IHJhbmdlLnN0YXJ0Q29sdW1uIH0pO1xyXG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX3ZhbGlkYXRlUG9zaXRpb24oeyBsaW5lTnVtYmVyOiByYW5nZS5lbmRMaW5lTnVtYmVyLCBjb2x1bW46IHJhbmdlLmVuZENvbHVtbiB9KTtcclxuICAgICAgICBpZiAoc3RhcnQubGluZU51bWJlciAhPT0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyXHJcbiAgICAgICAgICAgIHx8IHN0YXJ0LmNvbHVtbiAhPT0gcmFuZ2Uuc3RhcnRDb2x1bW5cclxuICAgICAgICAgICAgfHwgZW5kLmxpbmVOdW1iZXIgIT09IHJhbmdlLmVuZExpbmVOdW1iZXJcclxuICAgICAgICAgICAgfHwgZW5kLmNvbHVtbiAhPT0gcmFuZ2UuZW5kQ29sdW1uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzdGFydExpbmVOdW1iZXI6IHN0YXJ0LmxpbmVOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICBzdGFydENvbHVtbjogc3RhcnQuY29sdW1uLFxyXG4gICAgICAgICAgICAgICAgZW5kTGluZU51bWJlcjogZW5kLmxpbmVOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW46IGVuZC5jb2x1bW5cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xyXG4gICAgfVxyXG4gICAgX3ZhbGlkYXRlUG9zaXRpb24ocG9zaXRpb24pIHtcclxuICAgICAgICBpZiAoIVBvc2l0aW9uLmlzSVBvc2l0aW9uKHBvc2l0aW9uKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb3NpdGlvbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgeyBsaW5lTnVtYmVyLCBjb2x1bW4gfSA9IHBvc2l0aW9uO1xyXG4gICAgICAgIGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGxpbmVOdW1iZXIgPCAxKSB7XHJcbiAgICAgICAgICAgIGxpbmVOdW1iZXIgPSAxO1xyXG4gICAgICAgICAgICBjb2x1bW4gPSAxO1xyXG4gICAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGluZU51bWJlciA+IHRoaXMuX2xpbmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsaW5lTnVtYmVyID0gdGhpcy5fbGluZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb2x1bW4gPSB0aGlzLl9saW5lc1tsaW5lTnVtYmVyIC0gMV0ubGVuZ3RoICsgMTtcclxuICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgbWF4Q2hhcmFjdGVyID0gdGhpcy5fbGluZXNbbGluZU51bWJlciAtIDFdLmxlbmd0aCArIDE7XHJcbiAgICAgICAgICAgIGlmIChjb2x1bW4gPCAxKSB7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSAxO1xyXG4gICAgICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29sdW1uID4gbWF4Q2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBtYXhDaGFyYWN0ZXI7XHJcbiAgICAgICAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWhhc0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgbGluZU51bWJlciwgY29sdW1uIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmV4cG9ydCBjbGFzcyBFZGl0b3JTaW1wbGVXb3JrZXIge1xyXG4gICAgY29uc3RydWN0b3IoaG9zdCwgZm9yZWlnbk1vZHVsZUZhY3RvcnkpIHtcclxuICAgICAgICB0aGlzLl9ob3N0ID0gaG9zdDtcclxuICAgICAgICB0aGlzLl9tb2RlbHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgIHRoaXMuX2ZvcmVpZ25Nb2R1bGVGYWN0b3J5ID0gZm9yZWlnbk1vZHVsZUZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5fZm9yZWlnbk1vZHVsZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuX21vZGVscyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICB9XHJcbiAgICBfZ2V0TW9kZWwodXJpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGVsc1t1cmldO1xyXG4gICAgfVxyXG4gICAgX2dldE1vZGVscygpIHtcclxuICAgICAgICBsZXQgYWxsID0gW107XHJcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fbW9kZWxzKS5mb3JFYWNoKChrZXkpID0+IGFsbC5wdXNoKHRoaXMuX21vZGVsc1trZXldKSk7XHJcbiAgICAgICAgcmV0dXJuIGFsbDtcclxuICAgIH1cclxuICAgIGFjY2VwdE5ld01vZGVsKGRhdGEpIHtcclxuICAgICAgICB0aGlzLl9tb2RlbHNbZGF0YS51cmxdID0gbmV3IE1pcnJvck1vZGVsKFVSSS5wYXJzZShkYXRhLnVybCksIGRhdGEubGluZXMsIGRhdGEuRU9MLCBkYXRhLnZlcnNpb25JZCk7XHJcbiAgICB9XHJcbiAgICBhY2NlcHRNb2RlbENoYW5nZWQoc3RyVVJMLCBlKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9tb2RlbHNbc3RyVVJMXSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXMuX21vZGVsc1tzdHJVUkxdO1xyXG4gICAgICAgIG1vZGVsLm9uRXZlbnRzKGUpO1xyXG4gICAgfVxyXG4gICAgYWNjZXB0UmVtb3ZlZE1vZGVsKHN0clVSTCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fbW9kZWxzW3N0clVSTF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgdGhpcy5fbW9kZWxzW3N0clVSTF07XHJcbiAgICB9XHJcbiAgICAvLyAtLS0tIEJFR0lOIGRpZmYgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGNvbXB1dGVEaWZmKG9yaWdpbmFsVXJsLCBtb2RpZmllZFVybCwgaWdub3JlVHJpbVdoaXRlc3BhY2UsIG1heENvbXB1dGF0aW9uVGltZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsID0gdGhpcy5fZ2V0TW9kZWwob3JpZ2luYWxVcmwpO1xyXG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZCA9IHRoaXMuX2dldE1vZGVsKG1vZGlmaWVkVXJsKTtcclxuICAgICAgICAgICAgaWYgKCFvcmlnaW5hbCB8fCAhbW9kaWZpZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTGluZXMgPSBvcmlnaW5hbC5nZXRMaW5lc0NvbnRlbnQoKTtcclxuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRMaW5lcyA9IG1vZGlmaWVkLmdldExpbmVzQ29udGVudCgpO1xyXG4gICAgICAgICAgICBjb25zdCBkaWZmQ29tcHV0ZXIgPSBuZXcgRGlmZkNvbXB1dGVyKG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIHtcclxuICAgICAgICAgICAgICAgIHNob3VsZENvbXB1dGVDaGFyQ2hhbmdlczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHNob3VsZFBvc3RQcm9jZXNzQ2hhckNoYW5nZXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZTogaWdub3JlVHJpbVdoaXRlc3BhY2UsXHJcbiAgICAgICAgICAgICAgICBzaG91bGRNYWtlUHJldHR5RGlmZjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG1heENvbXB1dGF0aW9uVGltZTogbWF4Q29tcHV0YXRpb25UaW1lXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBkaWZmUmVzdWx0ID0gZGlmZkNvbXB1dGVyLmNvbXB1dGVEaWZmKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWNhbCA9IChkaWZmUmVzdWx0LmNoYW5nZXMubGVuZ3RoID4gMCA/IGZhbHNlIDogdGhpcy5fbW9kZWxzQXJlSWRlbnRpY2FsKG9yaWdpbmFsLCBtb2RpZmllZCkpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcXVpdEVhcmx5OiBkaWZmUmVzdWx0LnF1aXRFYXJseSxcclxuICAgICAgICAgICAgICAgIGlkZW50aWNhbDogaWRlbnRpY2FsLFxyXG4gICAgICAgICAgICAgICAgY2hhbmdlczogZGlmZlJlc3VsdC5jaGFuZ2VzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfbW9kZWxzQXJlSWRlbnRpY2FsKG9yaWdpbmFsLCBtb2RpZmllZCkge1xyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTGluZUNvdW50ID0gb3JpZ2luYWwuZ2V0TGluZUNvdW50KCk7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZWRMaW5lQ291bnQgPSBtb2RpZmllZC5nZXRMaW5lQ291bnQoKTtcclxuICAgICAgICBpZiAob3JpZ2luYWxMaW5lQ291bnQgIT09IG1vZGlmaWVkTGluZUNvdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgbGluZSA9IDE7IGxpbmUgPD0gb3JpZ2luYWxMaW5lQ291bnQ7IGxpbmUrKykge1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5nZXRMaW5lQ29udGVudChsaW5lKTtcclxuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWQuZ2V0TGluZUNvbnRlbnQobGluZSk7XHJcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbExpbmUgIT09IG1vZGlmaWVkTGluZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY29tcHV0ZU1vcmVNaW5pbWFsRWRpdHMobW9kZWxVcmwsIGVkaXRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9nZXRNb2RlbChtb2RlbFVybCk7XHJcbiAgICAgICAgICAgIGlmICghbW9kZWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlZGl0cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgbGV0IGxhc3RFb2wgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGVkaXRzID0gbWVyZ2VTb3J0KGVkaXRzLCAoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGEucmFuZ2UgJiYgYi5yYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSYW5nZS5jb21wYXJlUmFuZ2VzVXNpbmdTdGFydHMoYS5yYW5nZSwgYi5yYW5nZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBlb2wgb25seSBjaGFuZ2VzIHNob3VsZCBnbyB0byB0aGUgZW5kXHJcbiAgICAgICAgICAgICAgICBsZXQgYVJuZyA9IGEucmFuZ2UgPyAwIDogMTtcclxuICAgICAgICAgICAgICAgIGxldCBiUm5nID0gYi5yYW5nZSA/IDAgOiAxO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFSbmcgLSBiUm5nO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZm9yIChsZXQgeyByYW5nZSwgdGV4dCwgZW9sIH0gb2YgZWRpdHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW9sID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RFb2wgPSBlb2w7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoUmFuZ2UuaXNFbXB0eShyYW5nZSkgJiYgIXRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbXB0eSBjaGFuZ2VcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsID0gbW9kZWwuZ2V0VmFsdWVJblJhbmdlKHJhbmdlKTtcclxuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbnxcXG58XFxyL2csIG1vZGVsLmVvbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWwgPT09IHRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBub29wXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgZGlmZiB3b24ndCB0YWtlIHRvbyBsb25nXHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5tYXgodGV4dC5sZW5ndGgsIG9yaWdpbmFsLmxlbmd0aCkgPiBFZGl0b3JTaW1wbGVXb3JrZXIuX2RpZmZMaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgcmFuZ2UsIHRleHQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjb21wdXRlIGRpZmYgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZWRpdC50ZXh0XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gc3RyaW5nRGlmZihvcmlnaW5hbCwgdGV4dCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWRpdE9mZnNldCA9IG1vZGVsLm9mZnNldEF0KFJhbmdlLmxpZnQocmFuZ2UpLmdldFN0YXJ0UG9zaXRpb24oKSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBtb2RlbC5wb3NpdGlvbkF0KGVkaXRPZmZzZXQgKyBjaGFuZ2Uub3JpZ2luYWxTdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gbW9kZWwucG9zaXRpb25BdChlZGl0T2Zmc2V0ICsgY2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBjaGFuZ2Uub3JpZ2luYWxMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0VkaXQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQuc3Vic3RyKGNoYW5nZS5tb2RpZmllZFN0YXJ0LCBjaGFuZ2UubW9kaWZpZWRMZW5ndGgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogeyBzdGFydExpbmVOdW1iZXI6IHN0YXJ0LmxpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uOiBzdGFydC5jb2x1bW4sIGVuZExpbmVOdW1iZXI6IGVuZC5saW5lTnVtYmVyLCBlbmRDb2x1bW46IGVuZC5jb2x1bW4gfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmdldFZhbHVlSW5SYW5nZShuZXdFZGl0LnJhbmdlKSAhPT0gbmV3RWRpdC50ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld0VkaXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RFb2wgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGVvbDogbGFzdEVvbCwgdGV4dDogJycsIHJhbmdlOiB7IHN0YXJ0TGluZU51bWJlcjogMCwgc3RhcnRDb2x1bW46IDAsIGVuZExpbmVOdW1iZXI6IDAsIGVuZENvbHVtbjogMCB9IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyAtLS0tIEVORCBtaW5pbWFsIGVkaXRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgY29tcHV0ZUxpbmtzKG1vZGVsVXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgbGV0IG1vZGVsID0gdGhpcy5fZ2V0TW9kZWwobW9kZWxVcmwpO1xyXG4gICAgICAgICAgICBpZiAoIW1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29tcHV0ZUxpbmtzKG1vZGVsKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRleHR1YWxTdWdnZXN0KG1vZGVsVXJsLCBwb3NpdGlvbiwgd29yZERlZiwgd29yZERlZkZsYWdzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9nZXRNb2RlbChtb2RlbFVybCk7XHJcbiAgICAgICAgICAgIGlmICghbW9kZWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHdvcmRzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHdvcmREZWZSZWdFeHAgPSBuZXcgUmVnRXhwKHdvcmREZWYsIHdvcmREZWZGbGFncyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHdvcmRBdCA9IG1vZGVsLmdldFdvcmRBdFBvc2l0aW9uKHBvc2l0aW9uLCB3b3JkRGVmUmVnRXhwKTtcclxuICAgICAgICAgICAgaWYgKHdvcmRBdCkge1xyXG4gICAgICAgICAgICAgICAgc2Vlbi5hZGQobW9kZWwuZ2V0VmFsdWVJblJhbmdlKHdvcmRBdCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IHdvcmQgb2YgbW9kZWwud29yZHMod29yZERlZlJlZ0V4cCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWVuLmhhcyh3b3JkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2Vlbi5hZGQod29yZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKE51bWJlcih3b3JkKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdvcmRzLnB1c2god29yZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbi5zaXplID4gRWRpdG9yU2ltcGxlV29ya2VyLl9zdWdnZXN0aW9uc0xpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHdvcmRzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gLS0tLSBFTkQgc3VnZ2VzdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8jcmVnaW9uIC0tIHdvcmQgcmFuZ2VzIC0tXHJcbiAgICBjb21wdXRlV29yZFJhbmdlcyhtb2RlbFVybCwgcmFuZ2UsIHdvcmREZWYsIHdvcmREZWZGbGFncykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKG1vZGVsVXJsKTtcclxuICAgICAgICAgICAgaWYgKCFtb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgd29yZERlZlJlZ0V4cCA9IG5ldyBSZWdFeHAod29yZERlZiwgd29yZERlZkZsYWdzKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgbGluZSA9IHJhbmdlLnN0YXJ0TGluZU51bWJlcjsgbGluZSA8IHJhbmdlLmVuZExpbmVOdW1iZXI7IGxpbmUrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHdvcmRzID0gbW9kZWwuZ2V0TGluZVdvcmRzKGxpbmUsIHdvcmREZWZSZWdFeHApO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB3b3JkIG9mIHdvcmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihOdW1iZXIod29yZC53b3JkKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhcnJheSA9IHJlc3VsdFt3b3JkLndvcmRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXkgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3dvcmQud29yZF0gPSBhcnJheTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlcjogbGluZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDb2x1bW46IHdvcmQuc3RhcnRDb2x1bW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZExpbmVOdW1iZXI6IGxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZENvbHVtbjogd29yZC5lbmRDb2x1bW5cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgICBuYXZpZ2F0ZVZhbHVlU2V0KG1vZGVsVXJsLCByYW5nZSwgdXAsIHdvcmREZWYsIHdvcmREZWZGbGFncykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKG1vZGVsVXJsKTtcclxuICAgICAgICAgICAgaWYgKCFtb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHdvcmREZWZSZWdFeHAgPSBuZXcgUmVnRXhwKHdvcmREZWYsIHdvcmREZWZGbGFncyk7XHJcbiAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydENvbHVtbiA9PT0gcmFuZ2UuZW5kQ29sdW1uKSB7XHJcbiAgICAgICAgICAgICAgICByYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydExpbmVOdW1iZXI6IHJhbmdlLnN0YXJ0TGluZU51bWJlcixcclxuICAgICAgICAgICAgICAgICAgICBzdGFydENvbHVtbjogcmFuZ2Uuc3RhcnRDb2x1bW4sXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTGluZU51bWJlcjogcmFuZ2UuZW5kTGluZU51bWJlcixcclxuICAgICAgICAgICAgICAgICAgICBlbmRDb2x1bW46IHJhbmdlLmVuZENvbHVtbiArIDFcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHNlbGVjdGlvblRleHQgPSBtb2RlbC5nZXRWYWx1ZUluUmFuZ2UocmFuZ2UpO1xyXG4gICAgICAgICAgICBsZXQgd29yZFJhbmdlID0gbW9kZWwuZ2V0V29yZEF0UG9zaXRpb24oeyBsaW5lTnVtYmVyOiByYW5nZS5zdGFydExpbmVOdW1iZXIsIGNvbHVtbjogcmFuZ2Uuc3RhcnRDb2x1bW4gfSwgd29yZERlZlJlZ0V4cCk7XHJcbiAgICAgICAgICAgIGlmICghd29yZFJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgd29yZCA9IG1vZGVsLmdldFZhbHVlSW5SYW5nZSh3b3JkUmFuZ2UpO1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gQmFzaWNJbnBsYWNlUmVwbGFjZS5JTlNUQU5DRS5uYXZpZ2F0ZVZhbHVlU2V0KHJhbmdlLCBzZWxlY3Rpb25UZXh0LCB3b3JkUmFuZ2UsIHdvcmQsIHVwKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIC0tLS0gQkVHSU4gZm9yZWlnbiBtb2R1bGUgc3VwcG9ydCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgbG9hZEZvcmVpZ25Nb2R1bGUobW9kdWxlSWQsIGNyZWF0ZURhdGEsIGZvcmVpZ25Ib3N0TWV0aG9kcykge1xyXG4gICAgICAgIGNvbnN0IHByb3h5TWV0aG9kUmVxdWVzdCA9IChtZXRob2QsIGFyZ3MpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hvc3QuZmhyKG1ldGhvZCwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBmb3JlaWduSG9zdCA9IHR5cGVzLmNyZWF0ZVByb3h5T2JqZWN0KGZvcmVpZ25Ib3N0TWV0aG9kcywgcHJveHlNZXRob2RSZXF1ZXN0KTtcclxuICAgICAgICBsZXQgY3R4ID0ge1xyXG4gICAgICAgICAgICBob3N0OiBmb3JlaWduSG9zdCxcclxuICAgICAgICAgICAgZ2V0TWlycm9yTW9kZWxzOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TW9kZWxzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzLl9mb3JlaWduTW9kdWxlRmFjdG9yeSkge1xyXG4gICAgICAgICAgICB0aGlzLl9mb3JlaWduTW9kdWxlID0gdGhpcy5fZm9yZWlnbk1vZHVsZUZhY3RvcnkoY3R4LCBjcmVhdGVEYXRhKTtcclxuICAgICAgICAgICAgLy8gc3RhdGljIGZvcmVpbmcgbW9kdWxlXHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHlwZXMuZ2V0QWxsTWV0aG9kTmFtZXModGhpcy5fZm9yZWlnbk1vZHVsZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFU00tY29tbWVudC1iZWdpblxyXG4gICAgICAgIC8vIFx0XHRyZXR1cm4gbmV3IFByb21pc2U8YW55PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgLy8gXHRcdFx0cmVxdWlyZShbbW9kdWxlSWRdLCAoZm9yZWlnbk1vZHVsZTogeyBjcmVhdGU6IElGb3JlaWduTW9kdWxlRmFjdG9yeSB9KSA9PiB7XHJcbiAgICAgICAgLy8gXHRcdFx0XHR0aGlzLl9mb3JlaWduTW9kdWxlID0gZm9yZWlnbk1vZHVsZS5jcmVhdGUoY3R4LCBjcmVhdGVEYXRhKTtcclxuICAgICAgICAvLyBcclxuICAgICAgICAvLyBcdFx0XHRcdHJlc29sdmUodHlwZXMuZ2V0QWxsTWV0aG9kTmFtZXModGhpcy5fZm9yZWlnbk1vZHVsZSkpO1xyXG4gICAgICAgIC8vIFxyXG4gICAgICAgIC8vIFx0XHRcdH0sIHJlamVjdCk7XHJcbiAgICAgICAgLy8gXHRcdH0pO1xyXG4gICAgICAgIC8vIEVTTS1jb21tZW50LWVuZFxyXG4gICAgICAgIC8vIEVTTS11bmNvbW1lbnQtYmVnaW5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBVbmV4cGVjdGVkIHVzYWdlYCkpO1xyXG4gICAgICAgIC8vIEVTTS11bmNvbW1lbnQtZW5kXHJcbiAgICB9XHJcbiAgICAvLyBmb3JlaWduIG1ldGhvZCByZXF1ZXN0XHJcbiAgICBmbXIobWV0aG9kLCBhcmdzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9mb3JlaWduTW9kdWxlIHx8IHR5cGVvZiB0aGlzLl9mb3JlaWduTW9kdWxlW21ldGhvZF0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTWlzc2luZyByZXF1ZXN0SGFuZGxlciBvciBtZXRob2Q6ICcgKyBtZXRob2QpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9mb3JlaWduTW9kdWxlW21ldGhvZF0uYXBwbHkodGhpcy5fZm9yZWlnbk1vZHVsZSwgYXJncykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIC0tLS0gRU5EIGRpZmYgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gLS0tLSBCRUdJTiBtaW5pbWFsIGVkaXRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5FZGl0b3JTaW1wbGVXb3JrZXIuX2RpZmZMaW1pdCA9IDEwMDAwMDtcclxuLy8gLS0tLSBCRUdJTiBzdWdnZXN0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbkVkaXRvclNpbXBsZVdvcmtlci5fc3VnZ2VzdGlvbnNMaW1pdCA9IDEwMDAwO1xyXG4vKipcclxuICogQ2FsbGVkIG9uIHRoZSB3b3JrZXIgc2lkZVxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoaG9zdCkge1xyXG4gICAgcmV0dXJuIG5ldyBFZGl0b3JTaW1wbGVXb3JrZXIoaG9zdCwgbnVsbCk7XHJcbn1cclxuaWYgKHR5cGVvZiBpbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAvLyBSdW5uaW5nIGluIGEgd2ViIHdvcmtlclxyXG4gICAgZ2xvYmFscy5tb25hY28gPSBjcmVhdGVNb25hY29CYXNlQVBJKCk7XHJcbn1cclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IENhbmNlbGxhdGlvblRva2VuU291cmNlIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vY2FuY2VsbGF0aW9uLmpzJztcclxuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2V2ZW50LmpzJztcclxuaW1wb3J0IHsgS2V5Q2hvcmQgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9rZXlDb2Rlcy5qcyc7XHJcbmltcG9ydCB7IFVSSSB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3VyaS5qcyc7XHJcbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi4vY29yZS9wb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vY29yZS9yYW5nZS5qcyc7XHJcbmltcG9ydCB7IFNlbGVjdGlvbiB9IGZyb20gJy4uL2NvcmUvc2VsZWN0aW9uLmpzJztcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tICcuLi9jb3JlL3Rva2VuLmpzJztcclxuaW1wb3J0ICogYXMgc3RhbmRhbG9uZUVudW1zIGZyb20gJy4vc3RhbmRhbG9uZUVudW1zLmpzJztcclxuZXhwb3J0IGNsYXNzIEtleU1vZCB7XHJcbiAgICBzdGF0aWMgY2hvcmQoZmlyc3RQYXJ0LCBzZWNvbmRQYXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuIEtleUNob3JkKGZpcnN0UGFydCwgc2Vjb25kUGFydCk7XHJcbiAgICB9XHJcbn1cclxuS2V5TW9kLkN0cmxDbWQgPSAyMDQ4IC8qIEN0cmxDbWQgKi87XHJcbktleU1vZC5TaGlmdCA9IDEwMjQgLyogU2hpZnQgKi87XHJcbktleU1vZC5BbHQgPSA1MTIgLyogQWx0ICovO1xyXG5LZXlNb2QuV2luQ3RybCA9IDI1NiAvKiBXaW5DdHJsICovO1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTW9uYWNvQmFzZUFQSSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZWRpdG9yOiB1bmRlZmluZWQsXHJcbiAgICAgICAgbGFuZ3VhZ2VzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U6IENhbmNlbGxhdGlvblRva2VuU291cmNlLFxyXG4gICAgICAgIEVtaXR0ZXI6IEVtaXR0ZXIsXHJcbiAgICAgICAgS2V5Q29kZTogc3RhbmRhbG9uZUVudW1zLktleUNvZGUsXHJcbiAgICAgICAgS2V5TW9kOiBLZXlNb2QsXHJcbiAgICAgICAgUG9zaXRpb246IFBvc2l0aW9uLFxyXG4gICAgICAgIFJhbmdlOiBSYW5nZSxcclxuICAgICAgICBTZWxlY3Rpb246IFNlbGVjdGlvbixcclxuICAgICAgICBTZWxlY3Rpb25EaXJlY3Rpb246IHN0YW5kYWxvbmVFbnVtcy5TZWxlY3Rpb25EaXJlY3Rpb24sXHJcbiAgICAgICAgTWFya2VyU2V2ZXJpdHk6IHN0YW5kYWxvbmVFbnVtcy5NYXJrZXJTZXZlcml0eSxcclxuICAgICAgICBNYXJrZXJUYWc6IHN0YW5kYWxvbmVFbnVtcy5NYXJrZXJUYWcsXHJcbiAgICAgICAgVXJpOiBVUkksXHJcbiAgICAgICAgVG9rZW46IFRva2VuXHJcbiAgICB9O1xyXG59XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBUSElTIElTIEEgR0VORVJBVEVEIEZJTEUuIERPIE5PVCBFRElUIERJUkVDVExZLlxyXG5leHBvcnQgdmFyIEFjY2Vzc2liaWxpdHlTdXBwb3J0O1xyXG4oZnVuY3Rpb24gKEFjY2Vzc2liaWxpdHlTdXBwb3J0KSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgc2hvdWxkIGJlIHRoZSBicm93c2VyIGNhc2Ugd2hlcmUgaXQgaXMgbm90IGtub3duIGlmIGEgc2NyZWVuIHJlYWRlciBpcyBhdHRhY2hlZCBvciBuby5cclxuICAgICAqL1xyXG4gICAgQWNjZXNzaWJpbGl0eVN1cHBvcnRbQWNjZXNzaWJpbGl0eVN1cHBvcnRbXCJVbmtub3duXCJdID0gMF0gPSBcIlVua25vd25cIjtcclxuICAgIEFjY2Vzc2liaWxpdHlTdXBwb3J0W0FjY2Vzc2liaWxpdHlTdXBwb3J0W1wiRGlzYWJsZWRcIl0gPSAxXSA9IFwiRGlzYWJsZWRcIjtcclxuICAgIEFjY2Vzc2liaWxpdHlTdXBwb3J0W0FjY2Vzc2liaWxpdHlTdXBwb3J0W1wiRW5hYmxlZFwiXSA9IDJdID0gXCJFbmFibGVkXCI7XHJcbn0pKEFjY2Vzc2liaWxpdHlTdXBwb3J0IHx8IChBY2Nlc3NpYmlsaXR5U3VwcG9ydCA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZTtcclxuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUluc2VydFRleHRSdWxlKSB7XHJcbiAgICAvKipcclxuICAgICAqIEFkanVzdCB3aGl0ZXNwYWNlL2luZGVudGF0aW9uIG9mIG11bHRpbGluZSBpbnNlcnQgdGV4dHMgdG9cclxuICAgICAqIG1hdGNoIHRoZSBjdXJyZW50IGxpbmUgaW5kZW50YXRpb24uXHJcbiAgICAgKi9cclxuICAgIENvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGVbQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZVtcIktlZXBXaGl0ZXNwYWNlXCJdID0gMV0gPSBcIktlZXBXaGl0ZXNwYWNlXCI7XHJcbiAgICAvKipcclxuICAgICAqIGBpbnNlcnRUZXh0YCBpcyBhIHNuaXBwZXQuXHJcbiAgICAgKi9cclxuICAgIENvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGVbQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZVtcIkluc2VydEFzU25pcHBldFwiXSA9IDRdID0gXCJJbnNlcnRBc1NuaXBwZXRcIjtcclxufSkoQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZSB8fCAoQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZSA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgQ29tcGxldGlvbkl0ZW1LaW5kO1xyXG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtS2luZCkge1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIk1ldGhvZFwiXSA9IDBdID0gXCJNZXRob2RcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJGdW5jdGlvblwiXSA9IDFdID0gXCJGdW5jdGlvblwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkNvbnN0cnVjdG9yXCJdID0gMl0gPSBcIkNvbnN0cnVjdG9yXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiRmllbGRcIl0gPSAzXSA9IFwiRmllbGRcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJWYXJpYWJsZVwiXSA9IDRdID0gXCJWYXJpYWJsZVwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkNsYXNzXCJdID0gNV0gPSBcIkNsYXNzXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiU3RydWN0XCJdID0gNl0gPSBcIlN0cnVjdFwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkludGVyZmFjZVwiXSA9IDddID0gXCJJbnRlcmZhY2VcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJNb2R1bGVcIl0gPSA4XSA9IFwiTW9kdWxlXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiUHJvcGVydHlcIl0gPSA5XSA9IFwiUHJvcGVydHlcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJFdmVudFwiXSA9IDEwXSA9IFwiRXZlbnRcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJPcGVyYXRvclwiXSA9IDExXSA9IFwiT3BlcmF0b3JcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJVbml0XCJdID0gMTJdID0gXCJVbml0XCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiVmFsdWVcIl0gPSAxM10gPSBcIlZhbHVlXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiQ29uc3RhbnRcIl0gPSAxNF0gPSBcIkNvbnN0YW50XCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiRW51bVwiXSA9IDE1XSA9IFwiRW51bVwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkVudW1NZW1iZXJcIl0gPSAxNl0gPSBcIkVudW1NZW1iZXJcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJLZXl3b3JkXCJdID0gMTddID0gXCJLZXl3b3JkXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiVGV4dFwiXSA9IDE4XSA9IFwiVGV4dFwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkNvbG9yXCJdID0gMTldID0gXCJDb2xvclwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkZpbGVcIl0gPSAyMF0gPSBcIkZpbGVcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJSZWZlcmVuY2VcIl0gPSAyMV0gPSBcIlJlZmVyZW5jZVwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkN1c3RvbWNvbG9yXCJdID0gMjJdID0gXCJDdXN0b21jb2xvclwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkZvbGRlclwiXSA9IDIzXSA9IFwiRm9sZGVyXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiVHlwZVBhcmFtZXRlclwiXSA9IDI0XSA9IFwiVHlwZVBhcmFtZXRlclwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIlVzZXJcIl0gPSAyNV0gPSBcIlVzZXJcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJJc3N1ZVwiXSA9IDI2XSA9IFwiSXNzdWVcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJTbmlwcGV0XCJdID0gMjddID0gXCJTbmlwcGV0XCI7XHJcbn0pKENvbXBsZXRpb25JdGVtS2luZCB8fCAoQ29tcGxldGlvbkl0ZW1LaW5kID0ge30pKTtcclxuZXhwb3J0IHZhciBDb21wbGV0aW9uSXRlbVRhZztcclxuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbVRhZykge1xyXG4gICAgQ29tcGxldGlvbkl0ZW1UYWdbQ29tcGxldGlvbkl0ZW1UYWdbXCJEZXByZWNhdGVkXCJdID0gMV0gPSBcIkRlcHJlY2F0ZWRcIjtcclxufSkoQ29tcGxldGlvbkl0ZW1UYWcgfHwgKENvbXBsZXRpb25JdGVtVGFnID0ge30pKTtcclxuLyoqXHJcbiAqIEhvdyBhIHN1Z2dlc3QgcHJvdmlkZXIgd2FzIHRyaWdnZXJlZC5cclxuICovXHJcbmV4cG9ydCB2YXIgQ29tcGxldGlvblRyaWdnZXJLaW5kO1xyXG4oZnVuY3Rpb24gKENvbXBsZXRpb25UcmlnZ2VyS2luZCkge1xyXG4gICAgQ29tcGxldGlvblRyaWdnZXJLaW5kW0NvbXBsZXRpb25UcmlnZ2VyS2luZFtcIkludm9rZVwiXSA9IDBdID0gXCJJbnZva2VcIjtcclxuICAgIENvbXBsZXRpb25UcmlnZ2VyS2luZFtDb21wbGV0aW9uVHJpZ2dlcktpbmRbXCJUcmlnZ2VyQ2hhcmFjdGVyXCJdID0gMV0gPSBcIlRyaWdnZXJDaGFyYWN0ZXJcIjtcclxuICAgIENvbXBsZXRpb25UcmlnZ2VyS2luZFtDb21wbGV0aW9uVHJpZ2dlcktpbmRbXCJUcmlnZ2VyRm9ySW5jb21wbGV0ZUNvbXBsZXRpb25zXCJdID0gMl0gPSBcIlRyaWdnZXJGb3JJbmNvbXBsZXRlQ29tcGxldGlvbnNcIjtcclxufSkoQ29tcGxldGlvblRyaWdnZXJLaW5kIHx8IChDb21wbGV0aW9uVHJpZ2dlcktpbmQgPSB7fSkpO1xyXG4vKipcclxuICogQSBwb3NpdGlvbmluZyBwcmVmZXJlbmNlIGZvciByZW5kZXJpbmcgY29udGVudCB3aWRnZXRzLlxyXG4gKi9cclxuZXhwb3J0IHZhciBDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlO1xyXG4oZnVuY3Rpb24gKENvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2UpIHtcclxuICAgIC8qKlxyXG4gICAgICogUGxhY2UgdGhlIGNvbnRlbnQgd2lkZ2V0IGV4YWN0bHkgYXQgYSBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW0NvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbXCJFWEFDVFwiXSA9IDBdID0gXCJFWEFDVFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQbGFjZSB0aGUgY29udGVudCB3aWRnZXQgYWJvdmUgYSBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW0NvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbXCJBQk9WRVwiXSA9IDFdID0gXCJBQk9WRVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQbGFjZSB0aGUgY29udGVudCB3aWRnZXQgYmVsb3cgYSBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW0NvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbXCJCRUxPV1wiXSA9IDJdID0gXCJCRUxPV1wiO1xyXG59KShDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlIHx8IChDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlID0ge30pKTtcclxuLyoqXHJcbiAqIERlc2NyaWJlcyB0aGUgcmVhc29uIHRoZSBjdXJzb3IgaGFzIGNoYW5nZWQgaXRzIHBvc2l0aW9uLlxyXG4gKi9cclxuZXhwb3J0IHZhciBDdXJzb3JDaGFuZ2VSZWFzb247XHJcbihmdW5jdGlvbiAoQ3Vyc29yQ2hhbmdlUmVhc29uKSB7XHJcbiAgICAvKipcclxuICAgICAqIFVua25vd24gb3Igbm90IHNldC5cclxuICAgICAqL1xyXG4gICAgQ3Vyc29yQ2hhbmdlUmVhc29uW0N1cnNvckNoYW5nZVJlYXNvbltcIk5vdFNldFwiXSA9IDBdID0gXCJOb3RTZXRcIjtcclxuICAgIC8qKlxyXG4gICAgICogQSBgbW9kZWwuc2V0VmFsdWUoKWAgd2FzIGNhbGxlZC5cclxuICAgICAqL1xyXG4gICAgQ3Vyc29yQ2hhbmdlUmVhc29uW0N1cnNvckNoYW5nZVJlYXNvbltcIkNvbnRlbnRGbHVzaFwiXSA9IDFdID0gXCJDb250ZW50Rmx1c2hcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGBtb2RlbGAgaGFzIGJlZW4gY2hhbmdlZCBvdXRzaWRlIG9mIHRoaXMgY3Vyc29yIGFuZCB0aGUgY3Vyc29yIHJlY292ZXJzIGl0cyBwb3NpdGlvbiBmcm9tIGFzc29jaWF0ZWQgbWFya2Vycy5cclxuICAgICAqL1xyXG4gICAgQ3Vyc29yQ2hhbmdlUmVhc29uW0N1cnNvckNoYW5nZVJlYXNvbltcIlJlY292ZXJGcm9tTWFya2Vyc1wiXSA9IDJdID0gXCJSZWNvdmVyRnJvbU1hcmtlcnNcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlcmUgd2FzIGFuIGV4cGxpY2l0IHVzZXIgZ2VzdHVyZS5cclxuICAgICAqL1xyXG4gICAgQ3Vyc29yQ2hhbmdlUmVhc29uW0N1cnNvckNoYW5nZVJlYXNvbltcIkV4cGxpY2l0XCJdID0gM10gPSBcIkV4cGxpY2l0XCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZXJlIHdhcyBhIFBhc3RlLlxyXG4gICAgICovXHJcbiAgICBDdXJzb3JDaGFuZ2VSZWFzb25bQ3Vyc29yQ2hhbmdlUmVhc29uW1wiUGFzdGVcIl0gPSA0XSA9IFwiUGFzdGVcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlcmUgd2FzIGFuIFVuZG8uXHJcbiAgICAgKi9cclxuICAgIEN1cnNvckNoYW5nZVJlYXNvbltDdXJzb3JDaGFuZ2VSZWFzb25bXCJVbmRvXCJdID0gNV0gPSBcIlVuZG9cIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlcmUgd2FzIGEgUmVkby5cclxuICAgICAqL1xyXG4gICAgQ3Vyc29yQ2hhbmdlUmVhc29uW0N1cnNvckNoYW5nZVJlYXNvbltcIlJlZG9cIl0gPSA2XSA9IFwiUmVkb1wiO1xyXG59KShDdXJzb3JDaGFuZ2VSZWFzb24gfHwgKEN1cnNvckNoYW5nZVJlYXNvbiA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBlbmQgb2YgbGluZSB0byB1c2Ugd2hlbiBpbnN0YW50aWF0aW5nIG1vZGVscy5cclxuICovXHJcbmV4cG9ydCB2YXIgRGVmYXVsdEVuZE9mTGluZTtcclxuKGZ1bmN0aW9uIChEZWZhdWx0RW5kT2ZMaW5lKSB7XHJcbiAgICAvKipcclxuICAgICAqIFVzZSBsaW5lIGZlZWQgKFxcbikgYXMgdGhlIGVuZCBvZiBsaW5lIGNoYXJhY3Rlci5cclxuICAgICAqL1xyXG4gICAgRGVmYXVsdEVuZE9mTGluZVtEZWZhdWx0RW5kT2ZMaW5lW1wiTEZcIl0gPSAxXSA9IFwiTEZcIjtcclxuICAgIC8qKlxyXG4gICAgICogVXNlIGNhcnJpYWdlIHJldHVybiBhbmQgbGluZSBmZWVkIChcXHJcXG4pIGFzIHRoZSBlbmQgb2YgbGluZSBjaGFyYWN0ZXIuXHJcbiAgICAgKi9cclxuICAgIERlZmF1bHRFbmRPZkxpbmVbRGVmYXVsdEVuZE9mTGluZVtcIkNSTEZcIl0gPSAyXSA9IFwiQ1JMRlwiO1xyXG59KShEZWZhdWx0RW5kT2ZMaW5lIHx8IChEZWZhdWx0RW5kT2ZMaW5lID0ge30pKTtcclxuLyoqXHJcbiAqIEEgZG9jdW1lbnQgaGlnaGxpZ2h0IGtpbmQuXHJcbiAqL1xyXG5leHBvcnQgdmFyIERvY3VtZW50SGlnaGxpZ2h0S2luZDtcclxuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodEtpbmQpIHtcclxuICAgIC8qKlxyXG4gICAgICogQSB0ZXh0dWFsIG9jY3VycmVuY2UuXHJcbiAgICAgKi9cclxuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZFtEb2N1bWVudEhpZ2hsaWdodEtpbmRbXCJUZXh0XCJdID0gMF0gPSBcIlRleHRcIjtcclxuICAgIC8qKlxyXG4gICAgICogUmVhZC1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2UgcmVhZGluZyBhIHZhcmlhYmxlLlxyXG4gICAgICovXHJcbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmRbRG9jdW1lbnRIaWdobGlnaHRLaW5kW1wiUmVhZFwiXSA9IDFdID0gXCJSZWFkXCI7XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlLWFjY2VzcyBvZiBhIHN5bWJvbCwgbGlrZSB3cml0aW5nIHRvIGEgdmFyaWFibGUuXHJcbiAgICAgKi9cclxuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZFtEb2N1bWVudEhpZ2hsaWdodEtpbmRbXCJXcml0ZVwiXSA9IDJdID0gXCJXcml0ZVwiO1xyXG59KShEb2N1bWVudEhpZ2hsaWdodEtpbmQgfHwgKERvY3VtZW50SGlnaGxpZ2h0S2luZCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGF1dG8gaW5kZW50YXRpb24gaW4gdGhlIGVkaXRvclxyXG4gKi9cclxuZXhwb3J0IHZhciBFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3k7XHJcbihmdW5jdGlvbiAoRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5KSB7XHJcbiAgICBFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XHJcbiAgICBFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W1wiS2VlcFwiXSA9IDFdID0gXCJLZWVwXCI7XHJcbiAgICBFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W1wiQnJhY2tldHNcIl0gPSAyXSA9IFwiQnJhY2tldHNcIjtcclxuICAgIEVkaXRvckF1dG9JbmRlbnRTdHJhdGVneVtFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbXCJBZHZhbmNlZFwiXSA9IDNdID0gXCJBZHZhbmNlZFwiO1xyXG4gICAgRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W0VkaXRvckF1dG9JbmRlbnRTdHJhdGVneVtcIkZ1bGxcIl0gPSA0XSA9IFwiRnVsbFwiO1xyXG59KShFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3kgfHwgKEVkaXRvckF1dG9JbmRlbnRTdHJhdGVneSA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgRWRpdG9yT3B0aW9uO1xyXG4oZnVuY3Rpb24gKEVkaXRvck9wdGlvbikge1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImFjY2VwdFN1Z2dlc3Rpb25PbkNvbW1pdENoYXJhY3RlclwiXSA9IDBdID0gXCJhY2NlcHRTdWdnZXN0aW9uT25Db21taXRDaGFyYWN0ZXJcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhY2NlcHRTdWdnZXN0aW9uT25FbnRlclwiXSA9IDFdID0gXCJhY2NlcHRTdWdnZXN0aW9uT25FbnRlclwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImFjY2Vzc2liaWxpdHlTdXBwb3J0XCJdID0gMl0gPSBcImFjY2Vzc2liaWxpdHlTdXBwb3J0XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYWNjZXNzaWJpbGl0eVBhZ2VTaXplXCJdID0gM10gPSBcImFjY2Vzc2liaWxpdHlQYWdlU2l6ZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImFyaWFMYWJlbFwiXSA9IDRdID0gXCJhcmlhTGFiZWxcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhdXRvQ2xvc2luZ0JyYWNrZXRzXCJdID0gNV0gPSBcImF1dG9DbG9zaW5nQnJhY2tldHNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhdXRvQ2xvc2luZ092ZXJ0eXBlXCJdID0gNl0gPSBcImF1dG9DbG9zaW5nT3ZlcnR5cGVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhdXRvQ2xvc2luZ1F1b3Rlc1wiXSA9IDddID0gXCJhdXRvQ2xvc2luZ1F1b3Rlc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImF1dG9JbmRlbnRcIl0gPSA4XSA9IFwiYXV0b0luZGVudFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImF1dG9tYXRpY0xheW91dFwiXSA9IDldID0gXCJhdXRvbWF0aWNMYXlvdXRcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhdXRvU3Vycm91bmRcIl0gPSAxMF0gPSBcImF1dG9TdXJyb3VuZFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImNvZGVMZW5zXCJdID0gMTFdID0gXCJjb2RlTGVuc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImNvbG9yRGVjb3JhdG9yc1wiXSA9IDEyXSA9IFwiY29sb3JEZWNvcmF0b3JzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY29sdW1uU2VsZWN0aW9uXCJdID0gMTNdID0gXCJjb2x1bW5TZWxlY3Rpb25cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb21tZW50c1wiXSA9IDE0XSA9IFwiY29tbWVudHNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb250ZXh0bWVudVwiXSA9IDE1XSA9IFwiY29udGV4dG1lbnVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb3B5V2l0aFN5bnRheEhpZ2hsaWdodGluZ1wiXSA9IDE2XSA9IFwiY29weVdpdGhTeW50YXhIaWdobGlnaHRpbmdcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjdXJzb3JCbGlua2luZ1wiXSA9IDE3XSA9IFwiY3Vyc29yQmxpbmtpbmdcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjdXJzb3JTbW9vdGhDYXJldEFuaW1hdGlvblwiXSA9IDE4XSA9IFwiY3Vyc29yU21vb3RoQ2FyZXRBbmltYXRpb25cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjdXJzb3JTdHlsZVwiXSA9IDE5XSA9IFwiY3Vyc29yU3R5bGVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjdXJzb3JTdXJyb3VuZGluZ0xpbmVzXCJdID0gMjBdID0gXCJjdXJzb3JTdXJyb3VuZGluZ0xpbmVzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY3Vyc29yU3Vycm91bmRpbmdMaW5lc1N0eWxlXCJdID0gMjFdID0gXCJjdXJzb3JTdXJyb3VuZGluZ0xpbmVzU3R5bGVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjdXJzb3JXaWR0aFwiXSA9IDIyXSA9IFwiY3Vyc29yV2lkdGhcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJkaXNhYmxlTGF5ZXJIaW50aW5nXCJdID0gMjNdID0gXCJkaXNhYmxlTGF5ZXJIaW50aW5nXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZGlzYWJsZU1vbm9zcGFjZU9wdGltaXphdGlvbnNcIl0gPSAyNF0gPSBcImRpc2FibGVNb25vc3BhY2VPcHRpbWl6YXRpb25zXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZHJhZ0FuZERyb3BcIl0gPSAyNV0gPSBcImRyYWdBbmREcm9wXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZW1wdHlTZWxlY3Rpb25DbGlwYm9hcmRcIl0gPSAyNl0gPSBcImVtcHR5U2VsZWN0aW9uQ2xpcGJvYXJkXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZXh0cmFFZGl0b3JDbGFzc05hbWVcIl0gPSAyN10gPSBcImV4dHJhRWRpdG9yQ2xhc3NOYW1lXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZmFzdFNjcm9sbFNlbnNpdGl2aXR5XCJdID0gMjhdID0gXCJmYXN0U2Nyb2xsU2Vuc2l0aXZpdHlcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmaW5kXCJdID0gMjldID0gXCJmaW5kXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZml4ZWRPdmVyZmxvd1dpZGdldHNcIl0gPSAzMF0gPSBcImZpeGVkT3ZlcmZsb3dXaWRnZXRzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9sZGluZ1wiXSA9IDMxXSA9IFwiZm9sZGluZ1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbGRpbmdTdHJhdGVneVwiXSA9IDMyXSA9IFwiZm9sZGluZ1N0cmF0ZWd5XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9sZGluZ0hpZ2hsaWdodFwiXSA9IDMzXSA9IFwiZm9sZGluZ0hpZ2hsaWdodFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInVuZm9sZE9uQ2xpY2tBZnRlckVuZE9mTGluZVwiXSA9IDM0XSA9IFwidW5mb2xkT25DbGlja0FmdGVyRW5kT2ZMaW5lXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9udEZhbWlseVwiXSA9IDM1XSA9IFwiZm9udEZhbWlseVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbnRJbmZvXCJdID0gMzZdID0gXCJmb250SW5mb1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbnRMaWdhdHVyZXNcIl0gPSAzN10gPSBcImZvbnRMaWdhdHVyZXNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb250U2l6ZVwiXSA9IDM4XSA9IFwiZm9udFNpemVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb250V2VpZ2h0XCJdID0gMzldID0gXCJmb250V2VpZ2h0XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9ybWF0T25QYXN0ZVwiXSA9IDQwXSA9IFwiZm9ybWF0T25QYXN0ZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvcm1hdE9uVHlwZVwiXSA9IDQxXSA9IFwiZm9ybWF0T25UeXBlXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZ2x5cGhNYXJnaW5cIl0gPSA0Ml0gPSBcImdseXBoTWFyZ2luXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZ290b0xvY2F0aW9uXCJdID0gNDNdID0gXCJnb3RvTG9jYXRpb25cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJoaWRlQ3Vyc29ySW5PdmVydmlld1J1bGVyXCJdID0gNDRdID0gXCJoaWRlQ3Vyc29ySW5PdmVydmlld1J1bGVyXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiaGlnaGxpZ2h0QWN0aXZlSW5kZW50R3VpZGVcIl0gPSA0NV0gPSBcImhpZ2hsaWdodEFjdGl2ZUluZGVudEd1aWRlXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiaG92ZXJcIl0gPSA0Nl0gPSBcImhvdmVyXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiaW5EaWZmRWRpdG9yXCJdID0gNDddID0gXCJpbkRpZmZFZGl0b3JcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJsZXR0ZXJTcGFjaW5nXCJdID0gNDhdID0gXCJsZXR0ZXJTcGFjaW5nXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGlnaHRidWxiXCJdID0gNDldID0gXCJsaWdodGJ1bGJcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJsaW5lRGVjb3JhdGlvbnNXaWR0aFwiXSA9IDUwXSA9IFwibGluZURlY29yYXRpb25zV2lkdGhcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJsaW5lSGVpZ2h0XCJdID0gNTFdID0gXCJsaW5lSGVpZ2h0XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGluZU51bWJlcnNcIl0gPSA1Ml0gPSBcImxpbmVOdW1iZXJzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGluZU51bWJlcnNNaW5DaGFyc1wiXSA9IDUzXSA9IFwibGluZU51bWJlcnNNaW5DaGFyc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImxpbmtzXCJdID0gNTRdID0gXCJsaW5rc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm1hdGNoQnJhY2tldHNcIl0gPSA1NV0gPSBcIm1hdGNoQnJhY2tldHNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtaW5pbWFwXCJdID0gNTZdID0gXCJtaW5pbWFwXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibW91c2VTdHlsZVwiXSA9IDU3XSA9IFwibW91c2VTdHlsZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm1vdXNlV2hlZWxTY3JvbGxTZW5zaXRpdml0eVwiXSA9IDU4XSA9IFwibW91c2VXaGVlbFNjcm9sbFNlbnNpdGl2aXR5XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibW91c2VXaGVlbFpvb21cIl0gPSA1OV0gPSBcIm1vdXNlV2hlZWxab29tXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibXVsdGlDdXJzb3JNZXJnZU92ZXJsYXBwaW5nXCJdID0gNjBdID0gXCJtdWx0aUN1cnNvck1lcmdlT3ZlcmxhcHBpbmdcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtdWx0aUN1cnNvck1vZGlmaWVyXCJdID0gNjFdID0gXCJtdWx0aUN1cnNvck1vZGlmaWVyXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibXVsdGlDdXJzb3JQYXN0ZVwiXSA9IDYyXSA9IFwibXVsdGlDdXJzb3JQYXN0ZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm9jY3VycmVuY2VzSGlnaGxpZ2h0XCJdID0gNjNdID0gXCJvY2N1cnJlbmNlc0hpZ2hsaWdodFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm92ZXJ2aWV3UnVsZXJCb3JkZXJcIl0gPSA2NF0gPSBcIm92ZXJ2aWV3UnVsZXJCb3JkZXJcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJvdmVydmlld1J1bGVyTGFuZXNcIl0gPSA2NV0gPSBcIm92ZXJ2aWV3UnVsZXJMYW5lc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInBhZGRpbmdcIl0gPSA2Nl0gPSBcInBhZGRpbmdcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJwYXJhbWV0ZXJIaW50c1wiXSA9IDY3XSA9IFwicGFyYW1ldGVySGludHNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJwZWVrV2lkZ2V0RGVmYXVsdEZvY3VzXCJdID0gNjhdID0gXCJwZWVrV2lkZ2V0RGVmYXVsdEZvY3VzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZGVmaW5pdGlvbkxpbmtPcGVuc0luUGVla1wiXSA9IDY5XSA9IFwiZGVmaW5pdGlvbkxpbmtPcGVuc0luUGVla1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInF1aWNrU3VnZ2VzdGlvbnNcIl0gPSA3MF0gPSBcInF1aWNrU3VnZ2VzdGlvbnNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJxdWlja1N1Z2dlc3Rpb25zRGVsYXlcIl0gPSA3MV0gPSBcInF1aWNrU3VnZ2VzdGlvbnNEZWxheVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJlYWRPbmx5XCJdID0gNzJdID0gXCJyZWFkT25seVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJlbmFtZU9uVHlwZVwiXSA9IDczXSA9IFwicmVuYW1lT25UeXBlXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicmVuZGVyQ29udHJvbENoYXJhY3RlcnNcIl0gPSA3NF0gPSBcInJlbmRlckNvbnRyb2xDaGFyYWN0ZXJzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicmVuZGVySW5kZW50R3VpZGVzXCJdID0gNzVdID0gXCJyZW5kZXJJbmRlbnRHdWlkZXNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZW5kZXJGaW5hbE5ld2xpbmVcIl0gPSA3Nl0gPSBcInJlbmRlckZpbmFsTmV3bGluZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJlbmRlckxpbmVIaWdobGlnaHRcIl0gPSA3N10gPSBcInJlbmRlckxpbmVIaWdobGlnaHRcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZW5kZXJMaW5lSGlnaGxpZ2h0T25seVdoZW5Gb2N1c1wiXSA9IDc4XSA9IFwicmVuZGVyTGluZUhpZ2hsaWdodE9ubHlXaGVuRm9jdXNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZW5kZXJWYWxpZGF0aW9uRGVjb3JhdGlvbnNcIl0gPSA3OV0gPSBcInJlbmRlclZhbGlkYXRpb25EZWNvcmF0aW9uc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJlbmRlcldoaXRlc3BhY2VcIl0gPSA4MF0gPSBcInJlbmRlcldoaXRlc3BhY2VcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZXZlYWxIb3Jpem9udGFsUmlnaHRQYWRkaW5nXCJdID0gODFdID0gXCJyZXZlYWxIb3Jpem9udGFsUmlnaHRQYWRkaW5nXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicm91bmRlZFNlbGVjdGlvblwiXSA9IDgyXSA9IFwicm91bmRlZFNlbGVjdGlvblwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJ1bGVyc1wiXSA9IDgzXSA9IFwicnVsZXJzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2Nyb2xsYmFyXCJdID0gODRdID0gXCJzY3JvbGxiYXJcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzY3JvbGxCZXlvbmRMYXN0Q29sdW1uXCJdID0gODVdID0gXCJzY3JvbGxCZXlvbmRMYXN0Q29sdW1uXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2Nyb2xsQmV5b25kTGFzdExpbmVcIl0gPSA4Nl0gPSBcInNjcm9sbEJleW9uZExhc3RMaW5lXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2Nyb2xsUHJlZG9taW5hbnRBeGlzXCJdID0gODddID0gXCJzY3JvbGxQcmVkb21pbmFudEF4aXNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzZWxlY3Rpb25DbGlwYm9hcmRcIl0gPSA4OF0gPSBcInNlbGVjdGlvbkNsaXBib2FyZFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNlbGVjdGlvbkhpZ2hsaWdodFwiXSA9IDg5XSA9IFwic2VsZWN0aW9uSGlnaGxpZ2h0XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2VsZWN0T25MaW5lTnVtYmVyc1wiXSA9IDkwXSA9IFwic2VsZWN0T25MaW5lTnVtYmVyc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNob3dGb2xkaW5nQ29udHJvbHNcIl0gPSA5MV0gPSBcInNob3dGb2xkaW5nQ29udHJvbHNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzaG93VW51c2VkXCJdID0gOTJdID0gXCJzaG93VW51c2VkXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic25pcHBldFN1Z2dlc3Rpb25zXCJdID0gOTNdID0gXCJzbmlwcGV0U3VnZ2VzdGlvbnNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzbW9vdGhTY3JvbGxpbmdcIl0gPSA5NF0gPSBcInNtb290aFNjcm9sbGluZ1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInN0b3BSZW5kZXJpbmdMaW5lQWZ0ZXJcIl0gPSA5NV0gPSBcInN0b3BSZW5kZXJpbmdMaW5lQWZ0ZXJcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzdWdnZXN0XCJdID0gOTZdID0gXCJzdWdnZXN0XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic3VnZ2VzdEZvbnRTaXplXCJdID0gOTddID0gXCJzdWdnZXN0Rm9udFNpemVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzdWdnZXN0TGluZUhlaWdodFwiXSA9IDk4XSA9IFwic3VnZ2VzdExpbmVIZWlnaHRcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzdWdnZXN0T25UcmlnZ2VyQ2hhcmFjdGVyc1wiXSA9IDk5XSA9IFwic3VnZ2VzdE9uVHJpZ2dlckNoYXJhY3RlcnNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzdWdnZXN0U2VsZWN0aW9uXCJdID0gMTAwXSA9IFwic3VnZ2VzdFNlbGVjdGlvblwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInRhYkNvbXBsZXRpb25cIl0gPSAxMDFdID0gXCJ0YWJDb21wbGV0aW9uXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1widGFiSW5kZXhcIl0gPSAxMDJdID0gXCJ0YWJJbmRleFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInVudXN1YWxMaW5lVGVybWluYXRvcnNcIl0gPSAxMDNdID0gXCJ1bnVzdWFsTGluZVRlcm1pbmF0b3JzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1widXNlVGFiU3RvcHNcIl0gPSAxMDRdID0gXCJ1c2VUYWJTdG9wc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndvcmRTZXBhcmF0b3JzXCJdID0gMTA1XSA9IFwid29yZFNlcGFyYXRvcnNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3b3JkV3JhcFwiXSA9IDEwNl0gPSBcIndvcmRXcmFwXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid29yZFdyYXBCcmVha0FmdGVyQ2hhcmFjdGVyc1wiXSA9IDEwN10gPSBcIndvcmRXcmFwQnJlYWtBZnRlckNoYXJhY3RlcnNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3b3JkV3JhcEJyZWFrQmVmb3JlQ2hhcmFjdGVyc1wiXSA9IDEwOF0gPSBcIndvcmRXcmFwQnJlYWtCZWZvcmVDaGFyYWN0ZXJzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid29yZFdyYXBDb2x1bW5cIl0gPSAxMDldID0gXCJ3b3JkV3JhcENvbHVtblwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndvcmRXcmFwTWluaWZpZWRcIl0gPSAxMTBdID0gXCJ3b3JkV3JhcE1pbmlmaWVkXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid3JhcHBpbmdJbmRlbnRcIl0gPSAxMTFdID0gXCJ3cmFwcGluZ0luZGVudFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndyYXBwaW5nU3RyYXRlZ3lcIl0gPSAxMTJdID0gXCJ3cmFwcGluZ1N0cmF0ZWd5XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2hvd0RlcHJlY2F0ZWRcIl0gPSAxMTNdID0gXCJzaG93RGVwcmVjYXRlZFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImVkaXRvckNsYXNzTmFtZVwiXSA9IDExNF0gPSBcImVkaXRvckNsYXNzTmFtZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInBpeGVsUmF0aW9cIl0gPSAxMTVdID0gXCJwaXhlbFJhdGlvXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1widGFiRm9jdXNNb2RlXCJdID0gMTE2XSA9IFwidGFiRm9jdXNNb2RlXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGF5b3V0SW5mb1wiXSA9IDExN10gPSBcImxheW91dEluZm9cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3cmFwcGluZ0luZm9cIl0gPSAxMThdID0gXCJ3cmFwcGluZ0luZm9cIjtcclxufSkoRWRpdG9yT3B0aW9uIHx8IChFZGl0b3JPcHRpb24gPSB7fSkpO1xyXG4vKipcclxuICogRW5kIG9mIGxpbmUgY2hhcmFjdGVyIHByZWZlcmVuY2UuXHJcbiAqL1xyXG5leHBvcnQgdmFyIEVuZE9mTGluZVByZWZlcmVuY2U7XHJcbihmdW5jdGlvbiAoRW5kT2ZMaW5lUHJlZmVyZW5jZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgdGhlIGVuZCBvZiBsaW5lIGNoYXJhY3RlciBpZGVudGlmaWVkIGluIHRoZSB0ZXh0IGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgRW5kT2ZMaW5lUHJlZmVyZW5jZVtFbmRPZkxpbmVQcmVmZXJlbmNlW1wiVGV4dERlZmluZWRcIl0gPSAwXSA9IFwiVGV4dERlZmluZWRcIjtcclxuICAgIC8qKlxyXG4gICAgICogVXNlIGxpbmUgZmVlZCAoXFxuKSBhcyB0aGUgZW5kIG9mIGxpbmUgY2hhcmFjdGVyLlxyXG4gICAgICovXHJcbiAgICBFbmRPZkxpbmVQcmVmZXJlbmNlW0VuZE9mTGluZVByZWZlcmVuY2VbXCJMRlwiXSA9IDFdID0gXCJMRlwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgY2FycmlhZ2UgcmV0dXJuIGFuZCBsaW5lIGZlZWQgKFxcclxcbikgYXMgdGhlIGVuZCBvZiBsaW5lIGNoYXJhY3Rlci5cclxuICAgICAqL1xyXG4gICAgRW5kT2ZMaW5lUHJlZmVyZW5jZVtFbmRPZkxpbmVQcmVmZXJlbmNlW1wiQ1JMRlwiXSA9IDJdID0gXCJDUkxGXCI7XHJcbn0pKEVuZE9mTGluZVByZWZlcmVuY2UgfHwgKEVuZE9mTGluZVByZWZlcmVuY2UgPSB7fSkpO1xyXG4vKipcclxuICogRW5kIG9mIGxpbmUgY2hhcmFjdGVyIHByZWZlcmVuY2UuXHJcbiAqL1xyXG5leHBvcnQgdmFyIEVuZE9mTGluZVNlcXVlbmNlO1xyXG4oZnVuY3Rpb24gKEVuZE9mTGluZVNlcXVlbmNlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFVzZSBsaW5lIGZlZWQgKFxcbikgYXMgdGhlIGVuZCBvZiBsaW5lIGNoYXJhY3Rlci5cclxuICAgICAqL1xyXG4gICAgRW5kT2ZMaW5lU2VxdWVuY2VbRW5kT2ZMaW5lU2VxdWVuY2VbXCJMRlwiXSA9IDBdID0gXCJMRlwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgY2FycmlhZ2UgcmV0dXJuIGFuZCBsaW5lIGZlZWQgKFxcclxcbikgYXMgdGhlIGVuZCBvZiBsaW5lIGNoYXJhY3Rlci5cclxuICAgICAqL1xyXG4gICAgRW5kT2ZMaW5lU2VxdWVuY2VbRW5kT2ZMaW5lU2VxdWVuY2VbXCJDUkxGXCJdID0gMV0gPSBcIkNSTEZcIjtcclxufSkoRW5kT2ZMaW5lU2VxdWVuY2UgfHwgKEVuZE9mTGluZVNlcXVlbmNlID0ge30pKTtcclxuLyoqXHJcbiAqIERlc2NyaWJlcyB3aGF0IHRvIGRvIHdpdGggdGhlIGluZGVudGF0aW9uIHdoZW4gcHJlc3NpbmcgRW50ZXIuXHJcbiAqL1xyXG5leHBvcnQgdmFyIEluZGVudEFjdGlvbjtcclxuKGZ1bmN0aW9uIChJbmRlbnRBY3Rpb24pIHtcclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0IG5ldyBsaW5lIGFuZCBjb3B5IHRoZSBwcmV2aW91cyBsaW5lJ3MgaW5kZW50YXRpb24uXHJcbiAgICAgKi9cclxuICAgIEluZGVudEFjdGlvbltJbmRlbnRBY3Rpb25bXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0IG5ldyBsaW5lIGFuZCBpbmRlbnQgb25jZSAocmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIGxpbmUncyBpbmRlbnRhdGlvbikuXHJcbiAgICAgKi9cclxuICAgIEluZGVudEFjdGlvbltJbmRlbnRBY3Rpb25bXCJJbmRlbnRcIl0gPSAxXSA9IFwiSW5kZW50XCI7XHJcbiAgICAvKipcclxuICAgICAqIEluc2VydCB0d28gbmV3IGxpbmVzOlxyXG4gICAgICogIC0gdGhlIGZpcnN0IG9uZSBpbmRlbnRlZCB3aGljaCB3aWxsIGhvbGQgdGhlIGN1cnNvclxyXG4gICAgICogIC0gdGhlIHNlY29uZCBvbmUgYXQgdGhlIHNhbWUgaW5kZW50YXRpb24gbGV2ZWxcclxuICAgICAqL1xyXG4gICAgSW5kZW50QWN0aW9uW0luZGVudEFjdGlvbltcIkluZGVudE91dGRlbnRcIl0gPSAyXSA9IFwiSW5kZW50T3V0ZGVudFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnQgbmV3IGxpbmUgYW5kIG91dGRlbnQgb25jZSAocmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIGxpbmUncyBpbmRlbnRhdGlvbikuXHJcbiAgICAgKi9cclxuICAgIEluZGVudEFjdGlvbltJbmRlbnRBY3Rpb25bXCJPdXRkZW50XCJdID0gM10gPSBcIk91dGRlbnRcIjtcclxufSkoSW5kZW50QWN0aW9uIHx8IChJbmRlbnRBY3Rpb24gPSB7fSkpO1xyXG4vKipcclxuICogVmlydHVhbCBLZXkgQ29kZXMsIHRoZSB2YWx1ZSBkb2VzIG5vdCBob2xkIGFueSBpbmhlcmVudCBtZWFuaW5nLlxyXG4gKiBJbnNwaXJlZCBzb21ld2hhdCBmcm9tIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2RkMzc1NzMxKHY9dnMuODUpLmFzcHhcclxuICogQnV0IHRoZXNlIGFyZSBcIm1vcmUgZ2VuZXJhbFwiLCBhcyB0aGV5IHNob3VsZCB3b3JrIGFjcm9zcyBicm93c2VycyAmIE9TYHMuXHJcbiAqL1xyXG5leHBvcnQgdmFyIEtleUNvZGU7XHJcbihmdW5jdGlvbiAoS2V5Q29kZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBQbGFjZWQgZmlyc3QgdG8gY292ZXIgdGhlIDAgdmFsdWUgb2YgdGhlIGVudW0uXHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlVua25vd25cIl0gPSAwXSA9IFwiVW5rbm93blwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQmFja3NwYWNlXCJdID0gMV0gPSBcIkJhY2tzcGFjZVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiVGFiXCJdID0gMl0gPSBcIlRhYlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRW50ZXJcIl0gPSAzXSA9IFwiRW50ZXJcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlNoaWZ0XCJdID0gNF0gPSBcIlNoaWZ0XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJDdHJsXCJdID0gNV0gPSBcIkN0cmxcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkFsdFwiXSA9IDZdID0gXCJBbHRcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlBhdXNlQnJlYWtcIl0gPSA3XSA9IFwiUGF1c2VCcmVha1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQ2Fwc0xvY2tcIl0gPSA4XSA9IFwiQ2Fwc0xvY2tcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkVzY2FwZVwiXSA9IDldID0gXCJFc2NhcGVcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlNwYWNlXCJdID0gMTBdID0gXCJTcGFjZVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiUGFnZVVwXCJdID0gMTFdID0gXCJQYWdlVXBcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlBhZ2VEb3duXCJdID0gMTJdID0gXCJQYWdlRG93blwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRW5kXCJdID0gMTNdID0gXCJFbmRcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkhvbWVcIl0gPSAxNF0gPSBcIkhvbWVcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkxlZnRBcnJvd1wiXSA9IDE1XSA9IFwiTGVmdEFycm93XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJVcEFycm93XCJdID0gMTZdID0gXCJVcEFycm93XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJSaWdodEFycm93XCJdID0gMTddID0gXCJSaWdodEFycm93XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEb3duQXJyb3dcIl0gPSAxOF0gPSBcIkRvd25BcnJvd1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiSW5zZXJ0XCJdID0gMTldID0gXCJJbnNlcnRcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRlbGV0ZVwiXSA9IDIwXSA9IFwiRGVsZXRlXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfMFwiXSA9IDIxXSA9IFwiS0VZXzBcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV8xXCJdID0gMjJdID0gXCJLRVlfMVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZXzJcIl0gPSAyM10gPSBcIktFWV8yXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfM1wiXSA9IDI0XSA9IFwiS0VZXzNcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV80XCJdID0gMjVdID0gXCJLRVlfNFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZXzVcIl0gPSAyNl0gPSBcIktFWV81XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfNlwiXSA9IDI3XSA9IFwiS0VZXzZcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV83XCJdID0gMjhdID0gXCJLRVlfN1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZXzhcIl0gPSAyOV0gPSBcIktFWV84XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfOVwiXSA9IDMwXSA9IFwiS0VZXzlcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9BXCJdID0gMzFdID0gXCJLRVlfQVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0JcIl0gPSAzMl0gPSBcIktFWV9CXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfQ1wiXSA9IDMzXSA9IFwiS0VZX0NcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9EXCJdID0gMzRdID0gXCJLRVlfRFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0VcIl0gPSAzNV0gPSBcIktFWV9FXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfRlwiXSA9IDM2XSA9IFwiS0VZX0ZcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9HXCJdID0gMzddID0gXCJLRVlfR1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0hcIl0gPSAzOF0gPSBcIktFWV9IXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfSVwiXSA9IDM5XSA9IFwiS0VZX0lcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9KXCJdID0gNDBdID0gXCJLRVlfSlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0tcIl0gPSA0MV0gPSBcIktFWV9LXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfTFwiXSA9IDQyXSA9IFwiS0VZX0xcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9NXCJdID0gNDNdID0gXCJLRVlfTVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX05cIl0gPSA0NF0gPSBcIktFWV9OXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfT1wiXSA9IDQ1XSA9IFwiS0VZX09cIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9QXCJdID0gNDZdID0gXCJLRVlfUFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1FcIl0gPSA0N10gPSBcIktFWV9RXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfUlwiXSA9IDQ4XSA9IFwiS0VZX1JcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9TXCJdID0gNDldID0gXCJLRVlfU1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1RcIl0gPSA1MF0gPSBcIktFWV9UXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfVVwiXSA9IDUxXSA9IFwiS0VZX1VcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9WXCJdID0gNTJdID0gXCJLRVlfVlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1dcIl0gPSA1M10gPSBcIktFWV9XXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfWFwiXSA9IDU0XSA9IFwiS0VZX1hcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9ZXCJdID0gNTVdID0gXCJLRVlfWVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1pcIl0gPSA1Nl0gPSBcIktFWV9aXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJNZXRhXCJdID0gNTddID0gXCJNZXRhXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJDb250ZXh0TWVudVwiXSA9IDU4XSA9IFwiQ29udGV4dE1lbnVcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxXCJdID0gNTldID0gXCJGMVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjJcIl0gPSA2MF0gPSBcIkYyXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGM1wiXSA9IDYxXSA9IFwiRjNcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkY0XCJdID0gNjJdID0gXCJGNFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjVcIl0gPSA2M10gPSBcIkY1XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGNlwiXSA9IDY0XSA9IFwiRjZcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkY3XCJdID0gNjVdID0gXCJGN1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjhcIl0gPSA2Nl0gPSBcIkY4XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGOVwiXSA9IDY3XSA9IFwiRjlcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxMFwiXSA9IDY4XSA9IFwiRjEwXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTFcIl0gPSA2OV0gPSBcIkYxMVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjEyXCJdID0gNzBdID0gXCJGMTJcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxM1wiXSA9IDcxXSA9IFwiRjEzXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTRcIl0gPSA3Ml0gPSBcIkYxNFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjE1XCJdID0gNzNdID0gXCJGMTVcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxNlwiXSA9IDc0XSA9IFwiRjE2XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTdcIl0gPSA3NV0gPSBcIkYxN1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjE4XCJdID0gNzZdID0gXCJGMThcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxOVwiXSA9IDc3XSA9IFwiRjE5XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1Mb2NrXCJdID0gNzhdID0gXCJOdW1Mb2NrXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJTY3JvbGxMb2NrXCJdID0gNzldID0gXCJTY3JvbGxMb2NrXCI7XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgZm9yIG1pc2NlbGxhbmVvdXMgY2hhcmFjdGVyczsgaXQgY2FuIHZhcnkgYnkga2V5Ym9hcmQuXHJcbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJzs6JyBrZXlcclxuICAgICAqL1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiVVNfU0VNSUNPTE9OXCJdID0gODBdID0gXCJVU19TRU1JQ09MT05cIjtcclxuICAgIC8qKlxyXG4gICAgICogRm9yIGFueSBjb3VudHJ5L3JlZ2lvbiwgdGhlICcrJyBrZXlcclxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnPSsnIGtleVxyXG4gICAgICovXHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJVU19FUVVBTFwiXSA9IDgxXSA9IFwiVVNfRVFVQUxcIjtcclxuICAgIC8qKlxyXG4gICAgICogRm9yIGFueSBjb3VudHJ5L3JlZ2lvbiwgdGhlICcsJyBrZXlcclxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnLDwnIGtleVxyXG4gICAgICovXHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJVU19DT01NQVwiXSA9IDgyXSA9IFwiVVNfQ09NTUFcIjtcclxuICAgIC8qKlxyXG4gICAgICogRm9yIGFueSBjb3VudHJ5L3JlZ2lvbiwgdGhlICctJyBrZXlcclxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnLV8nIGtleVxyXG4gICAgICovXHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJVU19NSU5VU1wiXSA9IDgzXSA9IFwiVVNfTUlOVVNcIjtcclxuICAgIC8qKlxyXG4gICAgICogRm9yIGFueSBjb3VudHJ5L3JlZ2lvbiwgdGhlICcuJyBrZXlcclxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnLj4nIGtleVxyXG4gICAgICovXHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJVU19ET1RcIl0gPSA4NF0gPSBcIlVTX0RPVFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxyXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICcvPycga2V5XHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlVTX1NMQVNIXCJdID0gODVdID0gXCJVU19TTEFTSFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxyXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICdgficga2V5XHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlVTX0JBQ0tUSUNLXCJdID0gODZdID0gXCJVU19CQUNLVElDS1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxyXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICdbeycga2V5XHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlVTX09QRU5fU1FVQVJFX0JSQUNLRVRcIl0gPSA4N10gPSBcIlVTX09QRU5fU1FVQVJFX0JSQUNLRVRcIjtcclxuICAgIC8qKlxyXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cclxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnXFx8JyBrZXlcclxuICAgICAqL1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiVVNfQkFDS1NMQVNIXCJdID0gODhdID0gXCJVU19CQUNLU0xBU0hcIjtcclxuICAgIC8qKlxyXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cclxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnXX0nIGtleVxyXG4gICAgICovXHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJVU19DTE9TRV9TUVVBUkVfQlJBQ0tFVFwiXSA9IDg5XSA9IFwiVVNfQ0xPU0VfU1FVQVJFX0JSQUNLRVRcIjtcclxuICAgIC8qKlxyXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cclxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnJ1wiJyBrZXlcclxuICAgICAqL1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiVVNfUVVPVEVcIl0gPSA5MF0gPSBcIlVTX1FVT1RFXCI7XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgZm9yIG1pc2NlbGxhbmVvdXMgY2hhcmFjdGVyczsgaXQgY2FuIHZhcnkgYnkga2V5Ym9hcmQuXHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk9FTV84XCJdID0gOTFdID0gXCJPRU1fOFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFaXRoZXIgdGhlIGFuZ2xlIGJyYWNrZXQga2V5IG9yIHRoZSBiYWNrc2xhc2gga2V5IG9uIHRoZSBSVCAxMDIta2V5IGtleWJvYXJkLlxyXG4gICAgICovXHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJPRU1fMTAyXCJdID0gOTJdID0gXCJPRU1fMTAyXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOVU1QQURfMFwiXSA9IDkzXSA9IFwiTlVNUEFEXzBcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk5VTVBBRF8xXCJdID0gOTRdID0gXCJOVU1QQURfMVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTlVNUEFEXzJcIl0gPSA5NV0gPSBcIk5VTVBBRF8yXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOVU1QQURfM1wiXSA9IDk2XSA9IFwiTlVNUEFEXzNcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk5VTVBBRF80XCJdID0gOTddID0gXCJOVU1QQURfNFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTlVNUEFEXzVcIl0gPSA5OF0gPSBcIk5VTVBBRF81XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOVU1QQURfNlwiXSA9IDk5XSA9IFwiTlVNUEFEXzZcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk5VTVBBRF83XCJdID0gMTAwXSA9IFwiTlVNUEFEXzdcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk5VTVBBRF84XCJdID0gMTAxXSA9IFwiTlVNUEFEXzhcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk5VTVBBRF85XCJdID0gMTAyXSA9IFwiTlVNUEFEXzlcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk5VTVBBRF9NVUxUSVBMWVwiXSA9IDEwM10gPSBcIk5VTVBBRF9NVUxUSVBMWVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTlVNUEFEX0FERFwiXSA9IDEwNF0gPSBcIk5VTVBBRF9BRERcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk5VTVBBRF9TRVBBUkFUT1JcIl0gPSAxMDVdID0gXCJOVU1QQURfU0VQQVJBVE9SXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOVU1QQURfU1VCVFJBQ1RcIl0gPSAxMDZdID0gXCJOVU1QQURfU1VCVFJBQ1RcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk5VTVBBRF9ERUNJTUFMXCJdID0gMTA3XSA9IFwiTlVNUEFEX0RFQ0lNQUxcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk5VTVBBRF9ESVZJREVcIl0gPSAxMDhdID0gXCJOVU1QQURfRElWSURFXCI7XHJcbiAgICAvKipcclxuICAgICAqIENvdmVyIGFsbCBrZXkgY29kZXMgd2hlbiBJTUUgaXMgcHJvY2Vzc2luZyBpbnB1dC5cclxuICAgICAqL1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0lOX0NPTVBPU0lUSU9OXCJdID0gMTA5XSA9IFwiS0VZX0lOX0NPTVBPU0lUSU9OXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJBQk5UX0MxXCJdID0gMTEwXSA9IFwiQUJOVF9DMVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQUJOVF9DMlwiXSA9IDExMV0gPSBcIkFCTlRfQzJcIjtcclxuICAgIC8qKlxyXG4gICAgICogUGxhY2VkIGxhc3QgdG8gY292ZXIgdGhlIGxlbmd0aCBvZiB0aGUgZW51bS5cclxuICAgICAqIFBsZWFzZSBkbyBub3QgZGVwZW5kIG9uIHRoaXMgdmFsdWUhXHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk1BWF9WQUxVRVwiXSA9IDExMl0gPSBcIk1BWF9WQUxVRVwiO1xyXG59KShLZXlDb2RlIHx8IChLZXlDb2RlID0ge30pKTtcclxuZXhwb3J0IHZhciBNYXJrZXJTZXZlcml0eTtcclxuKGZ1bmN0aW9uIChNYXJrZXJTZXZlcml0eSkge1xyXG4gICAgTWFya2VyU2V2ZXJpdHlbTWFya2VyU2V2ZXJpdHlbXCJIaW50XCJdID0gMV0gPSBcIkhpbnRcIjtcclxuICAgIE1hcmtlclNldmVyaXR5W01hcmtlclNldmVyaXR5W1wiSW5mb1wiXSA9IDJdID0gXCJJbmZvXCI7XHJcbiAgICBNYXJrZXJTZXZlcml0eVtNYXJrZXJTZXZlcml0eVtcIldhcm5pbmdcIl0gPSA0XSA9IFwiV2FybmluZ1wiO1xyXG4gICAgTWFya2VyU2V2ZXJpdHlbTWFya2VyU2V2ZXJpdHlbXCJFcnJvclwiXSA9IDhdID0gXCJFcnJvclwiO1xyXG59KShNYXJrZXJTZXZlcml0eSB8fCAoTWFya2VyU2V2ZXJpdHkgPSB7fSkpO1xyXG5leHBvcnQgdmFyIE1hcmtlclRhZztcclxuKGZ1bmN0aW9uIChNYXJrZXJUYWcpIHtcclxuICAgIE1hcmtlclRhZ1tNYXJrZXJUYWdbXCJVbm5lY2Vzc2FyeVwiXSA9IDFdID0gXCJVbm5lY2Vzc2FyeVwiO1xyXG4gICAgTWFya2VyVGFnW01hcmtlclRhZ1tcIkRlcHJlY2F0ZWRcIl0gPSAyXSA9IFwiRGVwcmVjYXRlZFwiO1xyXG59KShNYXJrZXJUYWcgfHwgKE1hcmtlclRhZyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBQb3NpdGlvbiBpbiB0aGUgbWluaW1hcCB0byByZW5kZXIgdGhlIGRlY29yYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgdmFyIE1pbmltYXBQb3NpdGlvbjtcclxuKGZ1bmN0aW9uIChNaW5pbWFwUG9zaXRpb24pIHtcclxuICAgIE1pbmltYXBQb3NpdGlvbltNaW5pbWFwUG9zaXRpb25bXCJJbmxpbmVcIl0gPSAxXSA9IFwiSW5saW5lXCI7XHJcbiAgICBNaW5pbWFwUG9zaXRpb25bTWluaW1hcFBvc2l0aW9uW1wiR3V0dGVyXCJdID0gMl0gPSBcIkd1dHRlclwiO1xyXG59KShNaW5pbWFwUG9zaXRpb24gfHwgKE1pbmltYXBQb3NpdGlvbiA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUeXBlIG9mIGhpdCBlbGVtZW50IHdpdGggdGhlIG1vdXNlIGluIHRoZSBlZGl0b3IuXHJcbiAqL1xyXG5leHBvcnQgdmFyIE1vdXNlVGFyZ2V0VHlwZTtcclxuKGZ1bmN0aW9uIChNb3VzZVRhcmdldFR5cGUpIHtcclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIGFuIHVua25vd24gZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIlVOS05PV05cIl0gPSAwXSA9IFwiVU5LTk9XTlwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgdGhlIHRleHRhcmVhIHVzZWQgZm9yIGlucHV0LlxyXG4gICAgICovXHJcbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiVEVYVEFSRUFcIl0gPSAxXSA9IFwiVEVYVEFSRUFcIjtcclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIHRoZSBnbHlwaCBtYXJnaW5cclxuICAgICAqL1xyXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIkdVVFRFUl9HTFlQSF9NQVJHSU5cIl0gPSAyXSA9IFwiR1VUVEVSX0dMWVBIX01BUkdJTlwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgdGhlIGxpbmUgbnVtYmVyc1xyXG4gICAgICovXHJcbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiR1VUVEVSX0xJTkVfTlVNQkVSU1wiXSA9IDNdID0gXCJHVVRURVJfTElORV9OVU1CRVJTXCI7XHJcbiAgICAvKipcclxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiB0aGUgbGluZSBkZWNvcmF0aW9uc1xyXG4gICAgICovXHJcbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiR1VUVEVSX0xJTkVfREVDT1JBVElPTlNcIl0gPSA0XSA9IFwiR1VUVEVSX0xJTkVfREVDT1JBVElPTlNcIjtcclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIHRoZSB3aGl0ZXNwYWNlIGxlZnQgaW4gdGhlIGd1dHRlciBieSBhIHZpZXcgem9uZS5cclxuICAgICAqL1xyXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIkdVVFRFUl9WSUVXX1pPTkVcIl0gPSA1XSA9IFwiR1VUVEVSX1ZJRVdfWk9ORVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgdGV4dCBpbiB0aGUgY29udGVudC5cclxuICAgICAqL1xyXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIkNPTlRFTlRfVEVYVFwiXSA9IDZdID0gXCJDT05URU5UX1RFWFRcIjtcclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIGVtcHR5IHNwYWNlIGluIHRoZSBjb250ZW50IChlLmcuIGFmdGVyIGxpbmUgdGV4dCBvciBiZWxvdyBsYXN0IGxpbmUpXHJcbiAgICAgKi9cclxuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJDT05URU5UX0VNUFRZXCJdID0gN10gPSBcIkNPTlRFTlRfRU1QVFlcIjtcclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIGEgdmlldyB6b25lIGluIHRoZSBjb250ZW50LlxyXG4gICAgICovXHJcbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiQ09OVEVOVF9WSUVXX1pPTkVcIl0gPSA4XSA9IFwiQ09OVEVOVF9WSUVXX1pPTkVcIjtcclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIGEgY29udGVudCB3aWRnZXQuXHJcbiAgICAgKi9cclxuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJDT05URU5UX1dJREdFVFwiXSA9IDldID0gXCJDT05URU5UX1dJREdFVFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgdGhlIGRlY29yYXRpb25zIG92ZXJ2aWV3IHJ1bGVyLlxyXG4gICAgICovXHJcbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiT1ZFUlZJRVdfUlVMRVJcIl0gPSAxMF0gPSBcIk9WRVJWSUVXX1JVTEVSXCI7XHJcbiAgICAvKipcclxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiBhIHNjcm9sbGJhci5cclxuICAgICAqL1xyXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIlNDUk9MTEJBUlwiXSA9IDExXSA9IFwiU0NST0xMQkFSXCI7XHJcbiAgICAvKipcclxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiBhbiBvdmVybGF5IHdpZGdldC5cclxuICAgICAqL1xyXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIk9WRVJMQVlfV0lER0VUXCJdID0gMTJdID0gXCJPVkVSTEFZX1dJREdFVFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBpcyBvdXRzaWRlIG9mIHRoZSBlZGl0b3IuXHJcbiAgICAgKi9cclxuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJPVVRTSURFX0VESVRPUlwiXSA9IDEzXSA9IFwiT1VUU0lERV9FRElUT1JcIjtcclxufSkoTW91c2VUYXJnZXRUeXBlIHx8IChNb3VzZVRhcmdldFR5cGUgPSB7fSkpO1xyXG4vKipcclxuICogQSBwb3NpdGlvbmluZyBwcmVmZXJlbmNlIGZvciByZW5kZXJpbmcgb3ZlcmxheSB3aWRnZXRzLlxyXG4gKi9cclxuZXhwb3J0IHZhciBPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlO1xyXG4oZnVuY3Rpb24gKE92ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2UpIHtcclxuICAgIC8qKlxyXG4gICAgICogUG9zaXRpb24gdGhlIG92ZXJsYXkgd2lkZ2V0IGluIHRoZSB0b3AgcmlnaHQgY29ybmVyXHJcbiAgICAgKi9cclxuICAgIE92ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtcIlRPUF9SSUdIVF9DT1JORVJcIl0gPSAwXSA9IFwiVE9QX1JJR0hUX0NPUk5FUlwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQb3NpdGlvbiB0aGUgb3ZlcmxheSB3aWRnZXQgaW4gdGhlIGJvdHRvbSByaWdodCBjb3JuZXJcclxuICAgICAqL1xyXG4gICAgT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW1wiQk9UVE9NX1JJR0hUX0NPUk5FUlwiXSA9IDFdID0gXCJCT1RUT01fUklHSFRfQ09STkVSXCI7XHJcbiAgICAvKipcclxuICAgICAqIFBvc2l0aW9uIHRoZSBvdmVybGF5IHdpZGdldCBpbiB0aGUgdG9wIGNlbnRlclxyXG4gICAgICovXHJcbiAgICBPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW092ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbXCJUT1BfQ0VOVEVSXCJdID0gMl0gPSBcIlRPUF9DRU5URVJcIjtcclxufSkoT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZSB8fCAoT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBWZXJ0aWNhbCBMYW5lIGluIHRoZSBvdmVydmlldyBydWxlciBvZiB0aGUgZWRpdG9yLlxyXG4gKi9cclxuZXhwb3J0IHZhciBPdmVydmlld1J1bGVyTGFuZTtcclxuKGZ1bmN0aW9uIChPdmVydmlld1J1bGVyTGFuZSkge1xyXG4gICAgT3ZlcnZpZXdSdWxlckxhbmVbT3ZlcnZpZXdSdWxlckxhbmVbXCJMZWZ0XCJdID0gMV0gPSBcIkxlZnRcIjtcclxuICAgIE92ZXJ2aWV3UnVsZXJMYW5lW092ZXJ2aWV3UnVsZXJMYW5lW1wiQ2VudGVyXCJdID0gMl0gPSBcIkNlbnRlclwiO1xyXG4gICAgT3ZlcnZpZXdSdWxlckxhbmVbT3ZlcnZpZXdSdWxlckxhbmVbXCJSaWdodFwiXSA9IDRdID0gXCJSaWdodFwiO1xyXG4gICAgT3ZlcnZpZXdSdWxlckxhbmVbT3ZlcnZpZXdSdWxlckxhbmVbXCJGdWxsXCJdID0gN10gPSBcIkZ1bGxcIjtcclxufSkoT3ZlcnZpZXdSdWxlckxhbmUgfHwgKE92ZXJ2aWV3UnVsZXJMYW5lID0ge30pKTtcclxuZXhwb3J0IHZhciBSZW5kZXJMaW5lTnVtYmVyc1R5cGU7XHJcbihmdW5jdGlvbiAoUmVuZGVyTGluZU51bWJlcnNUeXBlKSB7XHJcbiAgICBSZW5kZXJMaW5lTnVtYmVyc1R5cGVbUmVuZGVyTGluZU51bWJlcnNUeXBlW1wiT2ZmXCJdID0gMF0gPSBcIk9mZlwiO1xyXG4gICAgUmVuZGVyTGluZU51bWJlcnNUeXBlW1JlbmRlckxpbmVOdW1iZXJzVHlwZVtcIk9uXCJdID0gMV0gPSBcIk9uXCI7XHJcbiAgICBSZW5kZXJMaW5lTnVtYmVyc1R5cGVbUmVuZGVyTGluZU51bWJlcnNUeXBlW1wiUmVsYXRpdmVcIl0gPSAyXSA9IFwiUmVsYXRpdmVcIjtcclxuICAgIFJlbmRlckxpbmVOdW1iZXJzVHlwZVtSZW5kZXJMaW5lTnVtYmVyc1R5cGVbXCJJbnRlcnZhbFwiXSA9IDNdID0gXCJJbnRlcnZhbFwiO1xyXG4gICAgUmVuZGVyTGluZU51bWJlcnNUeXBlW1JlbmRlckxpbmVOdW1iZXJzVHlwZVtcIkN1c3RvbVwiXSA9IDRdID0gXCJDdXN0b21cIjtcclxufSkoUmVuZGVyTGluZU51bWJlcnNUeXBlIHx8IChSZW5kZXJMaW5lTnVtYmVyc1R5cGUgPSB7fSkpO1xyXG5leHBvcnQgdmFyIFJlbmRlck1pbmltYXA7XHJcbihmdW5jdGlvbiAoUmVuZGVyTWluaW1hcCkge1xyXG4gICAgUmVuZGVyTWluaW1hcFtSZW5kZXJNaW5pbWFwW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XHJcbiAgICBSZW5kZXJNaW5pbWFwW1JlbmRlck1pbmltYXBbXCJUZXh0XCJdID0gMV0gPSBcIlRleHRcIjtcclxuICAgIFJlbmRlck1pbmltYXBbUmVuZGVyTWluaW1hcFtcIkJsb2Nrc1wiXSA9IDJdID0gXCJCbG9ja3NcIjtcclxufSkoUmVuZGVyTWluaW1hcCB8fCAoUmVuZGVyTWluaW1hcCA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgU2Nyb2xsVHlwZTtcclxuKGZ1bmN0aW9uIChTY3JvbGxUeXBlKSB7XHJcbiAgICBTY3JvbGxUeXBlW1Njcm9sbFR5cGVbXCJTbW9vdGhcIl0gPSAwXSA9IFwiU21vb3RoXCI7XHJcbiAgICBTY3JvbGxUeXBlW1Njcm9sbFR5cGVbXCJJbW1lZGlhdGVcIl0gPSAxXSA9IFwiSW1tZWRpYXRlXCI7XHJcbn0pKFNjcm9sbFR5cGUgfHwgKFNjcm9sbFR5cGUgPSB7fSkpO1xyXG5leHBvcnQgdmFyIFNjcm9sbGJhclZpc2liaWxpdHk7XHJcbihmdW5jdGlvbiAoU2Nyb2xsYmFyVmlzaWJpbGl0eSkge1xyXG4gICAgU2Nyb2xsYmFyVmlzaWJpbGl0eVtTY3JvbGxiYXJWaXNpYmlsaXR5W1wiQXV0b1wiXSA9IDFdID0gXCJBdXRvXCI7XHJcbiAgICBTY3JvbGxiYXJWaXNpYmlsaXR5W1Njcm9sbGJhclZpc2liaWxpdHlbXCJIaWRkZW5cIl0gPSAyXSA9IFwiSGlkZGVuXCI7XHJcbiAgICBTY3JvbGxiYXJWaXNpYmlsaXR5W1Njcm9sbGJhclZpc2liaWxpdHlbXCJWaXNpYmxlXCJdID0gM10gPSBcIlZpc2libGVcIjtcclxufSkoU2Nyb2xsYmFyVmlzaWJpbGl0eSB8fCAoU2Nyb2xsYmFyVmlzaWJpbGl0eSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgZGlyZWN0aW9uIG9mIGEgc2VsZWN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IHZhciBTZWxlY3Rpb25EaXJlY3Rpb247XHJcbihmdW5jdGlvbiAoU2VsZWN0aW9uRGlyZWN0aW9uKSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzZWxlY3Rpb24gc3RhcnRzIGFib3ZlIHdoZXJlIGl0IGVuZHMuXHJcbiAgICAgKi9cclxuICAgIFNlbGVjdGlvbkRpcmVjdGlvbltTZWxlY3Rpb25EaXJlY3Rpb25bXCJMVFJcIl0gPSAwXSA9IFwiTFRSXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzZWxlY3Rpb24gc3RhcnRzIGJlbG93IHdoZXJlIGl0IGVuZHMuXHJcbiAgICAgKi9cclxuICAgIFNlbGVjdGlvbkRpcmVjdGlvbltTZWxlY3Rpb25EaXJlY3Rpb25bXCJSVExcIl0gPSAxXSA9IFwiUlRMXCI7XHJcbn0pKFNlbGVjdGlvbkRpcmVjdGlvbiB8fCAoU2VsZWN0aW9uRGlyZWN0aW9uID0ge30pKTtcclxuZXhwb3J0IHZhciBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQ7XHJcbihmdW5jdGlvbiAoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kKSB7XHJcbiAgICBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1wiSW52b2tlXCJdID0gMV0gPSBcIkludm9rZVwiO1xyXG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1NpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtcIlRyaWdnZXJDaGFyYWN0ZXJcIl0gPSAyXSA9IFwiVHJpZ2dlckNoYXJhY3RlclwiO1xyXG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1NpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtcIkNvbnRlbnRDaGFuZ2VcIl0gPSAzXSA9IFwiQ29udGVudENoYW5nZVwiO1xyXG59KShTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQgfHwgKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBBIHN5bWJvbCBraW5kLlxyXG4gKi9cclxuZXhwb3J0IHZhciBTeW1ib2xLaW5kO1xyXG4oZnVuY3Rpb24gKFN5bWJvbEtpbmQpIHtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkZpbGVcIl0gPSAwXSA9IFwiRmlsZVwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiTW9kdWxlXCJdID0gMV0gPSBcIk1vZHVsZVwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiTmFtZXNwYWNlXCJdID0gMl0gPSBcIk5hbWVzcGFjZVwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiUGFja2FnZVwiXSA9IDNdID0gXCJQYWNrYWdlXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJDbGFzc1wiXSA9IDRdID0gXCJDbGFzc1wiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiTWV0aG9kXCJdID0gNV0gPSBcIk1ldGhvZFwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiUHJvcGVydHlcIl0gPSA2XSA9IFwiUHJvcGVydHlcIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkZpZWxkXCJdID0gN10gPSBcIkZpZWxkXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJDb25zdHJ1Y3RvclwiXSA9IDhdID0gXCJDb25zdHJ1Y3RvclwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiRW51bVwiXSA9IDldID0gXCJFbnVtXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJJbnRlcmZhY2VcIl0gPSAxMF0gPSBcIkludGVyZmFjZVwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiRnVuY3Rpb25cIl0gPSAxMV0gPSBcIkZ1bmN0aW9uXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJWYXJpYWJsZVwiXSA9IDEyXSA9IFwiVmFyaWFibGVcIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkNvbnN0YW50XCJdID0gMTNdID0gXCJDb25zdGFudFwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiU3RyaW5nXCJdID0gMTRdID0gXCJTdHJpbmdcIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIk51bWJlclwiXSA9IDE1XSA9IFwiTnVtYmVyXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJCb29sZWFuXCJdID0gMTZdID0gXCJCb29sZWFuXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJBcnJheVwiXSA9IDE3XSA9IFwiQXJyYXlcIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIk9iamVjdFwiXSA9IDE4XSA9IFwiT2JqZWN0XCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJLZXlcIl0gPSAxOV0gPSBcIktleVwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiTnVsbFwiXSA9IDIwXSA9IFwiTnVsbFwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiRW51bU1lbWJlclwiXSA9IDIxXSA9IFwiRW51bU1lbWJlclwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiU3RydWN0XCJdID0gMjJdID0gXCJTdHJ1Y3RcIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkV2ZW50XCJdID0gMjNdID0gXCJFdmVudFwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiT3BlcmF0b3JcIl0gPSAyNF0gPSBcIk9wZXJhdG9yXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJUeXBlUGFyYW1ldGVyXCJdID0gMjVdID0gXCJUeXBlUGFyYW1ldGVyXCI7XHJcbn0pKFN5bWJvbEtpbmQgfHwgKFN5bWJvbEtpbmQgPSB7fSkpO1xyXG5leHBvcnQgdmFyIFN5bWJvbFRhZztcclxuKGZ1bmN0aW9uIChTeW1ib2xUYWcpIHtcclxuICAgIFN5bWJvbFRhZ1tTeW1ib2xUYWdbXCJEZXByZWNhdGVkXCJdID0gMV0gPSBcIkRlcHJlY2F0ZWRcIjtcclxufSkoU3ltYm9sVGFnIHx8IChTeW1ib2xUYWcgPSB7fSkpO1xyXG4vKipcclxuICogVGhlIGtpbmQgb2YgYW5pbWF0aW9uIGluIHdoaWNoIHRoZSBlZGl0b3IncyBjdXJzb3Igc2hvdWxkIGJlIHJlbmRlcmVkLlxyXG4gKi9cclxuZXhwb3J0IHZhciBUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZTtcclxuKGZ1bmN0aW9uIChUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBIaWRkZW5cclxuICAgICAqL1xyXG4gICAgVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbXCJIaWRkZW5cIl0gPSAwXSA9IFwiSGlkZGVuXCI7XHJcbiAgICAvKipcclxuICAgICAqIEJsaW5raW5nXHJcbiAgICAgKi9cclxuICAgIFRleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlW1RleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlW1wiQmxpbmtcIl0gPSAxXSA9IFwiQmxpbmtcIjtcclxuICAgIC8qKlxyXG4gICAgICogQmxpbmtpbmcgd2l0aCBzbW9vdGggZmFkaW5nXHJcbiAgICAgKi9cclxuICAgIFRleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlW1RleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlW1wiU21vb3RoXCJdID0gMl0gPSBcIlNtb290aFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCbGlua2luZyB3aXRoIHByb2xvbmdlZCBmaWxsZWQgc3RhdGUgYW5kIHNtb290aCBmYWRpbmdcclxuICAgICAqL1xyXG4gICAgVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbXCJQaGFzZVwiXSA9IDNdID0gXCJQaGFzZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBhbmQgY29sbGFwc2UgYW5pbWF0aW9uIG9uIHRoZSB5IGF4aXNcclxuICAgICAqL1xyXG4gICAgVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbXCJFeHBhbmRcIl0gPSA0XSA9IFwiRXhwYW5kXCI7XHJcbiAgICAvKipcclxuICAgICAqIE5vLUJsaW5raW5nXHJcbiAgICAgKi9cclxuICAgIFRleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlW1RleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlW1wiU29saWRcIl0gPSA1XSA9IFwiU29saWRcIjtcclxufSkoVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGUgfHwgKFRleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBzdHlsZSBpbiB3aGljaCB0aGUgZWRpdG9yJ3MgY3Vyc29yIHNob3VsZCBiZSByZW5kZXJlZC5cclxuICovXHJcbmV4cG9ydCB2YXIgVGV4dEVkaXRvckN1cnNvclN0eWxlO1xyXG4oZnVuY3Rpb24gKFRleHRFZGl0b3JDdXJzb3JTdHlsZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcyBhIHZlcnRpY2FsIGxpbmUgKHNpdHRpbmcgYmV0d2VlbiB0d28gY2hhcmFjdGVycykuXHJcbiAgICAgKi9cclxuICAgIFRleHRFZGl0b3JDdXJzb3JTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbXCJMaW5lXCJdID0gMV0gPSBcIkxpbmVcIjtcclxuICAgIC8qKlxyXG4gICAgICogQXMgYSBibG9jayAoc2l0dGluZyBvbiB0b3Agb2YgYSBjaGFyYWN0ZXIpLlxyXG4gICAgICovXHJcbiAgICBUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbVGV4dEVkaXRvckN1cnNvclN0eWxlW1wiQmxvY2tcIl0gPSAyXSA9IFwiQmxvY2tcIjtcclxuICAgIC8qKlxyXG4gICAgICogQXMgYSBob3Jpem9udGFsIGxpbmUgKHNpdHRpbmcgdW5kZXIgYSBjaGFyYWN0ZXIpLlxyXG4gICAgICovXHJcbiAgICBUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbVGV4dEVkaXRvckN1cnNvclN0eWxlW1wiVW5kZXJsaW5lXCJdID0gM10gPSBcIlVuZGVybGluZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcyBhIHRoaW4gdmVydGljYWwgbGluZSAoc2l0dGluZyBiZXR3ZWVuIHR3byBjaGFyYWN0ZXJzKS5cclxuICAgICAqL1xyXG4gICAgVGV4dEVkaXRvckN1cnNvclN0eWxlW1RleHRFZGl0b3JDdXJzb3JTdHlsZVtcIkxpbmVUaGluXCJdID0gNF0gPSBcIkxpbmVUaGluXCI7XHJcbiAgICAvKipcclxuICAgICAqIEFzIGFuIG91dGxpbmVkIGJsb2NrIChzaXR0aW5nIG9uIHRvcCBvZiBhIGNoYXJhY3RlcikuXHJcbiAgICAgKi9cclxuICAgIFRleHRFZGl0b3JDdXJzb3JTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbXCJCbG9ja091dGxpbmVcIl0gPSA1XSA9IFwiQmxvY2tPdXRsaW5lXCI7XHJcbiAgICAvKipcclxuICAgICAqIEFzIGEgdGhpbiBob3Jpem9udGFsIGxpbmUgKHNpdHRpbmcgdW5kZXIgYSBjaGFyYWN0ZXIpLlxyXG4gICAgICovXHJcbiAgICBUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbVGV4dEVkaXRvckN1cnNvclN0eWxlW1wiVW5kZXJsaW5lVGhpblwiXSA9IDZdID0gXCJVbmRlcmxpbmVUaGluXCI7XHJcbn0pKFRleHRFZGl0b3JDdXJzb3JTdHlsZSB8fCAoVGV4dEVkaXRvckN1cnNvclN0eWxlID0ge30pKTtcclxuLyoqXHJcbiAqIERlc2NyaWJlcyB0aGUgYmVoYXZpb3Igb2YgZGVjb3JhdGlvbnMgd2hlbiB0eXBpbmcvZWRpdGluZyBuZWFyIHRoZWlyIGVkZ2VzLlxyXG4gKiBOb3RlOiBQbGVhc2UgZG8gbm90IGVkaXQgdGhlIHZhbHVlcywgYXMgdGhleSB2ZXJ5IGNhcmVmdWxseSBtYXRjaCBgRGVjb3JhdGlvblJhbmdlQmVoYXZpb3JgXHJcbiAqL1xyXG5leHBvcnQgdmFyIFRyYWNrZWRSYW5nZVN0aWNraW5lc3M7XHJcbihmdW5jdGlvbiAoVHJhY2tlZFJhbmdlU3RpY2tpbmVzcykge1xyXG4gICAgVHJhY2tlZFJhbmdlU3RpY2tpbmVzc1tUcmFja2VkUmFuZ2VTdGlja2luZXNzW1wiQWx3YXlzR3Jvd3NXaGVuVHlwaW5nQXRFZGdlc1wiXSA9IDBdID0gXCJBbHdheXNHcm93c1doZW5UeXBpbmdBdEVkZ2VzXCI7XHJcbiAgICBUcmFja2VkUmFuZ2VTdGlja2luZXNzW1RyYWNrZWRSYW5nZVN0aWNraW5lc3NbXCJOZXZlckdyb3dzV2hlblR5cGluZ0F0RWRnZXNcIl0gPSAxXSA9IFwiTmV2ZXJHcm93c1doZW5UeXBpbmdBdEVkZ2VzXCI7XHJcbiAgICBUcmFja2VkUmFuZ2VTdGlja2luZXNzW1RyYWNrZWRSYW5nZVN0aWNraW5lc3NbXCJHcm93c09ubHlXaGVuVHlwaW5nQmVmb3JlXCJdID0gMl0gPSBcIkdyb3dzT25seVdoZW5UeXBpbmdCZWZvcmVcIjtcclxuICAgIFRyYWNrZWRSYW5nZVN0aWNraW5lc3NbVHJhY2tlZFJhbmdlU3RpY2tpbmVzc1tcIkdyb3dzT25seVdoZW5UeXBpbmdBZnRlclwiXSA9IDNdID0gXCJHcm93c09ubHlXaGVuVHlwaW5nQWZ0ZXJcIjtcclxufSkoVHJhY2tlZFJhbmdlU3RpY2tpbmVzcyB8fCAoVHJhY2tlZFJhbmdlU3RpY2tpbmVzcyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgaG93IHRvIGluZGVudCB3cmFwcGVkIGxpbmVzLlxyXG4gKi9cclxuZXhwb3J0IHZhciBXcmFwcGluZ0luZGVudDtcclxuKGZ1bmN0aW9uIChXcmFwcGluZ0luZGVudCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBObyBpbmRlbnRhdGlvbiA9PiB3cmFwcGVkIGxpbmVzIGJlZ2luIGF0IGNvbHVtbiAxLlxyXG4gICAgICovXHJcbiAgICBXcmFwcGluZ0luZGVudFtXcmFwcGluZ0luZGVudFtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTYW1lID0+IHdyYXBwZWQgbGluZXMgZ2V0IHRoZSBzYW1lIGluZGVudGF0aW9uIGFzIHRoZSBwYXJlbnQuXHJcbiAgICAgKi9cclxuICAgIFdyYXBwaW5nSW5kZW50W1dyYXBwaW5nSW5kZW50W1wiU2FtZVwiXSA9IDFdID0gXCJTYW1lXCI7XHJcbiAgICAvKipcclxuICAgICAqIEluZGVudCA9PiB3cmFwcGVkIGxpbmVzIGdldCArMSBpbmRlbnRhdGlvbiB0b3dhcmQgdGhlIHBhcmVudC5cclxuICAgICAqL1xyXG4gICAgV3JhcHBpbmdJbmRlbnRbV3JhcHBpbmdJbmRlbnRbXCJJbmRlbnRcIl0gPSAyXSA9IFwiSW5kZW50XCI7XHJcbiAgICAvKipcclxuICAgICAqIERlZXBJbmRlbnQgPT4gd3JhcHBlZCBsaW5lcyBnZXQgKzIgaW5kZW50YXRpb24gdG93YXJkIHRoZSBwYXJlbnQuXHJcbiAgICAgKi9cclxuICAgIFdyYXBwaW5nSW5kZW50W1dyYXBwaW5nSW5kZW50W1wiRGVlcEluZGVudFwiXSA9IDNdID0gXCJEZWVwSW5kZW50XCI7XHJcbn0pKFdyYXBwaW5nSW5kZW50IHx8IChXcmFwcGluZ0luZGVudCA9IHt9KSk7XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyB0b1VpbnQzMiB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3VpbnQuanMnO1xyXG5leHBvcnQgY2xhc3MgUHJlZml4U3VtSW5kZXhPZlJlc3VsdCB7XHJcbiAgICBjb25zdHJ1Y3RvcihpbmRleCwgcmVtYWluZGVyKSB7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMucmVtYWluZGVyID0gcmVtYWluZGVyO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBQcmVmaXhTdW1Db21wdXRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZXMpIHtcclxuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcclxuICAgICAgICB0aGlzLnByZWZpeFN1bSA9IG5ldyBVaW50MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcclxuICAgICAgICB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXggPSBuZXcgSW50MzJBcnJheSgxKTtcclxuICAgICAgICB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gPSAtMTtcclxuICAgIH1cclxuICAgIGluc2VydFZhbHVlcyhpbnNlcnRJbmRleCwgaW5zZXJ0VmFsdWVzKSB7XHJcbiAgICAgICAgaW5zZXJ0SW5kZXggPSB0b1VpbnQzMihpbnNlcnRJbmRleCk7XHJcbiAgICAgICAgY29uc3Qgb2xkVmFsdWVzID0gdGhpcy52YWx1ZXM7XHJcbiAgICAgICAgY29uc3Qgb2xkUHJlZml4U3VtID0gdGhpcy5wcmVmaXhTdW07XHJcbiAgICAgICAgY29uc3QgaW5zZXJ0VmFsdWVzTGVuID0gaW5zZXJ0VmFsdWVzLmxlbmd0aDtcclxuICAgICAgICBpZiAoaW5zZXJ0VmFsdWVzTGVuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgVWludDMyQXJyYXkob2xkVmFsdWVzLmxlbmd0aCArIGluc2VydFZhbHVlc0xlbik7XHJcbiAgICAgICAgdGhpcy52YWx1ZXMuc2V0KG9sZFZhbHVlcy5zdWJhcnJheSgwLCBpbnNlcnRJbmRleCksIDApO1xyXG4gICAgICAgIHRoaXMudmFsdWVzLnNldChvbGRWYWx1ZXMuc3ViYXJyYXkoaW5zZXJ0SW5kZXgpLCBpbnNlcnRJbmRleCArIGluc2VydFZhbHVlc0xlbik7XHJcbiAgICAgICAgdGhpcy52YWx1ZXMuc2V0KGluc2VydFZhbHVlcywgaW5zZXJ0SW5kZXgpO1xyXG4gICAgICAgIGlmIChpbnNlcnRJbmRleCAtIDEgPCB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0pIHtcclxuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdID0gaW5zZXJ0SW5kZXggLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByZWZpeFN1bSA9IG5ldyBVaW50MzJBcnJheSh0aGlzLnZhbHVlcy5sZW5ndGgpO1xyXG4gICAgICAgIGlmICh0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gPj0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnByZWZpeFN1bS5zZXQob2xkUHJlZml4U3VtLnN1YmFycmF5KDAsIHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSArIDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjaGFuZ2VWYWx1ZShpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICBpbmRleCA9IHRvVWludDMyKGluZGV4KTtcclxuICAgICAgICB2YWx1ZSA9IHRvVWludDMyKHZhbHVlKTtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZXNbaW5kZXhdID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsdWVzW2luZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgIGlmIChpbmRleCAtIDEgPCB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0pIHtcclxuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdID0gaW5kZXggLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJlbW92ZVZhbHVlcyhzdGFydEluZGV4LCBjbnQpIHtcclxuICAgICAgICBzdGFydEluZGV4ID0gdG9VaW50MzIoc3RhcnRJbmRleCk7XHJcbiAgICAgICAgY250ID0gdG9VaW50MzIoY250KTtcclxuICAgICAgICBjb25zdCBvbGRWYWx1ZXMgPSB0aGlzLnZhbHVlcztcclxuICAgICAgICBjb25zdCBvbGRQcmVmaXhTdW0gPSB0aGlzLnByZWZpeFN1bTtcclxuICAgICAgICBpZiAoc3RhcnRJbmRleCA+PSBvbGRWYWx1ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG1heENudCA9IG9sZFZhbHVlcy5sZW5ndGggLSBzdGFydEluZGV4O1xyXG4gICAgICAgIGlmIChjbnQgPj0gbWF4Q250KSB7XHJcbiAgICAgICAgICAgIGNudCA9IG1heENudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNudCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IFVpbnQzMkFycmF5KG9sZFZhbHVlcy5sZW5ndGggLSBjbnQpO1xyXG4gICAgICAgIHRoaXMudmFsdWVzLnNldChvbGRWYWx1ZXMuc3ViYXJyYXkoMCwgc3RhcnRJbmRleCksIDApO1xyXG4gICAgICAgIHRoaXMudmFsdWVzLnNldChvbGRWYWx1ZXMuc3ViYXJyYXkoc3RhcnRJbmRleCArIGNudCksIHN0YXJ0SW5kZXgpO1xyXG4gICAgICAgIHRoaXMucHJlZml4U3VtID0gbmV3IFVpbnQzMkFycmF5KHRoaXMudmFsdWVzLmxlbmd0aCk7XHJcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggLSAxIDwgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSA9IHN0YXJ0SW5kZXggLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdID49IDApIHtcclxuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW0uc2V0KG9sZFByZWZpeFN1bS5zdWJhcnJheSgwLCB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gKyAxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0VG90YWxWYWx1ZSgpIHtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QWNjdW11bGF0ZWRWYWx1ZSh0aGlzLnZhbHVlcy5sZW5ndGggLSAxKTtcclxuICAgIH1cclxuICAgIGdldEFjY3VtdWxhdGVkVmFsdWUoaW5kZXgpIHtcclxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbmRleCA9IHRvVWludDMyKGluZGV4KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QWNjdW11bGF0ZWRWYWx1ZShpbmRleCk7XHJcbiAgICB9XHJcbiAgICBfZ2V0QWNjdW11bGF0ZWRWYWx1ZShpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA8PSB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlZml4U3VtW2luZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gKyAxO1xyXG4gICAgICAgIGlmIChzdGFydEluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlZml4U3VtWzBdID0gdGhpcy52YWx1ZXNbMF07XHJcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMudmFsdWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMudmFsdWVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDw9IGluZGV4OyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW1baV0gPSB0aGlzLnByZWZpeFN1bVtpIC0gMV0gKyB0aGlzLnZhbHVlc1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdID0gTWF0aC5tYXgodGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdLCBpbmRleCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlZml4U3VtW2luZGV4XTtcclxuICAgIH1cclxuICAgIGdldEluZGV4T2YoYWNjdW11bGF0ZWRWYWx1ZSkge1xyXG4gICAgICAgIGFjY3VtdWxhdGVkVmFsdWUgPSBNYXRoLmZsb29yKGFjY3VtdWxhdGVkVmFsdWUpOyAvL0BwZXJmXHJcbiAgICAgICAgLy8gQ29tcHV0ZSBhbGwgc3VtcyAodG8gZ2V0IGEgZnVsbHkgdmFsaWQgcHJlZml4U3VtKVxyXG4gICAgICAgIHRoaXMuZ2V0VG90YWxWYWx1ZSgpO1xyXG4gICAgICAgIGxldCBsb3cgPSAwO1xyXG4gICAgICAgIGxldCBoaWdoID0gdGhpcy52YWx1ZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICBsZXQgbWlkID0gMDtcclxuICAgICAgICBsZXQgbWlkU3RvcCA9IDA7XHJcbiAgICAgICAgbGV0IG1pZFN0YXJ0ID0gMDtcclxuICAgICAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcclxuICAgICAgICAgICAgbWlkID0gbG93ICsgKChoaWdoIC0gbG93KSAvIDIpIHwgMDtcclxuICAgICAgICAgICAgbWlkU3RvcCA9IHRoaXMucHJlZml4U3VtW21pZF07XHJcbiAgICAgICAgICAgIG1pZFN0YXJ0ID0gbWlkU3RvcCAtIHRoaXMudmFsdWVzW21pZF07XHJcbiAgICAgICAgICAgIGlmIChhY2N1bXVsYXRlZFZhbHVlIDwgbWlkU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQgLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY3VtdWxhdGVkVmFsdWUgPj0gbWlkU3RvcCkge1xyXG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJlZml4U3VtSW5kZXhPZlJlc3VsdChtaWQsIGFjY3VtdWxhdGVkVmFsdWUgLSBtaWRTdGFydCk7XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBTaW1wbGVXb3JrZXJTZXJ2ZXIgfSBmcm9tICcuLi9iYXNlL2NvbW1vbi93b3JrZXIvc2ltcGxlV29ya2VyLmpzJztcclxuaW1wb3J0IHsgRWRpdG9yU2ltcGxlV29ya2VyIH0gZnJvbSAnLi9jb21tb24vc2VydmljZXMvZWRpdG9yU2ltcGxlV29ya2VyLmpzJztcclxubGV0IGluaXRpYWxpemVkID0gZmFsc2U7XHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplKGZvcmVpZ25Nb2R1bGUpIHtcclxuICAgIGlmIChpbml0aWFsaXplZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgIGNvbnN0IHNpbXBsZVdvcmtlciA9IG5ldyBTaW1wbGVXb3JrZXJTZXJ2ZXIoKG1zZykgPT4ge1xyXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UobXNnKTtcclxuICAgIH0sIChob3N0KSA9PiBuZXcgRWRpdG9yU2ltcGxlV29ya2VyKGhvc3QsIGZvcmVpZ25Nb2R1bGUpKTtcclxuICAgIHNlbGYub25tZXNzYWdlID0gKGUpID0+IHtcclxuICAgICAgICBzaW1wbGVXb3JrZXIub25tZXNzYWdlKGUuZGF0YSk7XHJcbiAgICB9O1xyXG59XHJcbnNlbGYub25tZXNzYWdlID0gKGUpID0+IHtcclxuICAgIC8vIElnbm9yZSBmaXJzdCBtZXNzYWdlIGluIHRoaXMgY2FzZSBhbmQgaW5pdGlhbGl6ZSBpZiBub3QgeWV0IGluaXRpYWxpemVkXHJcbiAgICBpZiAoIWluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgaW5pdGlhbGl6ZShudWxsKTtcclxuICAgIH1cclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9